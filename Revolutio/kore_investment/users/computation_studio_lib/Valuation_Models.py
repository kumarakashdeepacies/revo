# Importing neccessary packages
import base64
from datetime import date, datetime, timedelta
from io import BytesIO
from itertools import accumulate
import json
import math
import multiprocessing
import warnings

from dateutil.relativedelta import relativedelta
from joblib import Parallel, delayed, wrap_non_picklable_objects
import matplotlib.pyplot as plt
from numba import float64, guvectorize, int64, njit, void
import numpy as np
import numpy_financial as npf
import pandas as pd
from pandas.core.algorithms import isin, mode
from scipy import optimize
from scipy.interpolate import CubicSpline

from kore_investment.users.computation_studio_lib import (
    OIS_Bootstrapping,
    Options_Pricing,
    Single_Curve_Bootstrapping,
    Swap_Curve,
)
from kore_investment.users.computations.db_centralised_function import read_data_func, update_data_func
import logging
from .Conventions import conventions

class NpEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, np.integer):
            return int(obj)
        elif isinstance(obj, np.floating):
            return float(obj)
        elif isinstance(obj, np.ndarray):
            return obj.tolist()
        elif isinstance(obj, np.datetime64):
            return str(obj)
        elif isinstance(obj, date):
            return obj.strftime("%Y-%m-%d")
        elif isinstance(obj, datetime):
            return obj.strftime("%Y-%m-%d %H:%M:%S")
        else:
            return super().default(obj)


## NUMBA Functions ##
# Cashflow Day of Payment Check


@guvectorize([(int64[:], int64[:], int64, int64[:])], "(n),(n),()->(n)")
def ndays(month, year, start_day, month_day):
    mdays = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    for i in range(month.size):
        month_day[i] = mdays[month[i]] + (
            (month[i] == 2) and (year[i] % 4 == 0) and ((year[i] % 100 != 0) or (year[i] % 400 == 0))
        )

    for i in range(len(month_day)):
        if start_day < month_day[i]:
            month_day[i] = start_day


# linear interpolation
@njit(cache=True, fastmath=True)
def linearinterp(x, y, independent_var_value):
    n = len(x)
    for j in range(1, n):
        if (x[j - 1]) <= independent_var_value <= (x[j]):
            return y[j - 1] + ((y[j] - y[j - 1]) * (independent_var_value - x[j - 1]) / (x[j] - x[j - 1]))


# linear extrapolation
@njit(cache=True, fastmath=True)
def linearexterp(x, y, independent_var_value):
    if independent_var_value > (x[-1]):
        return y[-1] + (independent_var_value - x[-1]) * (y[-1] - y[-2]) / (x[-1] - x[-2])
    elif independent_var_value < x[0]:
        return y[0] + (independent_var_value - x[0]) * (y[1] - y[0]) / (x[1] - x[0])


# cubic spline
def cubicspline(x, y, independent_var_value):
    check = CubicSpline(x, y)
    return check(independent_var_value)


@njit(cache=True, fastmath=True)
def flatexterp(x, y, independent_var_value):
    if independent_var_value > (x[-1]):
        return y[-1]
    elif independent_var_value < x[0]:
        return y[0]


@guvectorize([void(float64[:], float64[:], float64, float64[:])], "(n),(n),()->()")
def linforward(x, y, independent_var_value, result):
    n = len(x)
    for j in range(1, n):
        if (x[j - 1]) < independent_var_value < (x[j]):
            forward0 = (x[j] * y[j] - x[j - 1] * y[j - 1]) / (x[j] - x[j - 1])
            forward1 = (x[j + 1] * y[j + 1] - x[j] * y[j]) / (x[j + 1] - x[j])
            interpolated_forward = forward0 + (
                (forward1 - forward0) * (independent_var_value - x[j - 1]) / (x[j] - x[j - 1])
            )

            result[:] = (
                y[j - 1] * x[j - 1] + interpolated_forward * (independent_var_value - x[j - 1])
            ) / independent_var_value


# piecewise linear
@njit(cache=True, fastmath=True)
def bilinearint(x, y, f, x0, y0):
    w = []
    n = len(x)
    xu = min(c for c in x if c >= x0)
    xl = max(d for d in x if d <= x0)
    yu = min(g for g in y if g >= y0)
    yl = max(h for h in y if h <= y0)
    for j in range(0, n):
        if xl <= x[j] <= xu and yl <= y[j] <= yu:
            w.append([x[j], y[j], f[j]])
    return (
        (w[0][2] * (w[2][0] - x0) * (w[1][1] - y0))
        + (w[2][2] * (x0 - w[0][0]) * (w[1][1] - y0))
        + (w[1][2] * (w[2][0] - x0) * (y0 - w[0][1]))
        + (w[3][2] * (x0 - w[0][0]) * (y0 - w[0][1]))
    ) / ((w[2][0] - w[0][0]) * (w[1][1] - w[0][1]))


# c = coupon rate per period
# y = yield per period
# m = periods per year
# n = periods remaining


def macaulay_duration(c, y, m, n):
    if c == y:
        return ((1 + y) / (m * y)) * (1 - (1 / (1 + y) ** n))
    else:
        return ((1 + y) / (m * y)) - ((1 + y + n * (c - y)) / ((m * c * ((1 + y) ** n - 1)) + m * y))


# Cashflow Amount Calculation
@njit(cache=True, fastmath=True)
def fixed_income_government_cashflows(
    Cashflow_Date, Year_frac, Face_Value, Coupon_Rate, Maturity_Date, Redemption_Amount
):
    Coupon_amount = Face_Value * Coupon_Rate * Year_frac
    Principal_amount = np.where(Cashflow_Date == Maturity_Date, Redemption_Amount[0], 0)
    Total = Coupon_amount + Principal_amount
    return Coupon_amount, Principal_amount, Total


# FIB Government Valuation
@njit(cache=True, fastmath=True)
def fixed_income_valuation(
    TTM_array,
    Total_amount_array,
    zero_rates,
    Coupon_array,
    Principal_array,
    curve_compounding_frequency="Annual",
):
    zero_rate_plus_1bps = zero_rates + 0.0001
    zero_rate_minus_1bps = zero_rates - 0.0001
    if curve_compounding_frequency in ["Continuous", "continuous", "continuously"]:
        df = np.exp(-TTM_array * zero_rates)
        df_plus_1bps = np.exp(-TTM_array * zero_rate_plus_1bps)
        df_minus_1bps = np.exp(-TTM_array * zero_rate_minus_1bps)
    elif curve_compounding_frequency in ["monthly", "Monthly"]:
        df = np.power(1 + zero_rates / 12, -12 * TTM_array)
        df_plus_1bps = np.power(1 + zero_rate_plus_1bps / 12, -12 * TTM_array)
        df_minus_1bps = np.power(1 + zero_rate_minus_1bps / 12, -12 * TTM_array)
    elif curve_compounding_frequency in ["quarterly", "Quarterly"]:
        df = np.power(1 + zero_rates / 4, -4 * TTM_array)
        df_plus_1bps = np.power(1 + zero_rate_plus_1bps / 4, -4 * TTM_array)
        df_minus_1bps = np.power(1 + zero_rate_minus_1bps / 4, -4 * TTM_array)
    elif curve_compounding_frequency in ["semi-annualised", "Semi-Annual", "semi-annually"]:
        df = np.power(1 + zero_rates / 2, -2 * TTM_array)
        df_plus_1bps = np.power(1 + zero_rate_plus_1bps / 2, -2 * TTM_array)
        df_minus_1bps = np.power(1 + zero_rate_minus_1bps / 2, -2 * TTM_array)
    elif curve_compounding_frequency in ["bi-annual", "Bi-Annual", "bi-annually"]:
        df = np.power(1 + zero_rates / 0.5, -0.5 * TTM_array)
        df_plus_1bps = np.power(1 + zero_rate_plus_1bps / 0.5, -0.5 * TTM_array)
        df_minus_1bps = np.power(1 + zero_rate_minus_1bps / 0.5, -0.5 * TTM_array)
    else:
        df = np.power(1 + zero_rates, -TTM_array)
        df_plus_1bps = np.power(1 + zero_rate_plus_1bps, -TTM_array)
        df_minus_1bps = np.power(1 + zero_rate_minus_1bps, -TTM_array)

    PV_table = Total_amount_array * df
    PV_table_plus_1bps = Total_amount_array * df_plus_1bps
    PV_table_minus_1bps = Total_amount_array * df_minus_1bps
    PV_coupons = Coupon_array * df
    PV_principal = Principal_array * df
    PV_output = np.sum(PV_table)
    PV_plus_1bps = np.sum(PV_table_plus_1bps)
    PV_minus_1bps = np.sum(PV_table_minus_1bps)

    return (
            PV_output,
            PV_table,
            TTM_array,
            Total_amount_array,
            df,
            PV_coupons,
            PV_principal,
            PV_plus_1bps,
            PV_minus_1bps,
        )

@njit(cache=True, fastmath=True)
def fixed_income_valuation_investments(
    TTM_array,
    Total_amount_array,
    zero_rates,
    curve_compounding_frequency="Annual",
):
    zero_rate_plus_1bps = zero_rates + 0.0001
    zero_rate_minus_1bps = zero_rates - 0.0001
    if curve_compounding_frequency in ["Continuous", "continuous", "continuously"]:
        df = np.exp(-TTM_array * zero_rates)
        df_plus_1bps = np.exp(-TTM_array * zero_rate_plus_1bps)
        df_minus_1bps = np.exp(-TTM_array * zero_rate_minus_1bps)
    elif curve_compounding_frequency in ["monthly", "Monthly"]:
        df = np.power(1 + zero_rates / 12, -12 * TTM_array)
        df_plus_1bps = np.power(1 + zero_rate_plus_1bps / 12, -12 * TTM_array)
        df_minus_1bps = np.power(1 + zero_rate_minus_1bps / 12, -12 * TTM_array)
    elif curve_compounding_frequency in ["quarterly", "Quarterly"]:
        df = np.power(1 + zero_rates / 4, -4 * TTM_array)
        df_plus_1bps = np.power(1 + zero_rate_plus_1bps / 4, -4 * TTM_array)
        df_minus_1bps = np.power(1 + zero_rate_minus_1bps / 4, -4 * TTM_array)
    elif curve_compounding_frequency in ["semi-annualised", "Semi-Annual", "semi-annually"]:
        df = np.power(1 + zero_rates / 2, -2 * TTM_array)
        df_plus_1bps = np.power(1 + zero_rate_plus_1bps / 2, -2 * TTM_array)
        df_minus_1bps = np.power(1 + zero_rate_minus_1bps / 2, -2 * TTM_array)
    elif curve_compounding_frequency in ["bi-annual", "Bi-Annual", "bi-annually"]:
        df = np.power(1 + zero_rates / 0.5, -0.5 * TTM_array)
        df_plus_1bps = np.power(1 + zero_rate_plus_1bps / 0.5, -0.5 * TTM_array)
        df_minus_1bps = np.power(1 + zero_rate_minus_1bps / 0.5, -0.5 * TTM_array)
    else:
        df = np.power(1 + zero_rates, -TTM_array)
        df_plus_1bps = np.power(1 + zero_rate_plus_1bps, -TTM_array)
        df_minus_1bps = np.power(1 + zero_rate_minus_1bps, -TTM_array)

    PV_table = Total_amount_array * df
    PV_table_plus_1bps = Total_amount_array * df_plus_1bps
    PV_table_minus_1bps = Total_amount_array * df_minus_1bps
    PV_output = np.sum(PV_table)
    PV_plus_1bps = np.sum(PV_table_plus_1bps)
    PV_minus_1bps = np.sum(PV_table_minus_1bps)

    return (
            PV_output,
            PV_table,
            TTM_array,
            Total_amount_array,
            df,
            PV_plus_1bps,
            PV_minus_1bps,
        )

@guvectorize([void(float64[:], float64[:], float64, float64[:])], "(n),(n),()->()")
def fixed_income_valuation_VAR(TTM_array, Total_amount_array, zero_rates, result):
    df = np.exp(-TTM_array * zero_rates)
    PV_table = Total_amount_array * df
    PV_output = np.sum(PV_table)
    result[:] = PV_output


@njit(cache=True, fastmath=True)
def commercial_paper_valuation(
    TTM_Array, Redemption_Amount, all_in_rate, curve_compounding_frequency="Annual"
):
    TTM = TTM_Array[0]
    all_in_rate_plus_1bps = all_in_rate + 0.0001
    all_in_rate_minus_1bps = all_in_rate - 0.0001
    if curve_compounding_frequency in ["Continuous", "continuous", "continuously"]:
        df = np.exp(-TTM * all_in_rate)
        df_plus_1bps = np.exp(-TTM * all_in_rate_plus_1bps)
        df_minus_1bps = np.exp(-TTM * all_in_rate_minus_1bps)
    elif curve_compounding_frequency in ["monthly", "Monthly"]:
        df = np.power(1 + all_in_rate / 12, -12 * TTM)
        df_plus_1bps = np.power(1 + all_in_rate_plus_1bps / 12, -12 * TTM)
        df_minus_1bps = np.power(1 + all_in_rate_minus_1bps / 12, -12 * TTM)
    elif curve_compounding_frequency in ["quarterly", "Quarterly"]:
        df = np.power(1 + all_in_rate / 4, -4 * TTM)
        df_plus_1bps = np.power(1 + all_in_rate_plus_1bps / 4, -4 * TTM)
        df_minus_1bps = np.power(1 + all_in_rate_minus_1bps / 4, -4 * TTM)
    elif curve_compounding_frequency in ["semi-annualised", "Semi-Annual", "semi-annually"]:
        df = np.power(1 + all_in_rate / 2, -2 * TTM)
        df_plus_1bps = np.power(1 + all_in_rate_plus_1bps / 2, -2 * TTM)
        df_minus_1bps = np.power(1 + all_in_rate_minus_1bps / 2, -2 * TTM)
    elif curve_compounding_frequency in ["bi-annual", "Bi-Annual", "bi-annually"]:
        df = np.power(1 + all_in_rate / 0.5, -0.5 * TTM)
        df_plus_1bps = np.power(1 + all_in_rate_plus_1bps / 0.5, -0.5 * TTM)
        df_minus_1bps = np.power(1 + all_in_rate_minus_1bps / 0.5, -0.5 * TTM)
    else:
        df = np.power(1 + all_in_rate, -TTM)
        df_plus_1bps = np.power(1 + all_in_rate_plus_1bps, -TTM)
        df_minus_1bps = np.power(1 + all_in_rate_minus_1bps, -TTM)

    PV = Redemption_Amount * df
    PV_plus_1bps = Redemption_Amount * df_plus_1bps
    PV_minus_1bps = Redemption_Amount * df_minus_1bps
    return PV, TTM_Array, df, PV_plus_1bps, PV_minus_1bps


@njit(cache=True, fastmath=True)
def commercial_paper_mtm_valuation(TTM_Array, Redemption_Amount, ytm, ytm_frequency=1):
    df = 1 / (1 + (ytm / ytm_frequency)) ** (ytm_frequency * (TTM_Array))
    PV = Redemption_Amount * df
    return PV, TTM_Array, df


@njit(cache=True, fastmath=True)
def effective_duration_calc(PV, total_amount, TTM_Array, ytm):
    PV_m1 = np.sum(total_amount * np.exp(-TTM_Array * (ytm - 0.01)))
    PV_p1 = np.sum(total_amount * np.exp(-TTM_Array * (ytm + 0.01)))
    effective_duration = (PV_m1 - PV_p1) / (2 * PV * 0.01)
    return effective_duration


@njit(cache=True, fastmath=True)
def tenor_extraction(tenor, tenor_unit):
    if tenor_unit == "M":
        return int(tenor) / 12
    if tenor_unit == "Y":
        return int(tenor)


def pv_check(present_value, quantity):
    if present_value in ["", None, "None"]:
        return present_value
    else:
        return present_value * quantity


present_value_check_function = np.vectorize(pv_check)


def z_spread_calculation_and_revaluation(
    TTM,
    total_amount_array,
    zero_rates,
    market_data,
    accrued_interest,
    curve_compounding_frequency,
    request,
):
    market_price = market_data["quoted_price"].iloc[0]
    z_spread_value = market_data["z_spread"].iloc[0]

    if str(z_spread_value) in ["nan", "None", ""]:
        dirty_market_price = market_price + accrued_interest
        z_spread_value = valuation_models.z_spread(
            dirty_market_price, TTM, total_amount_array, zero_rates, curve_compounding_frequency
        )
        update_data_func(
            request,
            config_dict={
                "inputs": {
                    "Data_source": "Database",
                    "Table": "Quoted_Security_Data",
                    "Columns": [
                        {
                            "column_name": "z_spread",
                            "input_value": f"{z_spread_value}",
                            "separator": "",
                        },
                    ],
                },
                "condition": [
                    {
                        "column_name": "security_identifier",
                        "condition": "Equal to",
                        "input_value": market_data["security_identifier"].iloc[0],
                        "and_or": "and",
                    },
                    {
                        "column_name": "extract_date",
                        "condition": "Equal to",
                        "input_value": f'{market_data["extract_date"].iloc[0]}',
                        "and_or": "",
                    },
                ],
            },
        )
    (
        PV_output,
        PV_table,
        TTM_array,
        Total_amount_array,
        DF,
        PV_plus_1bps,
        PV_minus_1bps,
    ) = fixed_income_valuation_investments(
        TTM,
        total_amount_array.astype("float64"),
        zero_rates + z_spread_value,
        curve_compounding_frequency=curve_compounding_frequency,
    )
    return (
        PV_output,
        PV_table,
        TTM_array,
        Total_amount_array,
        DF,
        PV_plus_1bps,
        PV_minus_1bps,
    )


def z_spread_calculation_and_revaluation_zcb(
    TTM_array, Redemption_Amount, zero_rates, market_data, curve_compounding_frequency, request
):
    market_price = market_data["quoted_price"].iloc[0]
    z_spread_value = market_data["z_spread"].iloc[0]

    if str(z_spread_value) in ["nan", "None", ""]:
        z_spread_value = valuation_models.z_spread(
            market_price, TTM_array, Redemption_Amount, zero_rates, curve_compounding_frequency
        )
        update_data_func(
            request,
            config_dict={
                "inputs": {
                    "Data_source": "Database",
                    "Table": "Quoted_Security_Data",
                    "Columns": [
                        {
                            "column_name": "z_spread",
                            "input_value": f"{z_spread_value}",
                            "separator": "",
                        },
                    ],
                },
                "condition": [
                    {
                        "column_name": "security_identifier",
                        "condition": "Equal to",
                        "input_value": market_data["security_identifier"].iloc[0],
                        "and_or": "and",
                    },
                    {
                        "column_name": "extract_date",
                        "condition": "Equal to",
                        "input_value": f'{market_data["extract_date"].iloc[0]}',
                        "and_or": "",
                    },
                ],
            },
        )

    PV, TTM_array, df, PV_plus_1bps, PV_minus_1bps = commercial_paper_valuation(
        TTM_array,
        Redemption_Amount,
        zero_rates + z_spread_value,
        curve_compounding_frequency=curve_compounding_frequency,
    )
    return (PV, TTM_array, df, PV_plus_1bps, PV_minus_1bps)


def curve_component_transformation(curve_repo_data_ind):
    curve_components = {"curve_components": list(json.loads(curve_repo_data_ind["curve_components"]).keys())}
    components_new_df = pd.DataFrame(curve_components)
    components_new_df["curve_components"] = components_new_df["curve_components"].astype("int")
    components_new_df["curve_name"] = curve_repo_data_ind["curve_name"]
    components_new_df["interpolation_algorithm"] = curve_repo_data_ind["interpolation_algorithm"]
    components_new_df["extrapolation_algorithm"] = curve_repo_data_ind["extrapolation_algorithm"]
    if "compounding_frequency_output" in curve_repo_data_ind.keys():
        components_new_df["compounding_frequency_output"] = curve_repo_data_ind[
            "compounding_frequency_output"
        ]
    del curve_components
    return components_new_df


def vol_component_transformation(vol_repo):
    surface_components = {
        "vol_surface_component": list(json.loads(vol_repo["vol_surface_components"]).keys())
    }
    components_new_df = pd.DataFrame(surface_components)
    components_new_df["vol_surface_component"] = components_new_df["vol_surface_component"].astype("int")
    components_new_df["surface_name"] = vol_repo["vol_surface_name"]
    components_new_df["interpolation_smile"] = vol_repo["interpolation_smile"]
    components_new_df["interpolation_tenor"] = vol_repo["interpolation_tenor"]
    components_new_df["extrapolation_smile"] = vol_repo["extrapolation_smile"]
    components_new_df["extrapolation_tenor"] = vol_repo["extrapolation_tenor"]
    components_new_df["smile_interpolation_parameter"] = vol_repo["smile_interpolation_parameter"]
    components_new_df["tenor_interpolation_parameter"] = vol_repo["tenor_interpolation_parameter"]
    components_new_df["asset_class"] = vol_repo["asset_class"]
    del surface_components
    return components_new_df


def output_check_fn(
    cashflow_results=None,
    price_df=None,
    valuation_output=None,
):
    output_msg = {}

    if isinstance(cashflow_results, pd.DataFrame):
        nan_df = cashflow_results[pd.isnull(cashflow_results["cashflow"])]
        if len(nan_df) > 1:
            output_msg["CF_Output"] = "Missing"
        else:
            output_msg["CF_Output"] = "Present"

    if isinstance(price_df, pd.DataFrame):
        if len(price_df) > 0:
            if price_df["quoted_price"].notnull().iloc[0]:
                output_msg["Val_df_Output"] = "Present"
            else:
                output_msg["Val_df_Output"] = "Missing"
            if price_df["modified_duration"].notnull().iloc[0] and price_df["yield"].notnull().iloc[0]:
                output_msg["Sensitivity_output"] = "Present"
            else:
                output_msg["Sensitivity_output"] = "Missing"
            if price_df["yield"].notnull().iloc[0]:
                output_msg["YTM_Output"] = "Present"
            else:
                output_msg["YTM_Output"] = "Missing"
        else:
            output_msg["Val_df_Output"] = "Missing"
            output_msg["YTM_Output"] = "Missing"
            output_msg["Sensitivity_output"] = "Missing"
    else:
        output_msg["Val_df_Output"] = "Missing"
        output_msg["YTM_Output"] = "Missing"
        output_msg["Sensitivity_output"] = "Missing"

    if valuation_output:
        if valuation_output == "None":
            output_msg["Val_Output"] = "Missing"
        else:
            output_msg["Val_Output"] = "Present"

    return output_msg


def business_day_val(date, convention, holiday_list, business_days="1111100"):
    # Following
    if convention == 1:
        i = 0
        while np.busday_count(date, date + timedelta(days=i), business_days, holiday_list) == 0:
            if np.busday_count(date, date + timedelta(days=i + 1), business_days, holiday_list) != 0:
                return date + timedelta(days=i)
            i += 1
    # Preceding
    if convention == 2:
        if np.busday_count(date, date + timedelta(days=1), business_days, holiday_list) != 0:
            return date
        else:
            i = 0
            while (
                np.busday_count(
                    date - timedelta(days=i), date + timedelta(days=1), business_days, holiday_list
                )
                == 0
            ):
                if (
                    np.busday_count(
                        date - (timedelta(days=i + 1)), date + timedelta(days=1), business_days, holiday_list
                    )
                    != 0
                ):
                    return date - (timedelta(days=i + 1))
                i += 1

    # Modified Following
    if convention == 3:
        i = 0
        while np.busday_count(date, date + timedelta(days=i), business_days, holiday_list) == 0:
            if np.busday_count(date, date + (timedelta(days=i + 1)), business_days, holiday_list) != 0:
                if (np.datetime64(date) + i).astype(int) % 12 + 1 == np.datetime64(date).astype(int) % 12 + 1:
                    return date + timedelta(days=i)
                else:
                    if np.busday_count(date, date + timedelta(days=1), business_days, holiday_list) != 0:
                        return date
                    else:
                        j = 0
                        while (
                            np.busday_count(
                                date - timedelta(days=j),
                                date + timedelta(days=1),
                                business_days,
                                holiday_list,
                            )
                            == 0
                        ):
                            if (
                                np.busday_count(
                                    date - (timedelta(days=j + 1)),
                                    date + timedelta(days=1),
                                    business_days,
                                    holiday_list,
                                )
                                != 0
                            ):
                                return date - (timedelta(days=j + 1))
                            j += 1
            i += 1

    # No adjustment
    if convention in [5, "EOM"]:
        return date


## Valuation Models Central Class ##
class Valuation_Models:
    # Function to calculate cashflow payment days
    def month_range_day(self, start=None, end=None, period=None, reset_identifier=0, stub_date=None):
        # This calculates the total months between the two dates
        month_range = np.arange(start, end + relativedelta(months=1), period, dtype="datetime64[M]")
        # If the month_range is zero, then last repayment date is the end date
        if month_range.size == 0:
            date_list = np.array([end], dtype="datetime64[D]")
        else:
            # This generates the payment dates
            end = np.datetime64(end).astype("datetime64[D]")
            start_day = np.array([start]).astype(datetime)[0].day
            year = month_range.astype("datetime64[Y]").astype(np.int16) + 1970
            month = month_range.astype("datetime64[M]").astype(np.int16) % 12 + 1
            month_day = ndays(month, year, start_day)
            date_list = np.array(
                [datetime(year[i], month[i], month_day[i]) for i in range(month.size)], dtype="datetime64[D]"
            )
            # This equates last repayment date equal to payment date
            if date_list[-1] == end:
                date_list
            else:
                if reset_identifier == 0:
                    date_list = np.append(date_list, end)
            if reset_identifier == 0:
                date_list = np.delete(date_list, np.where(date_list > end)[0], axis=0)
            beginning_dates = np.delete(date_list, [len(date_list) - 1])
            end_dates = np.delete(date_list, [0])
        return beginning_dates, end_dates

    # Coupon Frequency code generator
    def coupon_Frequency(self, coupon_frequency, coupon_frequency_unit):
        if coupon_frequency_unit == "D":
            c = float(365.25 / float(coupon_frequency))
            return c
        elif coupon_frequency_unit == "M":
            c = 12 / float(coupon_frequency)
            return c
        elif coupon_frequency_unit == "Y":
            c = 1 / float(coupon_frequency)
            return c
        elif coupon_frequency_unit == "Q":
            c = 4 / float(coupon_frequency)
            return c

    # BusDay code generator
    def busday_convention_code(self, bus_day_convention):
        if bus_day_convention in ["Following", "following"]:
            c = 1
            return c
        elif bus_day_convention in ["Preceding", "preceding"]:
            c = 2
            return c
        elif bus_day_convention in ["Modified Following", "modified following"]:
            c = 3
            return c
        elif bus_day_convention in ["Modified Following Bimonthly", "modified following bimonthly"]:
            c = 4
            return c
        elif bus_day_convention in ["EOM"]:
            c = "EOM"
            return c
        else:
            c = 5
            return c

    # DayCount code generator
    def daycount_convention_code(self, daycount_convention):
        if daycount_convention in ["30/360_Bond_Basis", "30/360"]:
            c = 1
            return c
        elif daycount_convention == "30/360_US":
            c = 2
            return c
        elif daycount_convention == "30E/360":
            c = 3
            return c
        elif daycount_convention == "30E/360_ISDA":
            c = 4
            return c
        elif daycount_convention == "30E+/360_ISDA":
            c = 5
            return c
        elif daycount_convention == "ACT/360":
            c = 6
            return c
        elif daycount_convention in ["ACT/365", "ACTUAL/365", "Act/365"]:
            c = 7
            return c
        elif daycount_convention == "ACT/365L":
            c = 8
            return c
        elif daycount_convention == "ACT/365A":
            c = 9
            return c
        elif daycount_convention == "NL/365":
            c = 10
            return c
        elif daycount_convention == "ACT/ACT_ISDA":
            c = 11
            return c
        elif daycount_convention == "ACT/ACT_ICMA":
            c = 12
            return c
        elif daycount_convention == "Business/252":
            c = 13
            return c
        elif daycount_convention in ["ACT/ACT", "ACTUAL/ACTUAL"]:
            c = 14
            return c
        else:
            return daycount_convention

    # Cashflow Dates,YearFrac and Amount calculation
    def fixed_coupon_cashflow_generation(
        self,
        Unique_Reference_Id,
        Issue_Date,
        Maturity_date,
        Face_Value,
        Redemption_Amount,
        Coupon_Rate,
        Coupon_Frequency,
        Coupon_Frequency_unit,
        Valuation_Date,
        Discount_Daycount,
        Accrual_Daycount,
        Discount_Curve,
        Business_day_convention,
        Last_coupon_date,
        holiday_calendar,
        custom_daycount_conventions=None,
        accrued_interest=None,
        interest_calculation_methodology="Simple",
        compounding_frequency=None,
        compounding_frequency_unit=None,
        stub_date=None,
        business_days="1111100",
        moratorium_end_date="",
        moratorium_flag="N",
        interest_moratorium_flag="N",
        model_code="",
        principal_business_day_convention = None,
    ):

        if Discount_Daycount == "COUPON/FREQUENCY":
            Discount_Daycount = "ACT/365"
        elif Discount_Daycount == "ACTUAL/365":
            Discount_Daycount = "ACT/365"
        else:
            pass
        if Accrual_Daycount == "COUPON/FREQUENCY":
            Accrual_Daycount = "ACT/365"
        elif Accrual_Daycount == "ACTUAL/365":
            Accrual_Daycount = "ACT/365"
        else:
            pass

        if str(Coupon_Frequency) in ["nan", "None", "-"]:
            Coupon_Frequency = None
        if str(Coupon_Frequency_unit) in ["nan", "None", "-"]:
            Coupon_Frequency_unit = None

        if Coupon_Frequency and Coupon_Frequency_unit:
            coupon_frequency = self.coupon_Frequency(Coupon_Frequency, Coupon_Frequency_unit)

            if str(Last_coupon_date) in ["None", "NaT", "-", "nan"]:
                if str(stub_date) in ["None", "NaT", "-", "nan"]:
                    Begining_Date_array, Ending_Date_array = self.month_range_day(
                        Issue_Date, Maturity_date[0], int(12 / coupon_frequency)
                    )
                else:
                    Begining_Date_array_0 = np.array([Issue_Date], dtype="datetime64[D]")
                    Ending_Date_array_0 = np.array([stub_date], dtype="datetime64[D]")
                    Begining_Date_array, Ending_Date_array = self.month_range_day(
                        stub_date,
                        Maturity_date[0],
                        int(12 / coupon_frequency),
                    )
                    Begining_Date_array = np.concatenate((Begining_Date_array_0, Begining_Date_array))
                    Ending_Date_array = np.concatenate((Ending_Date_array_0, Ending_Date_array))
            else:
                Begining_Date_array, Ending_Date_array = self.month_range_day(
                    Last_coupon_date, Maturity_date[0], int(12 / coupon_frequency)
                )
            payout = "Cashflow_Schedule"
        else:
            Begining_Date_array = np.array([Issue_Date], dtype="datetime64[D]")
            Ending_Date_array = np.array(Maturity_date, dtype="datetime64[D]")
            payout = "Maturity"

        Begining_Date_array = Begining_Date_array.astype("datetime64[D]")
        Ending_Date_array = Ending_Date_array.astype("datetime64[D]")

        accrual_convention_code = self.daycount_convention_code(Accrual_Daycount)
        discount_convention_code = self.daycount_convention_code(Discount_Daycount)
        Cashflow_Date_array = np.empty([0], dtype="datetime64[D]")
        
        if principal_business_day_convention in ["nan","None","NaT","-",""]:
            principal_business_day_convention = Business_day_convention
        
        principal_business_convention_code = self.busday_convention_code(principal_business_day_convention)
        convention_code = self.busday_convention_code(Business_day_convention)

        Maturity_Date = np.array(
            [business_day_val(Maturity_date[0].date(), principal_business_convention_code, [])], dtype="datetime64[D]"
        )

        del_index = []
        if convention_code == "EOM":
            Cashflow_Date_array = conventions.eomonth(Ending_Date_array, Maturity_date[0])
            Begining_Date_array = conventions.eomonth(Begining_Date_array, Maturity_date[0])
            Begining_Date_array = np.delete(
                Begining_Date_array, np.where(Begining_Date_array == Maturity_date[0])
            )
            Ending_Date_array = conventions.eomonth(Ending_Date_array, Maturity_date[0])
            del_index = np.where(Cashflow_Date_array <= Valuation_Date)
            Ending_Date_array = np.unique(Ending_Date_array[Ending_Date_array > Valuation_Date])
            Cashflow_Date_array = np.unique(Cashflow_Date_array[Cashflow_Date_array > Valuation_Date])
            Begining_Date_array = np.delete(Begining_Date_array, del_index)
        else:
            for i in range(Ending_Date_array.size):
                if Ending_Date_array[i] > Valuation_Date:
                    Cashflow_Date_array = np.append(
                        Cashflow_Date_array,
                        conventions.business_day(
                            Ending_Date_array[i],
                            convention_code,
                            holiday_calendar,
                            business_days=business_days,
                        ),
                    )
                else:
                    del_index.append(i)
        for d_i in sorted(del_index, reverse=True):
            Begining_Date_array = np.delete(Begining_Date_array, d_i)
            Ending_Date_array = np.delete(Ending_Date_array, d_i)
        Year_frac_array = np.empty([0], dtype="float64")

        if interest_moratorium_flag == "Y":
            Cashflow_Date_array = Cashflow_Date_array[Cashflow_Date_array > moratorium_end_date]
            Ending_Date_array = Ending_Date_array[Ending_Date_array > moratorium_end_date]
            if str(Last_coupon_date) in ["None", "NaT", "-", "nan"]:
                Begining_Date_array = np.unique(np.append(Begining_Date_array, moratorium_end_date))
            Begining_Date_array = Begining_Date_array[Begining_Date_array >= moratorium_end_date]

        TTM_array = conventions.D_day_count(
            Valuation_Date,
            Cashflow_Date_array,
            discount_convention_code,
            custom_daycount_conventions=custom_daycount_conventions,
        )
        
        TTM_array_principal = conventions.D_day_count(
            Valuation_Date,
            Maturity_Date,
            discount_convention_code,
            custom_daycount_conventions=custom_daycount_conventions,
        )

        if interest_calculation_methodology != "Compound":
            if Coupon_Frequency and Coupon_Frequency_unit:
                if interest_moratorium_flag == "Y":
                    Year_frac_0_value = conventions.A_day_count(
                        Begining_Date_array[0],
                        Ending_Date_array[0],
                        accrual_convention_code,
                        custom_daycount_conventions=custom_daycount_conventions,
                    )
                elif str(Last_coupon_date) in ["None", "NaT", "-", "nan"]:
                    Year_frac_0_value = conventions.A_day_count(
                        np.datetime64(Issue_Date, "D"),
                        Ending_Date_array[0],
                        accrual_convention_code,
                        custom_daycount_conventions=custom_daycount_conventions,
                    )
                else:
                    Year_frac_0_value = conventions.A_day_count(
                        Last_coupon_date,
                        Ending_Date_array[0],
                        accrual_convention_code,
                        custom_daycount_conventions=custom_daycount_conventions,
                    )
            else:
                Year_frac_0_value = conventions.A_day_count(
                    np.datetime64(Issue_Date, "D"),
                    Ending_Date_array[0],
                    accrual_convention_code,
                    custom_daycount_conventions=custom_daycount_conventions,
                )
            if Year_frac_0_value > 0:
                Year_frac_array = np.append(Year_frac_array, Year_frac_0_value)
            else:
                Year_frac_array = np.append(Year_frac_array, 0)

            for i in range(1, Begining_Date_array.size):
                if str(Ending_Date_array[i - 1]) == "NaT":
                    Year_frac_value = conventions.A_day_count(
                        Last_coupon_date,
                        Ending_Date_array[i],
                        accrual_convention_code,
                        custom_daycount_conventions=custom_daycount_conventions,
                    )
                else:
                    Year_frac_value = conventions.A_day_count(
                        Begining_Date_array[i],
                        Ending_Date_array[i],
                        accrual_convention_code,
                        custom_daycount_conventions=custom_daycount_conventions,
                    )

                if Year_frac_value > 0:
                    Year_frac_array = np.append(Year_frac_array, Year_frac_value)
                else:
                    Year_frac_array = np.append(Year_frac_array, 0)

            Coupon_Rate = np.repeat(Coupon_Rate, len(Cashflow_Date_array))
            Face_Value = np.repeat(Face_Value, len(Cashflow_Date_array))

            Coupons, Principal, Total_Amount = fixed_income_government_cashflows(
                Cashflow_Date_array,
                Year_frac_array,
                Face_Value,
                Coupon_Rate,
                Maturity_Date,
                Redemption_Amount,
            )

        else:
            compound_interest_schedule = compound_interest_schedule_generation(
                compounding_frequency,
                compounding_frequency_unit,
                Issue_Date,
                pd.to_datetime(Maturity_date[0], dayfirst=True),
                Begining_Date_array,
                Ending_Date_array,
                Last_coupon_date,
                Redemption_Amount,
                Coupon_Rate,
                discount_convention_code,
                custom_daycount_conventions,
                payout=payout,
                model_code=model_code,
                accrued_interest=accrued_interest,
                valuation_date=Valuation_Date,
            )
            Coupons = compound_interest_schedule.loc[
                (compound_interest_schedule["payout_date"] == 1)
                & (compound_interest_schedule["date"] > Valuation_Date[0]),
                "interest",
            ].to_numpy(dtype="float64")
            Total_Amount = Coupons

        if str(accrued_interest) in ["nan", "None", ""]:
            if str(Last_coupon_date) in ["None", "NaT", "-", "nan"]:
                time_period = conventions.A_day_count(
                    np.datetime64(Issue_Date, "D"),
                    Valuation_Date,
                    accrual_convention_code,
                    custom_daycount_conventions=custom_daycount_conventions,
                )
            else:
                time_period = conventions.A_day_count(
                    Last_coupon_date,
                    Valuation_Date,
                    accrual_convention_code,
                    custom_daycount_conventions=custom_daycount_conventions,
                )
            if interest_calculation_methodology != "Compound":
                # Simple interest
                accrued_interest = Face_Value * Coupon_Rate * time_period
            else:
                # Compound Interest
                accrued_interest_subset = compound_interest_schedule.loc[
                    compound_interest_schedule["date"]
                    == compound_interest_schedule.loc[
                        compound_interest_schedule["date"] <= Valuation_Date[0], "date"
                    ].max()
                ]
                if len(accrued_interest_subset) == 0:
                    # Accrued interest calculation where there is no compounding of interest before the valuation date
                    accrued_interest = (
                        Redemption_Amount
                        * Coupon_Rate
                        * conventions.D_day_count(
                            np.array([Issue_Date], dtype="datetime64[D]"),
                            np.array(Valuation_Date, dtype="datetime64[D]"),
                            discount_convention_code,
                            custom_daycount_conventions=custom_daycount_conventions,
                        )
                    )
                else:
                    if accrued_interest_subset["date"].iloc[0] != Valuation_Date[0]:
                        if accrued_interest_subset["date"].iloc[0] == Last_coupon_date:
                            # Accrued interest calculation where there is no compounding date between the last coupon date and the valuation date
                            accrued_interest = (
                                accrued_interest_subset["outstanding_balance_after_payout"].iloc[0]
                                * Coupon_Rate
                                * time_period
                            )
                        else:
                            # Accrued cumulative interest calculation where there is an interest compounding date between the last coupon date and the valuation date
                            accrued_interest = accrued_interest_subset["interest"].iloc[
                                0
                            ] + accrued_interest_subset["outstanding_balance_after_payout"].iloc[
                                0
                            ] * Coupon_Rate * conventions.D_day_count(
                                np.array(accrued_interest_subset["date"].iloc[0], dtype="datetime64[D]"),
                                np.array(Valuation_Date, dtype="datetime64[D]"),
                                discount_convention_code,
                                custom_daycount_conventions=custom_daycount_conventions,
                            )
                    else:
                        if Last_coupon_date != Valuation_Date[0]:
                            # Accrued cumulative interest as on the last compounding date that is equal to the valuation date
                            accrued_interest = accrued_interest_subset["interest"].iloc[0]
                        else:
                            # Accrued interest as on the valuation date that is equal to the last coupon date
                            accrued_interest = 0

        Unique_Reference_Id = Unique_Reference_Id
        Valuation_Date = Valuation_Date
        
        result_array = [
            Unique_Reference_Id,
            Valuation_Date,
            Cashflow_Date_array,
            TTM_array,
            Coupons,
            Redemption_Amount,
            [],
            accrued_interest,
            Maturity_Date[0],
            TTM_array_principal
        ]
        return result_array

    # YTM Calculation
    def CF_ytm(self, price, TTM_list, CF_list, guess=0.001):
        def ytm_func(y):
            return sum([CF_list[x] * np.exp(-TTM_list[x] * y) for x in range(len(CF_list))]) - price

        return optimize.newton(ytm_func, guess)

    # Z_spread Calculation
    def z_spread(self, price, TTM_list, CF_list, zero_rates, curve_compounding_frequency, guess=0.001):
        def z_spread_func(y):
            if curve_compounding_frequency in ["Continuous", "continuous", "continuously"]:
                return (
                    sum(
                        [CF_list[x] * np.exp(-TTM_list[x] * (zero_rates[x] + y)) for x in range(len(CF_list))]
                    )
                    - price
                )
            elif curve_compounding_frequency in ["monthly", "Monthly"]:
                return (
                    sum(
                        [
                            CF_list[x] * np.power(1 + (zero_rates[x] + y) / 12, -12 * TTM_list[x])
                            for x in range(len(CF_list))
                        ]
                    )
                    - price
                )
            elif curve_compounding_frequency in ["quarterly", "Quarterly"]:
                return (
                    sum(
                        [
                            CF_list[x] * np.power(1 + (zero_rates[x] + y) / 4, -4 * TTM_list[x])
                            for x in range(len(CF_list))
                        ]
                    )
                    - price
                )
            elif curve_compounding_frequency in ["semi-annualised", "Semi-Annual", "semi-annually"]:
                return (
                    sum(
                        [
                            CF_list[x] * np.power(1 + (zero_rates[x] + y) / 2, -2 * TTM_list[x])
                            for x in range(len(CF_list))
                        ]
                    )
                    - price
                )
            elif curve_compounding_frequency in ["bi-annual", "Bi-Annual", "bi-annually"]:
                return (
                    sum(
                        [
                            CF_list[x] * np.power(1 + (zero_rates[x] + y) / 0.5, -0.5 * TTM_list[x])
                            for x in range(len(CF_list))
                        ]
                    )
                    - price
                )
            else:
                return (
                    sum(
                        [
                            CF_list[x] * np.power(1 + (zero_rates[x] + y), -TTM_list[x])
                            for x in range(len(CF_list))
                        ]
                    )
                    - price
                )

        return optimize.newton(z_spread_func, guess)

    # MTM Valuation Method

    def fixed_income_mtm_valuation(
        self, TTM_array, Total_amount_array, Coupons, Principal, ytm, PV=0, ytm_frequency=1
    ):
        df = 1 / (1 + (ytm / ytm_frequency)) ** (ytm_frequency * (TTM_array))
        PV_table = Total_amount_array * df
        PV_coupons = Coupons * df
        PV_principal = Principal * df
        PV_output = np.sum(PV_table)
        return PV_output, PV_table, TTM_array, Total_amount_array, df, PV_coupons, PV_principal

    # Sensitivity Measures Calculation
    def fixed_income_sensitivity_analysis(
        self,
        PV_table,
        TTM_array,
        Total_amount_array,
        Coupon_Frequency,
        Coupon_Frequency_unit,
        PV_Output,
        PV_plus_1bps,
        PV_minus_1bps,
    ):
        macaulay_duration = np.sum(PV_table * TTM_array) / np.sum(PV_table)
        ytm = self.CF_ytm(PV_Output, TTM_array, Total_amount_array)
        PV01 = np.average([abs(PV_plus_1bps - PV_Output), abs(PV_minus_1bps - PV_Output)])
        modified_duration = (10000 * PV01) / PV_Output
        effective_duration = effective_duration_calc(PV_Output, Total_amount_array, TTM_array, ytm)
        return PV01, macaulay_duration, modified_duration, effective_duration, ytm

    def fixed_income_mtm_sensitivity_analysis(
        self,
        modified_duration,
        ytm,
        TTM_array,
        Total_amount_array,
        Coupon_Frequency,
        Coupon_Frequency_unit,
        PV,
        PV_table=None,
        ytm_frequency=1,
    ):
        if np.isnan(ytm):
            ytm = self.CF_ytm(PV, TTM_array, Total_amount_array)
            ytm = np.exp(ytm) - 1
            ytm = ytm[0]
        else:
            pass
        if isinstance(Coupon_Frequency, float):
            Coupon_Frequency = Coupon_Frequency
        else:
            Coupon_Frequency = Coupon_Frequency[0]
        PV_plus_1bps = (
            self.fixed_income_mtm_valuation(
                TTM_array, Total_amount_array, [0], [0], ytm + 0.0001, ytm_frequency=ytm_frequency
            )
        )[0]
        PV_minus_1bps = (
            self.fixed_income_mtm_valuation(
                TTM_array, Total_amount_array, [0], [0], ytm - 0.0001, ytm_frequency=ytm_frequency
            )
        )[0]
        PV01 = np.average([abs(PV_plus_1bps - PV[0]), abs(PV_minus_1bps - PV[0])])
        if np.isnan(modified_duration):
            modified_duration = (10000 * PV01) / PV[0]
            macaulay_duration = modified_duration * (1 + (ytm / ytm_frequency))
        else:
            macaulay_duration = modified_duration * (1 + (ytm / ytm_frequency))
        effective_duration = effective_duration_calc(PV, Total_amount_array, TTM_array, ytm)
        return PV01, macaulay_duration, modified_duration, effective_duration, ytm

    def commercial_paper_sensitivity_analysis(
        self, PV, TTM_Array, Repurchase_Price, PV_plus_1bps, PV_minus_1bps
    ):

        TTM = TTM_Array[0]
        macaulay_duration = PV * TTM / PV
        ytm = self.CF_ytm(PV, TTM_Array, Repurchase_Price)
        PV01 = np.average([abs(PV_plus_1bps - PV), abs(PV_minus_1bps - PV)])
        modified_duration = (10000 * PV01) / PV
        df_m1 = np.exp(-TTM_Array * (ytm - 0.01))
        df_p1 = np.exp(-TTM_Array * (ytm + 0.01))
        PV_m1 = Repurchase_Price * df_m1
        PV_p1 = Repurchase_Price * df_p1
        effective_duration = (PV_m1 - PV_p1) / (2 * PV * 0.01)
        return macaulay_duration, modified_duration, PV01, effective_duration, ytm

    def commercial_paper_mtm_sensitivity_analysis(
        self, PV, TTM_array, Redemption_Amount, ytm=None, modified_duration=None, ytm_frequency=1
    ):
        if np.isnan(ytm):
            ytm = self.CF_ytm(PV, TTM_array, Redemption_Amount)
            ytm = np.exp(ytm) - 1
        else:
            pass
        df_m1bps = 1 / (1 + ((ytm - 0.0001) / ytm_frequency)) ** (ytm_frequency * (TTM_array))
        df_p1bps = 1 / (1 + ((ytm + 0.0001) / ytm_frequency)) ** (ytm_frequency * (TTM_array))
        PV_plus_1bps = Redemption_Amount * df_p1bps
        PV_minus_1bps = Redemption_Amount * df_m1bps
        PV01 = np.average([abs(PV_plus_1bps - PV[0]), abs(PV_minus_1bps - PV[0])])
        if np.isnan(modified_duration):
            modified_duration = (10000 * PV01) / PV[0]
            macaulay_duration = modified_duration * (1 + (ytm / ytm_frequency))
        else:
            macaulay_duration = modified_duration * (1 + (ytm / ytm_frequency))
        df_m1 = 1 / (1 + ((ytm - 0.01) / ytm_frequency)) ** (ytm_frequency * (TTM_array))
        df_p1 = 1 / (1 + ((ytm + 0.01) / ytm_frequency)) ** (ytm_frequency * (TTM_array))
        PV_m1 = Redemption_Amount * df_m1
        PV_p1 = Redemption_Amount * df_p1
        effective_duration = (PV_m1 - PV_p1) / (2 * PV * 0.01)
        return macaulay_duration, modified_duration, PV01, effective_duration, ytm

    # Cashflow Dates,YearFrac and Amount calculation for Floating coupon
    def floating_coupon_cashflow_generation(
        self,
        Unique_Reference_Id,
        Issue_Date,
        Maturity_Date,
        Face_Value,
        Redemption_Amount,
        Spread_Over_Benchmark,
        Coupon_Frequency,
        Coupon_Frequency_unit,
        Valuation_Date,
        Discount_Daycount,
        Accrual_Daycount,
        Discount_Curve,
        Business_day_convention,
        Last_coupon_date,
        Coupon_Benchmark_Curve,
        Next_Repricing_Date,
        Last_Repricing_Date,
        curve_data,
        Repricing_Frequency,
        Repricing_Frequency_unit,
        holiday_calendar,
        current_benchmark_rate=0,
        custom_daycount_conventions=None,
        accrued_interest=None,
        stub_date=None,
        business_days="1111100",
    ):
        coupon_frequency = self.coupon_Frequency(Coupon_Frequency, Coupon_Frequency_unit)
        reset_frequency = self.coupon_Frequency(Repricing_Frequency, Repricing_Frequency_unit)
        if str(Last_coupon_date) in ["None", "NaT", "-", "nan"]:
            if str(stub_date) in ["None", "NaT", "-", "nan"]:
                Begining_Date_array, Ending_Date_array = self.month_range_day(
                    Issue_Date, Maturity_Date[0], int(12 / coupon_frequency)
                )
            else:
                Begining_Date_array_0 = np.array([Issue_Date], dtype="datetime64[D]")
                Ending_Date_array_0 = np.array([stub_date], dtype="datetime64[D]")
                Begining_Date_array, Ending_Date_array = self.month_range_day(
                    stub_date,
                    Maturity_Date[0],
                    int(12 / coupon_frequency),
                )
                Begining_Date_array = np.concatenate((Begining_Date_array_0, Begining_Date_array))
                Ending_Date_array = np.concatenate((Ending_Date_array_0, Ending_Date_array))
        else:
            Begining_Date_array, Ending_Date_array = self.month_range_day(
                Last_coupon_date, Maturity_Date[0], int(12 / coupon_frequency)
            )
        reset_maturity_date = Maturity_Date[0] + relativedelta(months=int(12 / reset_frequency))
        Begining_Reset_Date_array, Ending_Reset_Date_array = self.month_range_day(
            Last_Repricing_Date, reset_maturity_date, int(12 / reset_frequency), reset_identifier=1
        )
        Cashflow_Date_array = np.empty([0], dtype="datetime64[D]")
        convention_code = self.busday_convention_code(Business_day_convention)
        Maturity_Date = np.array(
            [business_day_val(Maturity_Date[0].date(), convention_code, [])], dtype="datetime64[D]"
        )
        del_index = []
        if convention_code == "EOM":
            Cashflow_Date_array = conventions.eomonth(Ending_Date_array, Maturity_Date[0])
            del_index = np.where(Cashflow_Date_array <= Valuation_Date)
            Cashflow_Date_array = np.unique(Cashflow_Date_array[Cashflow_Date_array > Valuation_Date])
            Begining_Date_array = np.delete(Begining_Date_array, del_index)
        else:
            for i in range(Ending_Date_array.size):
                if Ending_Date_array[i] > Valuation_Date:
                    Cashflow_Date_array = np.append(
                        Cashflow_Date_array,
                        conventions.business_day(
                            Ending_Date_array[i],
                            convention_code,
                            holiday_calendar,
                            business_days=business_days,
                        ),
                    )
                else:
                    del_index.append(i)
        for d_i in sorted(del_index, reverse=True):
            Begining_Date_array = np.delete(Begining_Date_array, d_i)
            Ending_Date_array = np.delete(Ending_Date_array, d_i)
        accrual_convention_code = self.daycount_convention_code(Accrual_Daycount)
        discount_convention_code = self.daycount_convention_code(Discount_Daycount)
        if str(accrued_interest) in ["nan", "None", ""]:
            if str(Last_coupon_date) in ["None", "NaT", "-", "nan"]:
                time_period = conventions.A_day_count(
                    np.datetime64(Issue_Date, "D"),
                    Valuation_Date,
                    accrual_convention_code,
                    custom_daycount_conventions=custom_daycount_conventions,
                )
            else:
                time_period = conventions.A_day_count(
                    Last_coupon_date,
                    Valuation_Date,
                    accrual_convention_code,
                    custom_daycount_conventions=custom_daycount_conventions,
                )
            accrued_interest = (
                Face_Value * ((current_benchmark_rate + float(Spread_Over_Benchmark)) / 100) * time_period
            )
        TTM_array = conventions.D_day_count(
            Valuation_Date,
            Cashflow_Date_array,
            discount_convention_code,
            custom_daycount_conventions=custom_daycount_conventions,
        )
        Forward_Begining_Date_array = np.empty([0], dtype="datetime64[D]")
        Forward_Ending_Date_array = np.empty([0], dtype="datetime64[D]")
        spot_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == Coupon_Benchmark_Curve), :]
        interpolation_algorithm = spot_rate_curve_points["interpolation_algorithm"].iloc[0]
        extrapolation_algorithm = spot_rate_curve_points["extrapolation_algorithm"].iloc[0]
        tenor = np.array(spot_rate_curve_points["tenor"], dtype="float64")
        rates = np.array(spot_rate_curve_points["rate"], dtype="float64")
        All_in_rate = np.empty([0], dtype="float64")
        for i in range(Begining_Reset_Date_array.size):
            if Begining_Reset_Date_array[i] >= Valuation_Date:
                begining_date = Begining_Reset_Date_array[i]
                ending_date = Ending_Reset_Date_array[i]
            else:
                begining_date = np.datetime64("NaT")
                ending_date = np.datetime64("NaT")

            Forward_Begining_Date_array = np.append(Forward_Begining_Date_array, begining_date)
            Forward_Ending_Date_array = np.append(Forward_Ending_Date_array, ending_date)
            if begining_date >= Valuation_Date[0]:
                forward_begining_ttm = (begining_date - Valuation_Date[0]).astype("int") / 365
            else:
                forward_begining_ttm = 0
            if ending_date >= Valuation_Date[0]:
                forward_ending_ttm = (ending_date - Valuation_Date[0]).astype("int") / 365
            else:
                forward_ending_ttm = 0
            if interpolation_algorithm == "Linear":
                if linearinterp(tenor, rates, forward_begining_ttm) is None:
                    if extrapolation_algorithm == "Linear":
                        calculated_value = linearexterp(tenor, rates, forward_begining_ttm)
                    else:
                        calculated_value = flatexterp(tenor, rates, forward_begining_ttm)
                else:
                    calculated_value = linearinterp(tenor, rates, forward_begining_ttm)
                if linearinterp(tenor, rates, forward_ending_ttm) is None:
                    if extrapolation_algorithm == "Linear":
                        calculated_value_ending = linearexterp(tenor, rates, forward_ending_ttm)
                    else:
                        calculated_value_ending = flatexterp(tenor, rates, forward_ending_ttm)
                else:
                    calculated_value_ending = linearinterp(tenor, rates, forward_ending_ttm)
            df_begining = (1 / (1 + calculated_value)) ** forward_begining_ttm
            df_ending = (1 / (1 + calculated_value_ending)) ** forward_ending_ttm
            Implied_Forward_Rate_inter = (
                (df_begining / df_ending - 1)
                / conventions.D_day_count(
                    begining_date,
                    ending_date,
                    discount_convention_code,
                    custom_daycount_conventions=custom_daycount_conventions,
                )
            ).astype("float64")
            df_begining = None
            df_ending = None
            del forward_begining_ttm
            del forward_ending_ttm
            del df_begining
            del df_ending
            if i == 0:
                Implied_Forward_Rate_inter = float(current_benchmark_rate) / 100
            if Implied_Forward_Rate_inter in [np.NINF, np.Inf]:
                Implied_Forward_Rate_inter = 0
            All_in_rate = np.append(
                All_in_rate, (Implied_Forward_Rate_inter + float(Spread_Over_Benchmark) / 100)
            )

        tenor = None
        rates = None
        del tenor
        del rates
        del Implied_Forward_Rate_inter
        Coupons = np.empty([0], dtype="float64")
        Principal = np.empty([0], dtype="float64")

        for i in range(Ending_Date_array.size):
            reset_dates_end = Ending_Reset_Date_array[
                np.where(
                    (Ending_Reset_Date_array > Begining_Date_array[i])
                    & (Ending_Reset_Date_array <= Ending_Date_array[i])
                )
            ]
            total_coupon = 0
            if reset_dates_end.size > 0:
                for j in range(reset_dates_end.size):
                    rate = All_in_rate[np.where(Ending_Reset_Date_array == reset_dates_end[j])]
                    if j == 0:
                        year_frac = conventions.A_day_count(
                            Begining_Date_array[i],
                            reset_dates_end[j],
                            accrual_convention_code,
                            custom_daycount_conventions=custom_daycount_conventions,
                        )
                    else:
                        year_frac = conventions.A_day_count(
                            reset_dates_end[j - 1],
                            reset_dates_end[j],
                            accrual_convention_code,
                            custom_daycount_conventions=custom_daycount_conventions,
                        )
                    total_coupon += rate * year_frac * Face_Value
                if reset_dates_end[-1] != Ending_Date_array[i]:
                    rate = All_in_rate[np.where(Begining_Reset_Date_array == reset_dates_end[-1])]
                    year_frac = conventions.A_day_count(
                        reset_dates_end[-1],
                        Ending_Date_array[i],
                        accrual_convention_code,
                        custom_daycount_conventions=custom_daycount_conventions,
                    )
                    total_coupon += rate * year_frac * Face_Value
            else:
                rate = All_in_rate[np.where(Begining_Reset_Date_array < Begining_Date_array[i])[0][-1]]
                year_frac = conventions.A_day_count(
                    Begining_Date_array[i],
                    Ending_Date_array[i],
                    accrual_convention_code,
                    custom_daycount_conventions=custom_daycount_conventions,
                )
                total_coupon += rate * year_frac * Face_Value
            Coupons = np.append(Coupons, total_coupon)
            if Cashflow_Date_array[i] == Maturity_Date:
                Principal = np.append(Principal, Redemption_Amount[0])
            else:
                Principal = np.append(Principal, 0)
        Total_Amount = Coupons + Principal
        Unique_Reference_Id = Unique_Reference_Id
        Valuation_Date = Valuation_Date
        result_array = [
            Unique_Reference_Id,
            Valuation_Date,
            Cashflow_Date_array,
            TTM_array,
            Coupons,
            Principal,
            Total_Amount,
            accrued_interest,
        ]
        return result_array


## Master JSON Extraction Function ##


def Value_extraction(
    config_dict,
    curve_repo_data,
    curve_components_data,
    cs_curve_repo_data=None,
    cs_curve_components_data=None,
    holiday_calendar=[],
    mtm_data=None,
    custom_daycount_conventions=None,
    func_name="",
    df="",
):

    mtm_data = mtm_data.loc[
        mtm_data["extract_date"] == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
    ]
    curve_component_transformation_vect = np.vectorize(curve_component_transformation)
    curve_component_transformation_result = curve_component_transformation_vect(
        curve_repo_data.to_dict("records")
    )
    curve_data = pd.concat(curve_component_transformation_result, ignore_index=True)

    del curve_component_transformation_result
    curve_data = curve_data.merge(
        curve_components_data, left_on="curve_components", right_on="id", how="left"
    ).drop(columns=["curve_components", "id"])
    curve_data["tenor"] = np.where(
        curve_data["tenor_unit"] == "D",
        curve_data["tenor_value"] / 365.25,
        np.where(curve_data["tenor_unit"] == "M", curve_data["tenor_value"] / 12, curve_data["tenor_value"]),
    )
    curve_data = (
        curve_data.merge(
            mtm_data.loc[:, ["security_identifier", "quoted_price"]],
            left_on="curve_component",
            right_on="security_identifier",
            how="left",
        )
        .drop(columns=["security_identifier"])
        .rename(columns={"quoted_price": "rate"})
    )
    curve_data.sort_values(by=["curve_name", "tenor"], inplace=True)
    if len(cs_curve_repo_data) > 0:
        cs_curve_component_transformation_result = curve_component_transformation_vect(
            cs_curve_repo_data.to_dict("records")
        )
        cs_curve_data = pd.concat(cs_curve_component_transformation_result, ignore_index=True)
        del cs_curve_component_transformation_result
        cs_curve_data = cs_curve_data.merge(
            cs_curve_components_data, left_on="curve_components", right_on="id", how="left"
        ).drop(columns=["curve_components", "id"])
        cs_curve_data["tenor"] = np.where(
            cs_curve_data["tenor_unit"] == "D",
            cs_curve_data["tenor_value"] / 365.25,
            np.where(
                cs_curve_data["tenor_unit"] == "M",
                cs_curve_data["tenor_value"] / 12,
                cs_curve_data["tenor_value"],
            ),
        )
        credit_spread_data = (
            cs_curve_data.merge(
                mtm_data.loc[:, ["security_identifier", "quoted_price"]],
                left_on="curve_component",
                right_on="security_identifier",
                how="left",
            )
            .drop(columns=["security_identifier"])
            .rename(columns={"quoted_price": "spread_value", "curve_name": "credit_spread_curve_name"})
        )
        del cs_curve_data
        credit_spread_data.sort_values(by=["credit_spread_curve_name", "tenor"], inplace=True)
        spread_curve_data = credit_spread_data.drop(columns=["tenor"]).rename(
            columns={"tenor_value": "tenor"}
        )
        del credit_spread_data
    if config_dict["inputs"]["model_code"] == "M001":
        if len(df) > 0:
            pass

        else:
            Unique_Reference_Id = np.array([config_dict["inputs"]["Unique_Reference_Id"]])
            Face_Value = np.array([config_dict["inputs"]["Face_Value"]])

            config_dict["inputs"]["Redemption_Amount"] = float(config_dict["inputs"]["Redemption_Amount"])
            Redemption_Amount = np.array([config_dict["inputs"]["Redemption_Amount"]])
            Valuation_Date = np.array(
                [pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)]
            )
            Issue_Date = np.array([pd.to_datetime(config_dict["inputs"]["Issue_Date"], dayfirst=True)])
            Maturity_Date = np.array([pd.to_datetime(config_dict["inputs"]["Maturity_Date"], dayfirst=True)])
            Accrual_Daycount = np.array([config_dict["inputs"]["Accrual_daycount_convention"]])
            Discount_Daycount = np.array([config_dict["inputs"]["Discount_daycount_convention"]])
            Business_day_convention = np.array([config_dict["inputs"]["Business_day_convention"]])
            Discount_Curve = np.array([config_dict["inputs"]["Discount_Curve"]])

            Valuation_Date = Valuation_Date.astype("datetime64[D]")
            Maturity_Date = Maturity_Date.astype("datetime64[D]")

            discount_convention_code = valuation_models.daycount_convention_code(Discount_Daycount)
            convention_code = valuation_models.busday_convention_code(Business_day_convention)
            cashflow_date = conventions.business_day(Maturity_Date, convention_code, holiday_calendar)
            cashflow_date1 = pd.to_datetime(cashflow_date, dayfirst=True).strftime("%Y-%m-%d")
            TTM_array = conventions.D_day_count(
                Valuation_Date, Maturity_Date, custom_daycount_conventions=discount_convention_code
            )
            valuation_results = []
            sensitivity_analysis = []

            index_values = [
                "Unique Reference Id",
                "Valuation Date",
                "Cashflow Dates",
                "Time Elapsed",
                "Nominal Value",
                "Total Amount",
            ]
            cashflow_results = [
                Unique_Reference_Id,
                pd.to_datetime(Valuation_Date, dayfirst=True).strftime("%Y-%m-%d"),
                cashflow_date1,
                TTM_array,
                Face_Value,
                Redemption_Amount,
            ]
            cashflow_model_results = pd.DataFrame(data=cashflow_results, index=index_values).transpose()
            cashflow_model_results = cashflow_model_results.astype(
                {
                    "Time Elapsed": "float64",
                    "Nominal Value": "float64",
                    "Total Amount": "float64",
                }
            )
            if config_dict["outputs"]["Valuation"] == "Yes":
                if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                    zero_rate_curve = Discount_Curve[0]
                    zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
                    interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
                    extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                    curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[
                        0
                    ]
                    tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                    rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                    zero_rates = np.empty([0], dtype="float64")
                    for j in range(len(TTM_array)):
                        if interpolation_algorithm == "Linear":
                            if linearinterp(tenor, rates, TTM_array[j]) is None:
                                if extrapolation_algorithm == "Linear":
                                    extrapolated_value = linearexterp(tenor, rates, TTM_array[j])
                                else:
                                    extrapolated_value = flatexterp(tenor, rates, TTM_array[j])
                                zero_rates = np.append(zero_rates, extrapolated_value)
                            else:
                                interpolated_value = linearinterp(tenor, rates, TTM_array[j])
                                zero_rates = np.append(zero_rates, interpolated_value)

                    PV, TTM_array, df, PV_plus_1bps, PV_minus_1bps = commercial_paper_valuation(
                        TTM_array,
                        Redemption_Amount,
                        zero_rates,
                        curve_compounding_frequency=curve_compounding_frequency,
                    )
                    cashflow_model_results["DF"] = df
                    cashflow_model_results["PV of Principal"] = Redemption_Amount * df
                    valuation_output = {
                        "Unique Reference Id": config_dict["inputs"]["Unique_Reference_Id"],
                        "Valuation Date": config_dict["inputs"]["Valuation_date"],
                        "PV": PV[0],
                    }
                    valuation_results.append(valuation_output)

                elif config_dict["inputs"]["Valuation_Method"] == "mtm_valuation":
                    PV = np.array(
                        [
                            mtm_data[
                                (
                                    mtm_data["security_identifier"]
                                    == config_dict["inputs"]["Unique_Reference_Id"]
                                )
                                & (
                                    mtm_data["extract_date"]
                                    == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                                )
                            ]["quoted_price"].iloc[0]
                        ]
                    )
                    Valuation_Date = pd.to_datetime(
                        mtm_data.loc[
                            mtm_data["security_identifier"] == config_dict["inputs"]["Unique_Reference_Id"],
                            "extract_date",
                        ].iloc[0],
                        dayfirst=True,
                    ).strftime("%Y-%m-%d %H:%M:%S")
                    valuation_output = {
                        "Unique_Reference_Id": config_dict["inputs"]["Unique_Reference_Id"],
                        "Valuation Date": Valuation_Date,
                        "PV": PV[0],
                    }
                    valuation_results.append(valuation_output)

                if config_dict["outputs"]["Sensitivity_Analysis"] == "Yes":
                    if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                        (
                            macaulay_duration,
                            modified_duration,
                            PV01,
                            effective_duration,
                            ytm,
                        ) = valuation_models.commercial_paper_sensitivity_analysis(
                            PV, TTM_array, Redemption_Amount, PV_plus_1bps, PV_minus_1bps
                        )
                        sensitivity_analysis.append(
                            {
                                "Macaulay Duration": macaulay_duration[0],
                                "Effective Duration": effective_duration[0],
                                "Modified Duration": modified_duration[0],
                                "PV01 per unit": PV01[0],
                            }
                        )

                    elif config_dict["inputs"]["Valuation_Method"] == "mtm_valuation":
                        modified_duration = mtm_data[
                            (mtm_data["security_identifier"] == config_dict["inputs"]["Unique_Reference_Id"])
                            & (
                                mtm_data["extract_date"]
                                == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                            )
                        ]["modified_duration"].iloc[0]
                        ytm = np.array(
                            [
                                mtm_data[
                                    (
                                        mtm_data["security_identifier"]
                                        == config_dict["inputs"]["Unique_Reference_Id"]
                                    )
                                    & (
                                        mtm_data["extract_date"]
                                        == pd.to_datetime(
                                            config_dict["inputs"]["Valuation_date"], dayfirst=True
                                        )
                                    )
                                ]["yield"].iloc[0]
                            ]
                        )
                        (
                            macaulay_duration,
                            modified_duration,
                            PV01,
                            effective_duration,
                            ytm,
                        ) = valuation_models.commercial_paper_mtm_sensitivity_analysis(
                            PV, TTM_array, Redemption_Amount, ytm, modified_duration
                        )
                        sensitivity_analysis.append(
                            {
                                "Macaulay_Duration": macaulay_duration,
                                "Effective Duration": effective_duration[0],
                                "Modified_Duration": modified_duration,
                                "PV01 per unit": PV01[0],
                            }
                        )
        return cashflow_model_results, valuation_results, sensitivity_analysis

    elif config_dict["inputs"]["model_code"] == "M002":
        if len(df) > 0:
            df = df[
                [
                    config_dict["inputs"]["Unique_Reference_Id"],
                    config_dict["inputs"]["Issue_Date"],
                    config_dict["inputs"]["Maturity_Date"],
                    config_dict["inputs"]["Face_Value"],
                    config_dict["inputs"]["Redemption_Amount"],
                    config_dict["inputs"]["Coupon_Rate"],
                    config_dict["inputs"]["Coupon_frequency"],
                    config_dict["inputs"]["Valuation_date"],
                    config_dict["inputs"]["Discount_daycount_convention"],
                    config_dict["inputs"]["Accrual_daycount_convention"],
                    config_dict["inputs"]["Discount_Curve"],
                    config_dict["inputs"]["Business_day_convention"],
                    config_dict["inputs"]["Last_coupon_date"],
                ]
            ]
            arr = np.array(df)

            def applyParallel(
                config_dict,
                arr,
                curve_data,
                Value_extraction_fixed_income_government_portfolio,
                holiday_calendar,
            ):
                retLst, valuation, sensitivity = zip(
                    *Parallel(n_jobs=multiprocessing.cpu_count())(
                        delayed(Value_extraction_fixed_income_government_portfolio)(
                            config_dict, curve_data, x, holiday_calendar
                        )
                        for x in arr
                    )
                )
                cashflow = pd.concat(retLst)
                return cashflow, valuation, sensitivity

            cashflow_model_results, valuation_results, sensitivity_analysis = applyParallel(
                config_dict,
                arr,
                curve_data,
                Value_extraction_fixed_income_government_portfolio,
                holiday_calendar,
            )

        else:
            Unique_Reference_Id = np.array([config_dict["inputs"]["Unique_Reference_Id"]])
            Issue_Date = pd.to_datetime(config_dict["inputs"]["Issue_Date"], dayfirst=True)
            Maturity_Date = np.array([pd.to_datetime(config_dict["inputs"]["Maturity_Date"], dayfirst=True)])
            Face_Value = np.array([float(config_dict["inputs"]["Face_Value"])])
            Redemption_Amount = np.array([float(config_dict["inputs"]["Redemption_Amount"])])
            Coupon_Rate = np.array([float(config_dict["inputs"]["Base_Rate"])])
            Coupon_Frequency = config_dict["inputs"]["Coupon_frequency"]
            Coupon_Frequency_unit = config_dict["inputs"]["Coupon_frequency_unit"]
            Valuation_Date = np.array([np.datetime64(config_dict["inputs"]["Valuation_date"], "D")])
            Discount_Daycount = np.array([config_dict["inputs"]["Discount_daycount_convention"]])
            Accrual_Daycount = np.array([config_dict["inputs"]["Accrual_daycount_convention"]])
            Discount_Curve = config_dict["inputs"]["Discount_Curve"]
            Business_day_convention = np.array([config_dict["inputs"]["Business_day_convention"]])
            Last_coupon_date = np.datetime64(config_dict["inputs"]["Last_coupon_date"], "D")
            cashflow_results = valuation_models.fixed_coupon_cashflow_generation(
                Unique_Reference_Id,
                Issue_Date,
                Maturity_Date,
                Face_Value,
                Redemption_Amount,
                Coupon_Rate,
                Coupon_Frequency,
                Coupon_Frequency_unit,
                Valuation_Date,
                Discount_Daycount,
                Accrual_Daycount,
                Discount_Curve,
                Business_day_convention,
                Last_coupon_date,
                holiday_calendar,
                custom_daycount_conventions,
            )
            index_values = [
                "Unique Reference Id",
                "Valuation Date",
                "Cashflow Dates",
                "Time Elapsed",
                "Coupons",
                "Principal",
                "Total Amount",
                "Accrued Interest",
                # "DF",
                # "PV of Coupons",
                # "PV of Principal",
                # "PV of Total Amount",
            ]

            cashflow_model_results = pd.DataFrame(data=cashflow_results, index=index_values).transpose()
            cashflow_model_results["Unique Reference Id"] = Unique_Reference_Id[0]
            cashflow_model_results["Valuation Date"] = Valuation_Date[0]
            cashflow_model_results["DF"] = ""
            cashflow_model_results["PV of Coupons"] = ""
            cashflow_model_results["PV of Principal"] = ""
            cashflow_model_results["PV of Total Amount"] = ""
            cashflow_model_results = cashflow_model_results.astype(
                {
                    "Time Elapsed": "float64",
                    "Coupons": "float64",
                    "Principal": "float64",
                    "Total Amount": "float64",
                }
            )
            valuation_results = []
            sensitivity_analysis = []
            if config_dict["outputs"]["Valuation"] == "Yes":
                TTM = cashflow_model_results["Time Elapsed"].to_numpy(dtype="float64")
                Total_Amount = cashflow_model_results["Total Amount"].to_numpy(dtype="float64")
                Coupons = cashflow_model_results["Coupons"].to_numpy(dtype="float64")
                Principal = cashflow_model_results["Principal"].to_numpy(dtype="float64")
                if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                    zero_rate_curve = Discount_Curve
                    zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
                    interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
                    extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                    curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[
                        0
                    ]
                    tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                    rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                    zero_rates = np.empty([0], dtype="float64")
                    for j in range(len(TTM)):
                        if interpolation_algorithm == "Linear":
                            if linearinterp(tenor, rates, TTM[j]) is None:
                                if extrapolation_algorithm == "Linear":
                                    extrapolated_value = linearexterp(tenor, rates, TTM[j])
                                else:
                                    extrapolated_value = flatexterp(tenor, rates, TTM[j])
                                zero_rates = np.append(zero_rates, extrapolated_value)
                            else:
                                interpolated_value = linearinterp(tenor, rates, TTM[j])
                                zero_rates = np.append(zero_rates, interpolated_value)

                    (
                        PV_output,
                        PV_table,
                        TTM_array,
                        Total_amount_array,
                        DF,
                        PV_coupons,
                        PV_principal,
                        PV_plus_1bps,
                        PV_minus_1bps,
                    ) = fixed_income_valuation(
                        TTM,
                        Total_Amount,
                        zero_rates,
                        Coupons,
                        Principal,
                        curve_compounding_frequency=curve_compounding_frequency,
                    )
                    cashflow_model_results["DF"] = DF
                    cashflow_model_results["PV of Coupons"] = PV_coupons
                    cashflow_model_results["PV of Principal"] = PV_principal
                    cashflow_model_results["PV of Total Amount"] = PV_table
                    valuation_output = {
                        "Unique Reference Id": config_dict["inputs"]["Unique_Reference_Id"],
                        "PV": round(PV_output, 4),
                    }
                    valuation_results.append(valuation_output)

                elif config_dict["inputs"]["Valuation_Method"] == "mtm_valuation":
                    PV = np.array(
                        [
                            mtm_data[
                                (
                                    mtm_data["security_identifier"]
                                    == config_dict["inputs"]["Unique_Reference_Id"]
                                )
                                & (
                                    mtm_data["extract_date"]
                                    == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                                )
                            ]["quoted_price"].iloc[0]
                        ]
                    )
                    Valuation_Date = pd.to_datetime(
                        mtm_data.loc[
                            mtm_data["security_identifier"] == config_dict["inputs"]["Unique_Reference_Id"],
                            "extract_date",
                        ].iloc[0],
                        dayfirst=True,
                    ).strftime("%Y-%m-%d %H:%M:%S")
                    valuation_output = {
                        "Unique Reference Id": config_dict["inputs"]["Unique_Reference_Id"],
                        "Valuation Date": Valuation_Date,
                        "PV": PV[0],
                    }
                    valuation_results.append(valuation_output)
                    ytm = np.array(
                        [
                            mtm_data[
                                (
                                    mtm_data["security_identifier"]
                                    == config_dict["inputs"]["Unique_Reference_Id"]
                                )
                                & (
                                    mtm_data["extract_date"]
                                    == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                                )
                            ]["yield"].iloc[0]
                        ]
                    )
                    (
                        PV_output,
                        PV_table,
                        TTM_array,
                        Total_amount_array,
                        DF,
                        PV_coupons,
                        PV_principal,
                    ) = valuation_models.fixed_income_mtm_valuation(
                        TTM, Total_Amount, Coupons, Principal, ytm, PV
                    )
                    cashflow_model_results["DF"] = DF
                    cashflow_model_results["PV of Coupons"] = PV_coupons
                    cashflow_model_results["PV of Principal"] = PV_principal
                    cashflow_model_results["PV of Total Amount"] = PV_table

                if config_dict["outputs"]["Sensitivity_Analysis"] == "Yes":
                    if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                        (
                            PV01,
                            macaulay_duration,
                            modified_duration,
                            effective_duration,
                            ytm,
                        ) = valuation_models.fixed_income_sensitivity_analysis(
                            PV_table,
                            TTM_array,
                            Total_amount_array,
                            Coupon_Frequency,
                            Coupon_Frequency_unit,
                            PV_output,
                            PV_plus_1bps,
                            PV_minus_1bps,
                        )
                        sensitivity_analysis.append(
                            {
                                "Macaulay Duration": macaulay_duration,
                                "Effective Duration": effective_duration,
                                "Modified Duration": modified_duration,
                                "PV01 per unit": PV01,
                            }
                        )
                    elif config_dict["inputs"]["Valuation_Method"] == "mtm_valuation":
                        modified_duration = mtm_data[
                            (mtm_data["security_identifier"] == config_dict["inputs"]["Unique_Reference_Id"])
                            & (
                                mtm_data["extract_date"]
                                == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                            )
                        ]["modified_duration"].iloc[0]
                        ytm = mtm_data[
                            (mtm_data["security_identifier"] == config_dict["inputs"]["Unique_Reference_Id"])
                            & (
                                mtm_data["extract_date"]
                                == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                            )
                        ]["yield"].iloc[0]
                        (
                            PV01,
                            macaulay_duration,
                            modified_duration,
                            effective_duration,
                            ytm,
                        ) = valuation_models.fixed_income_mtm_sensitivity_analysis(
                            modified_duration,
                            ytm,
                            TTM_array,
                            Total_amount_array,
                            Coupon_Frequency,
                            Coupon_Frequency_unit,
                            PV,
                            PV_table=PV_table,
                        )
                        sensitivity_analysis.append(
                            {
                                "Macaulay_Duration": macaulay_duration,
                                "Effective Duration": effective_duration[0],
                                "Modified_Duration": modified_duration,
                                "PV01 per unit": PV01,
                            }
                        )

        return cashflow_model_results, valuation_results, sensitivity_analysis

    elif config_dict["inputs"]["model_code"] == "M003":
        if len(df) > 0:
            pass
        else:
            Unique_Reference_Id = np.array([config_dict["inputs"]["Unique_Reference_Id"]])
            Issue_Date = pd.to_datetime(config_dict["inputs"]["Issue_Date"], dayfirst=True)
            Maturity_Date = np.array([pd.to_datetime(config_dict["inputs"]["Maturity_Date"], dayfirst=True)])
            Face_Value = np.array([config_dict["inputs"]["Face_Value"]], dtype="float64")
            Redemption_Amount = np.array([config_dict["inputs"]["Redemption_Amount"]], dtype="float64")
            if config_dict["inputs"].get("Spread_Over_Benchmark"):
                Spread_Over_Benchmark = config_dict["inputs"].get("Spread_Over_Benchmark")
            else:
                Spread_Over_Benchmark = "0"
            Coupon_Frequency = config_dict["inputs"]["Coupon_frequency"]
            Coupon_Frequency_unit = config_dict["inputs"]["Coupon_frequency_unit"]
            Valuation_Date = np.array([np.datetime64(config_dict["inputs"]["Valuation_date"], "D")])
            Discount_Daycount = np.array([config_dict["inputs"]["Discount_daycount_convention"]])
            Accrual_Daycount = np.array([config_dict["inputs"]["Accrual_daycount_convention"]])
            Discount_Curve = np.array([config_dict["inputs"]["Discount_Curve"]])
            Business_day_convention = np.array([config_dict["inputs"]["Business_day_convention"]])
            Last_coupon_date = np.datetime64(config_dict["inputs"]["Last_coupon_date"], "D")
            Coupon_Benchmark_Curve = config_dict["inputs"]["Benchmark_Curve"]
            Next_Repricing_Date = pd.to_datetime(config_dict["inputs"]["Next_Repricing_Date"], dayfirst=True)
            if config_dict["inputs"].get("Last_Repricing_Date"):
                Last_Repricing_Date = pd.to_datetime(
                    config_dict["inputs"].get("Last_Repricing_Date"), dayfirst=True
                )
            else:
                Last_Repricing_Date = np.datetime64("NaT")
            Repricing_Frequency = config_dict["inputs"]["Repricing_Frequency"]
            Repricing_Frequency_unit = config_dict["inputs"]["Repricing_Frequency_unit"]

            cashflow_results = valuation_models.floating_coupon_cashflow_generation(
                Unique_Reference_Id,
                Issue_Date,
                Maturity_Date,
                Face_Value,
                Redemption_Amount,
                Spread_Over_Benchmark,
                Coupon_Frequency,
                Coupon_Frequency_unit,
                Valuation_Date,
                Discount_Daycount,
                Accrual_Daycount,
                Discount_Curve,
                Business_day_convention,
                Last_coupon_date,
                Coupon_Benchmark_Curve,
                Next_Repricing_Date,
                Last_Repricing_Date,
                curve_data,
                Repricing_Frequency,
                Repricing_Frequency_unit,
                holiday_calendar,
                custom_daycount_conventions,
            )
            index_values = [
                "Unique Reference Id",
                "Valuation Date",
                "Cashflow Dates",
                "Time Elapsed",
                "Coupons",
                "Principal",
                "Total Amount",
            ]
            cashflow_model_results = pd.DataFrame(data=cashflow_results, index=index_values).transpose()
            cashflow_model_results["Unique Reference Id"] = Unique_Reference_Id[0]
            cashflow_model_results["Valuation Date"] = Valuation_Date[0]
            cashflow_model_results["DF"] = ""
            cashflow_model_results["PV of Coupons"] = ""
            cashflow_model_results["PV of Principal"] = ""
            cashflow_model_results["PV of Total Amount"] = ""
            cashflow_model_results = cashflow_model_results.astype(
                {
                    "Time Elapsed": "float64",
                    "Coupons": "float64",
                    "Principal": "float64",
                    "Total Amount": "float64",
                }
            )
            valuation_results = []
            sensitivity_analysis = []
            if config_dict["outputs"]["Valuation"] == "Yes":
                TTM = cashflow_model_results["Time Elapsed"].to_numpy(dtype="float64")
                Total_Amount = cashflow_model_results["Total Amount"].to_numpy(dtype="float64")
                Coupons = cashflow_model_results["Coupons"].to_numpy(dtype="float64")
                Principal = cashflow_model_results["Principal"].to_numpy(dtype="float64")
                if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                    zero_rate_curve = Discount_Curve[0]
                    zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
                    interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
                    extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                    curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[
                        0
                    ]
                    tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                    rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                    zero_rates = np.empty([0], dtype="float64")
                    for j in range(len(TTM)):
                        if interpolation_algorithm == "Linear":
                            if linearinterp(tenor, rates, TTM[j]) is None:
                                if extrapolation_algorithm == "Linear":
                                    extrapolated_value = linearexterp(tenor, rates, TTM[j])
                                else:
                                    extrapolated_value = flatexterp(tenor, rates, TTM[j])
                                zero_rates = np.append(zero_rates, extrapolated_value)
                            else:
                                interpolated_value = linearinterp(tenor, rates, TTM[j])
                                zero_rates = np.append(zero_rates, interpolated_value)
                    (
                        PV_output,
                        PV_table,
                        TTM_array,
                        Total_amount_array,
                        DF,
                        PV_coupons,
                        PV_principal,
                        PV_plus_1bps,
                        PV_minus_1bps,
                    ) = fixed_income_valuation(
                        TTM,
                        Total_Amount,
                        zero_rates,
                        Coupons,
                        Principal,
                        curve_compounding_frequency=curve_compounding_frequency,
                    )
                    cashflow_model_results["DF"] = DF
                    cashflow_model_results["PV of Coupons"] = PV_coupons
                    cashflow_model_results["PV of Principal"] = PV_principal
                    cashflow_model_results["PV of Total Amount"] = PV_table
                    valuation_output = {
                        "Unique Reference Id": config_dict["inputs"]["Unique_Reference_Id"],
                        "Valuation Date": config_dict["inputs"]["Valuation_date"],
                        "PV": round(PV_output, 4),
                    }
                    valuation_results.append(valuation_output)

                elif config_dict["inputs"]["Valuation_Method"] == "mtm_valuation":
                    PV = np.array(
                        [
                            mtm_data[
                                (
                                    mtm_data["security_identifier"]
                                    == config_dict["inputs"]["Unique_Reference_Id"]
                                )
                                & (
                                    mtm_data["extract_date"]
                                    == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                                )
                            ]["quoted_price"].iloc[0]
                        ]
                    )
                    Valuation_Date = pd.to_datetime(
                        mtm_data.loc[
                            mtm_data["security_identifier"] == config_dict["inputs"]["Unique_Reference_Id"],
                            "extract_date",
                        ].iloc[0],
                        dayfirst=True,
                    ).strftime("%Y-%m-%d %H:%M:%S")
                    valuation_output = {
                        "Unique Reference Id": config_dict["inputs"]["Unique_Reference_Id"],
                        "Valuation Date": Valuation_Date,
                        "PV": PV[0],
                    }
                    valuation_results.append(valuation_output)
                    ytm = np.array(
                        [
                            mtm_data[
                                (
                                    mtm_data["security_identifier"]
                                    == config_dict["inputs"]["Unique_Reference_Id"]
                                )
                                & (
                                    mtm_data["extract_date"]
                                    == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                                )
                            ]["yield"].iloc[0]
                        ]
                    )
                    (
                        PV_output,
                        PV_table,
                        TTM_array,
                        Total_amount_array,
                        DF,
                        PV_coupons,
                        PV_principal,
                    ) = valuation_models.fixed_income_mtm_valuation(
                        TTM, Total_Amount, Coupons, Principal, ytm, PV
                    )
                    cashflow_model_results["DF"] = DF
                    cashflow_model_results["PV of Coupons"] = PV_coupons
                    cashflow_model_results["PV of Principal"] = PV_principal
                    cashflow_model_results["PV of Total Amount"] = PV_table

                if config_dict["outputs"]["Sensitivity_Analysis"] == "Yes":
                    if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                        (
                            PV01,
                            macaulay_duration,
                            modified_duration,
                            effective_duration,
                            ytm,
                        ) = valuation_models.fixed_income_sensitivity_analysis(
                            PV_table,
                            TTM_array,
                            Total_amount_array,
                            Coupon_Frequency,
                            Coupon_Frequency_unit,
                            PV_output,
                            PV_plus_1bps,
                            PV_minus_1bps,
                        )
                        sensitivity_analysis.append(
                            {
                                "Macaulay Duration": macaulay_duration,
                                "Effective Duration": effective_duration,
                                "Modified Duration": modified_duration,
                                "PV01 per unit": PV01,
                            }
                        )
                    elif config_dict["inputs"]["Valuation_Method"] == "mtm_valuation":
                        modified_duration = mtm_data[
                            (mtm_data["security_identifier"] == config_dict["inputs"]["Unique_Reference_Id"])
                            & (
                                mtm_data["extract_date"]
                                == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                            )
                        ]["modified_duration"].iloc[0]
                        ytm = mtm_data[
                            (mtm_data["security_identifier"] == config_dict["inputs"]["Unique_Reference_Id"])
                            & (
                                mtm_data["extract_date"]
                                == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                            )
                        ]["yield"].iloc[0]
                        (
                            PV01,
                            macaulay_duration,
                            modified_duration,
                            effective_duration,
                            ytm,
                        ) = valuation_models.fixed_income_mtm_sensitivity_analysis(
                            modified_duration,
                            ytm,
                            TTM_array,
                            Total_amount_array,
                            Coupon_Frequency,
                            Coupon_Frequency_unit,
                            PV,
                            PV_table=PV_table,
                        )
                        sensitivity_analysis.append(
                            {
                                "Macaulay_Duration": macaulay_duration,
                                "Effective Duration": effective_duration[0],
                                "Modified_Duration": modified_duration,
                                "PV01 per unit": PV01,
                            }
                        )

        return cashflow_model_results, valuation_results, sensitivity_analysis

    elif config_dict["inputs"]["model_code"] == "M005":
        if len(df) > 0:
            pass

        else:
            Unique_Reference_Id = np.array([config_dict["inputs"]["Unique_Reference_Id"]])
            Face_Value = np.array([config_dict["inputs"]["Face_Value"]])

            config_dict["inputs"]["Redemption_Amount"] = float(config_dict["inputs"]["Redemption_Amount"])
            Redemption_Amount = np.array([config_dict["inputs"]["Redemption_Amount"]])
            Valuation_Date = np.array(
                [pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)]
            )
            Issue_Date = np.array([pd.to_datetime(config_dict["inputs"]["Issue_Date"], dayfirst=True)])
            Maturity_Date = np.array([pd.to_datetime(config_dict["inputs"]["Maturity_Date"], dayfirst=True)])
            Accrual_Daycount = np.array([config_dict["inputs"]["Accrual_daycount_convention"]])
            Discount_Daycount = np.array([config_dict["inputs"]["Discount_daycount_convention"]])
            Discount_Curve = np.array([config_dict["inputs"]["Discount_Curve"]])
            Business_day_convention = np.array([config_dict["inputs"]["Business_day_convention"]])
            credit_spread_rate = np.array([config_dict["inputs"]["Credit_Spread_Rate"]])
            Credit_Spread_Curve = np.array([config_dict["inputs"].get("Credit_Spread_Curve")])
            Valuation_Date = Valuation_Date.astype("datetime64[D]")
            Maturity_Date = Maturity_Date.astype("datetime64[D]")

            discount_convention_code = valuation_models.daycount_convention_code(Discount_Daycount)
            convention_code = valuation_models.busday_convention_code(Business_day_convention)
            cashflow_date = conventions.business_day(Maturity_Date, convention_code, holiday_calendar)
            cashflow_date1 = pd.to_datetime(cashflow_date, dayfirst=True).strftime("%Y-%m-%d")
            TTM_array = conventions.D_day_count(
                Valuation_Date,
                Maturity_Date,
                discount_convention_code,
                custom_daycount_conventions=custom_daycount_conventions,
            )
            valuation_results = []
            sensitivity_analysis = []
            index_values = [
                "Unique Reference Id",
                "Valuation Date",
                "Cashflow Dates",
                "Time Elapsed",
                "Coupons",
                "Principal",
                "Total Amount",
            ]
            cashflow_results = [
                Unique_Reference_Id,
                pd.to_datetime(Valuation_Date, dayfirst=True).strftime("%Y-%m-%d"),
                cashflow_date1,
                TTM_array,
                "-",
                Face_Value,
                Redemption_Amount,
            ]
            cashflow_model_results = pd.DataFrame(data=cashflow_results, index=index_values).transpose()
            cashflow_model_results = cashflow_model_results.astype(
                {
                    "Time Elapsed": "float64",
                    "Principal": "float64",
                    "Total Amount": "float64",
                }
            )
            if config_dict["outputs"]["Valuation"] == "Yes":
                if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                    zero_rate_curve = Discount_Curve[0]
                    zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
                    interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
                    extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                    curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[
                        0
                    ]
                    tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                    rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                    zero_rates = np.empty([0], dtype="float64")
                    for j in range(len(TTM_array)):
                        if interpolation_algorithm == "Linear":
                            if linearinterp(tenor, rates, TTM_array[j]) is None:
                                if extrapolation_algorithm == "Linear":
                                    extrapolated_value = linearexterp(tenor, rates, TTM_array[j])
                                else:
                                    extrapolated_value = flatexterp(tenor, rates, TTM_array[j])
                                zero_rates = np.append(zero_rates, extrapolated_value)
                            else:
                                interpolated_value = linearinterp(tenor, rates, TTM_array[j])
                                zero_rates = np.append(zero_rates, interpolated_value)
                    if bool(credit_spread_rate[0]):
                        all_in_rate = float(zero_rates[0]) + float(credit_spread_rate[0])
                    elif len(Credit_Spread_Curve) > 0:
                        spread_rate_curve = Credit_Spread_Curve[0]
                        credit_spread_curve_data = spread_curve_data.loc[
                            (spread_curve_data["credit_spread_curve_name"] == spread_rate_curve), :
                        ]

                        if len(credit_spread_curve_data) > 0:
                            spread_tenor = np.array(credit_spread_curve_data.tenor.tolist())
                            spread_tenor_unit = np.array(credit_spread_curve_data.tenor_unit.tolist())
                            cs_interpolation_algorithm = credit_spread_curve_data[
                                "interpolation_algorithm"
                            ].iloc[0]
                            cs_extrapolation_algorithm = credit_spread_curve_data[
                                "extrapolation_algorithm"
                            ].iloc[0]
                            tenor_extrac = np.vectorize(tenor_extraction)
                            spread_tenor = tenor_extrac(spread_tenor, spread_tenor_unit)
                            spread_rates = np.array(credit_spread_curve_data.spread_value.tolist())
                            credit_spread_rates = np.empty([0], dtype="float64")
                            for j in range(len(TTM_array)):
                                if linearinterp(spread_tenor, spread_rates, TTM_array[j]) is None:
                                    if cs_extrapolation_algorithm == "Linear":
                                        calculated_value = linearexterp(spread_tenor, spread_rates, j)
                                    else:
                                        calculated_value = flatexterp(spread_tenor, spread_rates, j)
                                else:
                                    calculated_value = linearinterp(spread_tenor, spread_rates, TTM_array[j])
                                credit_spread_rates = np.append(credit_spread_rates, calculated_value)
                            all_in_rate = zero_rates + credit_spread_rates
                    PV, TTM_array, df, PV_plus_1bps, PV_minus_1bps = commercial_paper_valuation(
                        TTM_array,
                        Redemption_Amount,
                        all_in_rate,
                        curve_compounding_frequency=curve_compounding_frequency,
                    )
                    valuation_output = {
                        "Unique Reference Id": config_dict["inputs"]["Unique_Reference_Id"],
                        "Valuation Date": config_dict["inputs"]["Valuation_date"],
                        "PV": PV[0],
                    }
                    valuation_results.append(valuation_output)
                    cashflow_model_results["DF"] = df
                    cashflow_model_results["PV of Principal"] = Redemption_Amount * df

                elif config_dict["inputs"]["Valuation_Method"] == "mtm_valuation":
                    PV = np.array(
                        [
                            mtm_data[
                                (
                                    mtm_data["security_identifier"]
                                    == config_dict["inputs"]["Unique_Reference_Id"]
                                )
                                & (
                                    mtm_data["extract_date"]
                                    == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                                )
                            ]["quoted_price"].iloc[0]
                        ]
                    )
                    Valuation_Date = pd.to_datetime(
                        mtm_data.loc[
                            mtm_data["security_identifier"] == config_dict["inputs"]["Unique_Reference_Id"],
                            "extract_date",
                        ].iloc[0],
                        dayfirst=True,
                    ).strftime("%Y-%m-%d %H:%M:%S")
                    valuation_output = {
                        "Unique_Reference_Id": config_dict["inputs"]["Unique_Reference_Id"],
                        "Valuation Date": Valuation_Date,
                        "PV": PV[0],
                    }
                    valuation_results.append(valuation_output)
                    cashflow_model_results = cashflow_model_results.astype(
                        {"Time Elapsed": "float64", "Principal": "float64", "Total Amount": "float64"}
                    )

                if config_dict["outputs"]["Sensitivity_Analysis"] == "Yes":
                    if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                        (
                            macaulay_duration,
                            modified_duration,
                            PV01,
                            effective_duration,
                            ytm,
                        ) = valuation_models.commercial_paper_sensitivity_analysis(
                            PV, TTM_array, Redemption_Amount, PV_plus_1bps, PV_minus_1bps
                        )
                        sensitivity_analysis.append(
                            {
                                "Macaulay_Duration": macaulay_duration[0],
                                "Effective Duration": effective_duration[0],
                                "Modified_Duration": modified_duration[0],
                                "PV01 per unit": PV01[0],
                            }
                        )
                    elif config_dict["inputs"]["Valuation_Method"] == "mtm_valuation":
                        modified_duration = mtm_data[
                            (mtm_data["security_identifier"] == config_dict["inputs"]["Unique_Reference_Id"])
                            & (
                                mtm_data["extract_date"]
                                == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                            )
                        ]["modified_duration"].iloc[0]
                        ytm = np.array(
                            [
                                mtm_data[
                                    (
                                        mtm_data["security_identifier"]
                                        == config_dict["inputs"]["Unique_Reference_Id"]
                                    )
                                    & (
                                        mtm_data["extract_date"]
                                        == pd.to_datetime(
                                            config_dict["inputs"]["Valuation_date"], dayfirst=True
                                        )
                                    )
                                ]["yield"].iloc[0]
                            ]
                        )
                        (
                            macaulay_duration,
                            modified_duration,
                            PV01,
                            effective_duration,
                            ytm,
                        ) = valuation_models.commercial_paper_mtm_sensitivity_analysis(
                            PV, TTM_array, Redemption_Amount, ytm, modified_duration
                        )
                        sensitivity_analysis.append(
                            {
                                "Macaulay_Duration": macaulay_duration,
                                "Effective Duration": effective_duration[0],
                                "Modified_Duration": modified_duration,
                                "PV01 per unit": PV01[0],
                            }
                        )

        return cashflow_model_results, valuation_results, sensitivity_analysis

    elif config_dict["inputs"]["model_code"] == "M006":
        if len(df) > 0:
            pass

        else:
            Unique_Reference_Id = np.array([config_dict["inputs"]["Unique_Reference_Id"]])
            Issue_Date = pd.to_datetime(config_dict["inputs"]["Issue_Date"], dayfirst=True)
            Maturity_Date = np.array([pd.to_datetime(config_dict["inputs"]["Maturity_Date"], dayfirst=True)])
            Face_Value = np.array([float(config_dict["inputs"]["Face_Value"])])
            Redemption_Amount = np.array([float(config_dict["inputs"]["Redemption_Amount"])])
            Coupon_Rate = np.array([float(config_dict["inputs"]["Base_Rate"])])
            Coupon_Frequency = config_dict["inputs"]["Coupon_frequency"]
            Coupon_Frequency_unit = config_dict["inputs"]["Coupon_frequency_unit"]
            Valuation_Date = np.array([np.datetime64(config_dict["inputs"]["Valuation_date"], "D")])
            Discount_Daycount = np.array([config_dict["inputs"]["Discount_daycount_convention"]])
            Accrual_Daycount = np.array([config_dict["inputs"]["Accrual_daycount_convention"]])
            Discount_Curve = config_dict["inputs"]["Discount_Curve"]
            Business_day_convention = np.array([config_dict["inputs"]["Business_day_convention"]])
            Last_coupon_date = np.datetime64(config_dict["inputs"]["Last_coupon_date"], "D")
            Credit_Spread_Rate = np.array([config_dict["inputs"].get("Credit_Spread_Rate")])
            Credit_Spread_Curve = np.array([config_dict["inputs"].get("Credit_Spread_Curve")])

            cashflow_results = valuation_models.fixed_coupon_cashflow_generation(
                Unique_Reference_Id,
                Issue_Date,
                Maturity_Date,
                Face_Value,
                Redemption_Amount,
                Coupon_Rate,
                Coupon_Frequency,
                Coupon_Frequency_unit,
                Valuation_Date,
                Discount_Daycount,
                Accrual_Daycount,
                Discount_Curve,
                Business_day_convention,
                Last_coupon_date,
                holiday_calendar,
                custom_daycount_conventions,
            )
            index_values = [
                "Unique Reference Id",
                "Valuation Date",
                "Cashflow Dates",
                "Time Elapsed",
                "Coupons",
                "Principal",
                "Total Amount",
                # "DF",
                # "PV of Coupons",
                # "PV of Principal",
                # "PV of Total Amount",
            ]
            cashflow_model_results = pd.DataFrame(data=cashflow_results, index=index_values).transpose()
            cashflow_model_results["Unique Reference Id"] = Unique_Reference_Id[0]
            cashflow_model_results["Valuation Date"] = Valuation_Date[0]
            cashflow_model_results["DF"] = ""
            cashflow_model_results["PV of Coupons"] = ""
            cashflow_model_results["PV of Principal"] = ""
            cashflow_model_results["PV of Total Amount"] = ""
            cashflow_model_results = cashflow_model_results.astype(
                {
                    "Time Elapsed": "float64",
                    "Coupons": "float64",
                    "Principal": "float64",
                    "Total Amount": "float64",
                }
            )
            valuation_results = []
            sensitivity_analysis = []
            if config_dict["outputs"]["Valuation"] == "Yes":
                TTM = cashflow_model_results["Time Elapsed"].to_numpy(dtype="float64")
                Total_Amount = cashflow_model_results["Total Amount"].to_numpy(dtype="float64")
                Coupons = cashflow_model_results["Coupons"].to_numpy(dtype="float64")
                Principal = cashflow_model_results["Principal"].to_numpy(dtype="float64")
                if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                    zero_rate_curve = Discount_Curve
                    zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
                    interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
                    extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                    curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[
                        0
                    ]
                    tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                    rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                    zero_rates = np.empty([0], dtype="float64")
                    for j in range(len(TTM)):
                        if interpolation_algorithm == "Linear":
                            if linearinterp(tenor, rates, TTM[j]) is None:
                                if extrapolation_algorithm == "Linear":
                                    extrapolated_value = linearexterp(tenor, rates, TTM[j])
                                else:
                                    extrapolated_value = flatexterp(tenor, rates, TTM[j])
                                zero_rates = np.append(zero_rates, extrapolated_value)
                            else:
                                interpolated_value = linearinterp(tenor, rates, TTM[j])
                                zero_rates = np.append(zero_rates, interpolated_value)
                    # Add Credit Spread Rate to zero_rates
                    if bool(Credit_Spread_Rate[0]):
                        zero_rates = zero_rates + float(Credit_Spread_Rate[0])
                    elif len(Credit_Spread_Curve) > 0:
                        spread_rate_curve = Credit_Spread_Curve[0]
                        credit_spread_curve_data = spread_curve_data.loc[
                            (spread_curve_data["credit_spread_curve_name"] == spread_rate_curve), :
                        ]
                        if len(credit_spread_curve_data) > 0:
                            spread_tenor = np.array(credit_spread_curve_data.tenor.tolist())
                            spread_tenor_unit = np.array(credit_spread_curve_data.tenor_unit.tolist())
                            cs_interpolation_algorithm = credit_spread_curve_data[
                                "interpolation_algorithm"
                            ].iloc[0]
                            cs_extrapolation_algorithm = credit_spread_curve_data[
                                "extrapolation_algorithm"
                            ].iloc[0]
                            tenor_extrac = np.vectorize(tenor_extraction)
                            spread_tenor = tenor_extrac(spread_tenor, spread_tenor_unit)
                            spread_rates = np.array(credit_spread_curve_data.spread_value.tolist())
                            credit_spread_rates = np.empty([0], dtype="float64")
                            for j in range(len(TTM)):
                                if linearinterp(spread_tenor, spread_rates, TTM[j]) is None:
                                    if cs_extrapolation_algorithm == "Linear":
                                        calculated_value = linearexterp(spread_tenor, spread_rates, TTM[j])
                                    else:
                                        calculated_value = flatexterp(spread_tenor, spread_rates, TTM[j])
                                else:
                                    calculated_value = linearinterp(spread_tenor, spread_rates, TTM[j])
                                credit_spread_rates = np.append(credit_spread_rates, calculated_value)
                            zero_rates = zero_rates + credit_spread_rates

                    (
                        PV_output,
                        PV_table,
                        TTM_array,
                        Total_amount_array,
                        DF,
                        PV_coupons,
                        PV_principal,
                        PV_plus_1bps,
                        PV_minus_1bps,
                    ) = fixed_income_valuation(
                        TTM,
                        Total_Amount,
                        zero_rates,
                        Coupons,
                        Principal,
                        curve_compounding_frequency=curve_compounding_frequency,
                    )
                    cashflow_model_results["DF"] = DF
                    cashflow_model_results["PV of Coupons"] = PV_coupons
                    cashflow_model_results["PV of Principal"] = PV_principal
                    cashflow_model_results["PV of Total Amount"] = PV_table
                    valuation_output = {
                        "Unique Reference Id": config_dict["inputs"]["Unique_Reference_Id"],
                        "Valuation Date": config_dict["inputs"]["Valuation_date"],
                        "PV": round(PV_output, 4),
                    }
                    valuation_results.append(valuation_output)

                elif config_dict["inputs"]["Valuation_Method"] == "mtm_valuation":
                    PV = np.array(
                        [
                            mtm_data[
                                (
                                    mtm_data["security_identifier"]
                                    == config_dict["inputs"]["Unique_Reference_Id"]
                                )
                                & (
                                    mtm_data["extract_date"]
                                    == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                                )
                            ]["quoted_price"].iloc[0]
                        ]
                    )
                    Valuation_Date = pd.to_datetime(
                        mtm_data.loc[
                            mtm_data["security_identifier"] == config_dict["inputs"]["Unique_Reference_Id"],
                            "extract_date",
                        ].iloc[0],
                        dayfirst=True,
                    ).strftime("%Y-%m-%d %H:%M:%S")
                    valuation_output = {
                        "Unique Reference Id": config_dict["inputs"]["Unique_Reference_Id"],
                        "Valuation Date": Valuation_Date,
                        "PV": PV[0],
                    }
                    valuation_results.append(valuation_output)
                    ytm = np.array(
                        [
                            mtm_data[
                                (
                                    mtm_data["security_identifier"]
                                    == config_dict["inputs"]["Unique_Reference_Id"]
                                )
                                & (
                                    mtm_data["extract_date"]
                                    == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                                )
                            ]["yield"].iloc[0]
                        ]
                    )
                    (
                        PV_output,
                        PV_table,
                        TTM_array,
                        Total_amount_array,
                        DF,
                        PV_coupons,
                        PV_principal,
                    ) = valuation_models.fixed_income_mtm_valuation(
                        TTM, Total_Amount, Coupons, Principal, ytm, PV
                    )
                    cashflow_model_results["DF"] = DF
                    cashflow_model_results["PV of Coupons"] = PV_coupons
                    cashflow_model_results["PV of Principal"] = PV_principal
                    cashflow_model_results["PV of Total Amount"] = PV_table

                if config_dict["outputs"]["Sensitivity_Analysis"] == "Yes":
                    if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                        (
                            PV01,
                            macaulay_duration,
                            modified_duration,
                            effective_duration,
                            ytm,
                        ) = valuation_models.fixed_income_sensitivity_analysis(
                            PV_table,
                            TTM_array,
                            Total_amount_array,
                            Coupon_Frequency,
                            Coupon_Frequency_unit,
                            PV_output,
                            PV_plus_1bps,
                            PV_minus_1bps,
                        )
                        sensitivity_analysis.append(
                            {
                                "Macaulay_Duration": macaulay_duration,
                                "Effective Duration": effective_duration,
                                "Modified_Duration": modified_duration,
                                "PV01 per unit": PV01,
                            }
                        )
                    elif config_dict["inputs"]["Valuation_Method"] == "mtm_valuation":
                        modified_duration = mtm_data[
                            (mtm_data["security_identifier"] == config_dict["inputs"]["Unique_Reference_Id"])
                            & (
                                mtm_data["extract_date"]
                                == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                            )
                        ]["modified_duration"].iloc[0]
                        ytm = mtm_data[
                            (mtm_data["security_identifier"] == config_dict["inputs"]["Unique_Reference_Id"])
                            & (
                                mtm_data["extract_date"]
                                == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                            )
                        ]["yield"].iloc[0]
                        (
                            PV01,
                            macaulay_duration,
                            modified_duration,
                            effective_duration,
                            ytm,
                        ) = valuation_models.fixed_income_mtm_sensitivity_analysis(
                            modified_duration,
                            ytm,
                            TTM_array,
                            Total_amount_array,
                            Coupon_Frequency,
                            Coupon_Frequency_unit,
                            PV,
                            PV_table=PV_table,
                        )
                        sensitivity_analysis.append(
                            {
                                "Macaulay_Duration": macaulay_duration,
                                "Effective Duration": effective_duration[0],
                                "Modified_Duration": modified_duration,
                                "PV01 per unit": PV01,
                            }
                        )

        return cashflow_model_results, valuation_results, sensitivity_analysis

    elif config_dict["inputs"]["model_code"] == "M007":
        if len(df) > 0:
            pass
        else:
            Unique_Reference_Id = np.array([config_dict["inputs"]["Unique_Reference_Id"]])
            Issue_Date = pd.to_datetime(config_dict["inputs"]["Issue_Date"], dayfirst=True)
            Maturity_Date = np.array([pd.to_datetime(config_dict["inputs"]["Maturity_Date"], dayfirst=True)])
            Face_Value = np.array([float(config_dict["inputs"]["Face_Value"])])
            Redemption_Amount = np.array([float(config_dict["inputs"]["Redemption_Amount"])])
            if config_dict["inputs"].get("Spread_Over_Benchmark"):
                Spread_Over_Benchmark = config_dict["inputs"].get("Spread_Over_Benchmark")
            else:
                Spread_Over_Benchmark = "0"
            Coupon_Frequency = config_dict["inputs"]["Coupon_frequency"]
            Coupon_Frequency_unit = config_dict["inputs"]["Coupon_frequency_unit"]
            Valuation_Date = np.array([np.datetime64(config_dict["inputs"]["Valuation_date"], "D")])
            Discount_Daycount = np.array([config_dict["inputs"]["Discount_daycount_convention"]])
            Accrual_Daycount = np.array([config_dict["inputs"]["Accrual_daycount_convention"]])
            Discount_Curve = np.array([config_dict["inputs"]["Discount_Curve"]])
            Business_day_convention = np.array([config_dict["inputs"]["Business_day_convention"]])
            Last_coupon_date = np.datetime64(config_dict["inputs"]["Last_coupon_date"], "D")
            Coupon_Benchmark_Curve = np.array([config_dict["inputs"]["Benchmark_Curve"]])
            Next_Repricing_Date = pd.to_datetime(config_dict["inputs"]["Next_Repricing_Date"], dayfirst=True)
            if config_dict["inputs"].get("Last_Repricing_Date"):
                Last_Repricing_Date = pd.to_datetime(
                    config_dict["inputs"].get("Last_Repricing_Date"), dayfirst=True
                )
            else:
                Last_Repricing_Date = np.datetime64("NaT")

            Repricing_Frequency = config_dict["inputs"]["Repricing_Frequency"]
            Repricing_Frequency_unit = config_dict["inputs"]["Repricing_Frequency_unit"]
            Credit_Spread_Rate = config_dict["inputs"].get("Credit_Spread_Rate")
            Credit_Spread_Curve = config_dict["inputs"].get("Credit_Spread_Curve")

            cashflow_results = valuation_models.floating_coupon_cashflow_generation(
                Unique_Reference_Id,
                Issue_Date,
                Maturity_Date,
                Face_Value,
                Redemption_Amount,
                Spread_Over_Benchmark,
                Coupon_Frequency,
                Coupon_Frequency_unit,
                Valuation_Date,
                Discount_Daycount,
                Accrual_Daycount,
                Discount_Curve,
                Business_day_convention,
                Last_coupon_date,
                Coupon_Benchmark_Curve,
                Next_Repricing_Date,
                Last_Repricing_Date,
                curve_data,
                Repricing_Frequency,
                Repricing_Frequency_unit,
                holiday_calendar,
                custom_daycount_conventions,
            )
            index_values = [
                "Unique Reference Id",
                "Valuation Date",
                "Cashflow Dates",
                "Time Elapsed",
                "Coupons",
                "Principal",
                "Total Amount",
            ]
            cashflow_model_results = pd.DataFrame(data=cashflow_results, index=index_values).transpose()
            cashflow_model_results["Unique Reference Id"] = Unique_Reference_Id[0]
            cashflow_model_results["Valuation Date"] = Valuation_Date[0]
            cashflow_model_results["DF"] = ""
            cashflow_model_results["PV of Coupons"] = ""
            cashflow_model_results["PV of Principal"] = ""
            cashflow_model_results["PV of Total Amount"] = ""
            cashflow_model_results = cashflow_model_results.astype(
                {
                    "Time Elapsed": "float64",
                    "Coupons": "float64",
                    "Principal": "float64",
                    "Total Amount": "float64",
                }
            )
            valuation_results = []
            sensitivity_analysis = []
            if config_dict["outputs"]["Valuation"] == "Yes":
                TTM = cashflow_model_results["Time Elapsed"].to_numpy(dtype="float64")
                Total_Amount = cashflow_model_results["Total Amount"].to_numpy(dtype="float64")
                Coupons = cashflow_model_results["Coupons"].to_numpy(dtype="float64")
                Principal = cashflow_model_results["Principal"].to_numpy(dtype="float64")
                if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                    zero_rate_curve = Discount_Curve[0]
                    zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
                    interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
                    extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                    curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[
                        0
                    ]
                    tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                    rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                    zero_rates = np.empty([0], dtype="float64")
                    for j in range(len(TTM)):
                        if interpolation_algorithm == "Linear":
                            if linearinterp(tenor, rates, TTM[j]) is None:
                                if extrapolation_algorithm == "Linear":
                                    extrapolated_value = linearexterp(tenor, rates, TTM[j])
                                else:
                                    extrapolated_value = flatexterp(tenor, rates, TTM[j])
                                zero_rates = np.append(zero_rates, extrapolated_value)
                            else:
                                interpolated_value = linearinterp(tenor, rates, TTM[j])
                                zero_rates = np.append(zero_rates, interpolated_value)
                    # Add Credit Spread Rate to zero_rates
                    if bool(Credit_Spread_Rate[0]):
                        zero_rates = zero_rates + float(Credit_Spread_Rate[0])
                    elif len(Credit_Spread_Curve) > 0:
                        spread_rate_curve = Credit_Spread_Curve[0]
                        credit_spread_curve_data = spread_curve_data.loc[
                            (spread_curve_data["credit_spread_curve_name"] == spread_rate_curve), :
                        ]
                        if len(credit_spread_curve_data) > 0:
                            spread_tenor = np.array(credit_spread_curve_data.tenor.tolist())
                            spread_tenor_unit = np.array(credit_spread_curve_data.tenor_unit.tolist())
                            cs_interpolation_algorithm = credit_spread_curve_data[
                                "interpolation_algorithm"
                            ].iloc[0]
                            cs_extrapolation_algorithm = credit_spread_curve_data[
                                "extrapolation_algorithm"
                            ].iloc[0]
                            tenor_extrac = np.vectorize(tenor_extraction)
                            spread_tenor = tenor_extrac(spread_tenor, spread_tenor_unit)
                            spread_rates = np.array(credit_spread_curve_data.spread_value.tolist())
                            credit_spread_rates = np.empty([0], dtype="float64")
                            for j in range(len(TTM)):
                                if linearinterp(spread_tenor, spread_rates, TTM[j]) is None:
                                    if cs_extrapolation_algorithm == "Linear":
                                        calculated_value = linearexterp(spread_tenor, spread_rates, TTM[j])
                                    else:
                                        calculated_value = flatexterp(spread_tenor, spread_rates, TTM[j])
                                else:
                                    calculated_value = linearinterp(spread_tenor, spread_rates, TTM[j])
                                credit_spread_rates = np.append(credit_spread_rates, calculated_value)
                            zero_rates = zero_rates + credit_spread_rates

                    (
                        PV_output,
                        PV_table,
                        TTM_array,
                        Total_amount_array,
                        DF,
                        PV_coupons,
                        PV_principal,
                        PV_plus_1bps,
                        PV_minus_1bps,
                    ) = fixed_income_valuation(
                        TTM,
                        Total_Amount,
                        zero_rates,
                        Coupons,
                        Principal,
                        curve_compounding_frequency=curve_compounding_frequency,
                    )
                    cashflow_model_results["DF"] = DF
                    cashflow_model_results["PV of Coupons"] = PV_coupons
                    cashflow_model_results["PV of Principal"] = PV_principal
                    cashflow_model_results["PV of Total Amount"] = PV_table
                    valuation_output = {
                        "Unique Reference Id": config_dict["inputs"]["Unique_Reference_Id"],
                        "Valuation Date": config_dict["inputs"]["Valuation_date"],
                        "PV": round(PV_output, 4),
                    }
                    valuation_results.append(valuation_output)

                elif config_dict["inputs"]["Valuation_Method"] == "mtm_valuation":
                    PV = np.array(
                        [
                            mtm_data[
                                (
                                    mtm_data["security_identifier"]
                                    == config_dict["inputs"]["Unique_Reference_Id"]
                                )
                                & (
                                    mtm_data["extract_date"]
                                    == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                                )
                            ]["quoted_price"].iloc[0]
                        ]
                    )
                    Valuation_Date = pd.to_datetime(
                        mtm_data.loc[
                            mtm_data["security_identifier"] == config_dict["inputs"]["Unique_Reference_Id"],
                            "extract_date",
                        ].iloc[0],
                        dayfirst=True,
                    ).strftime("%Y-%m-%d %H:%M:%S")
                    valuation_output = {
                        "Unique Reference Id": config_dict["inputs"]["Unique_Reference_Id"],
                        "Valuation Date": Valuation_Date,
                        "PV": PV[0],
                    }
                    valuation_results.append(valuation_output)
                    ytm = np.array(
                        [
                            mtm_data[
                                (
                                    mtm_data["security_identifier"]
                                    == config_dict["inputs"]["Unique_Reference_Id"]
                                )
                                & (
                                    mtm_data["extract_date"]
                                    == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                                )
                            ]["yield"].iloc[0]
                        ]
                    )
                    (
                        PV_output,
                        PV_table,
                        TTM_array,
                        Total_amount_array,
                        DF,
                        PV_coupons,
                        PV_principal,
                    ) = valuation_models.fixed_income_mtm_valuation(
                        TTM, Total_Amount, Coupons, Principal, ytm, PV
                    )
                    cashflow_model_results["DF"] = DF
                    cashflow_model_results["PV of Coupons"] = PV_coupons
                    cashflow_model_results["PV of Principal"] = PV_principal
                    cashflow_model_results["PV of Total Amount"] = PV_table

                if config_dict["outputs"]["Sensitivity_Analysis"] == "Yes":
                    if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                        (
                            PV01,
                            macaulay_duration,
                            modified_duration,
                            effective_duration,
                            ytm,
                        ) = valuation_models.fixed_income_sensitivity_analysis(
                            PV_table,
                            TTM_array,
                            Total_amount_array,
                            Coupon_Frequency,
                            Coupon_Frequency_unit,
                            PV_output,
                            PV_plus_1bps,
                            PV_minus_1bps,
                        )
                        sensitivity_analysis.append(
                            {
                                "Macaulay Duration": macaulay_duration,
                                "Effective Duration": effective_duration,
                                "Modified Duration": modified_duration,
                                "PV01 per unit": PV01,
                            }
                        )
                    elif config_dict["inputs"]["Valuation_Method"] == "mtm_valuation":
                        modified_duration = mtm_data[
                            (mtm_data["security_identifier"] == config_dict["inputs"]["Unique_Reference_Id"])
                            & (
                                mtm_data["extract_date"]
                                == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                            )
                        ]["modified_duration"].iloc[0]
                        ytm = mtm_data[
                            (mtm_data["security_identifier"] == config_dict["inputs"]["Unique_Reference_Id"])
                            & (
                                mtm_data["extract_date"]
                                == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                            )
                        ]["yield"].iloc[0]
                        (
                            PV01,
                            macaulay_duration,
                            modified_duration,
                            effective_duration,
                            ytm,
                        ) = valuation_models.fixed_income_mtm_sensitivity_analysis(
                            modified_duration,
                            ytm,
                            TTM_array,
                            Total_amount_array,
                            Coupon_Frequency,
                            Coupon_Frequency_unit,
                            PV,
                            PV_table=PV_table,
                        )
                        sensitivity_analysis.append(
                            {
                                "Macaulay_Duration": macaulay_duration,
                                "Effective Duration": effective_duration[0],
                                "Modified_Duration": modified_duration,
                                "PV01 per unit": PV01,
                            }
                        )

        return cashflow_model_results, valuation_results, sensitivity_analysis

    elif config_dict["inputs"]["model_code"] == "M008":
        if len(df) > 0:
            pass

        else:
            Collateral = config_dict["inputs"]["Unique_Reference_Id"]
            Valuation_Date = np.array(
                [pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)]
            )
            Repo_End_Date = np.array([config_dict["inputs"]["Maturity_Date"]])
            config_dict["inputs"]["Initial_Amount"] = float(config_dict["inputs"]["Initial_Amount"])
            Lending_Amount = config_dict["inputs"]["Initial_Amount"]
            config_dict["inputs"]["Underlying_Face_Value"] = float(
                config_dict["inputs"]["Underlying_Face_Value"]
            )
            Face_Value = config_dict["inputs"]["Underlying_Face_Value"]
            config_dict["inputs"]["Sale_Price"] = float(config_dict["inputs"]["Sale_Price"])
            Sale_Price = config_dict["inputs"]["Sale_Price"]

            Accrual_Daycount = np.array([config_dict["inputs"]["Accrual_daycount_convention"]])
            Discount_Daycount = np.array([config_dict["inputs"]["Discount_daycount_convention"]])
            Discount_Curve = np.array([config_dict["inputs"]["Discount_Curve"]])
            Business_day_convention = np.array([config_dict["inputs"]["Business_day_convention"]])
            Credit_Spread_Curve = np.array([config_dict["inputs"].get("Credit_Spread_Curve")])
            credit_spread_rate = np.array([config_dict["inputs"]["Credit_Spread_Rate"]])

            position_direction = np.array([config_dict["inputs"]["Position_Direction"]])

            Valuation_Date = Valuation_Date.astype("datetime64[D]")
            Repo_End_Date = Repo_End_Date.astype("datetime64[D]")

            discount_convention_code = valuation_models.daycount_convention_code(Discount_Daycount)
            convention_code = valuation_models.busday_convention_code(Business_day_convention)
            cashflow_date = conventions.business_day(Repo_End_Date, convention_code, holiday_calendar)
            TTM_array = conventions.D_day_count(
                Valuation_Date,
                Repo_End_Date,
                discount_convention_code,
                custom_daycount_conventions=custom_daycount_conventions,
            )
            Number_Of_Bonds = Lending_Amount / Sale_Price
            valuation_results = []
            sensitivity_analysis = []
            if position_direction == "Sell":
                ReSale_Amount = Number_Of_Bonds * Face_Value
                index_values = [
                    "Collateral",
                    "Valuation Date",
                    "Cashflow Dates",
                    "Time Elapsed",
                    "Coupons",
                    "Principal",
                    "Resale Amount",
                ]
            elif position_direction == "Buy":
                ReSale_Amount = -1 * Number_Of_Bonds * Face_Value
                index_values = [
                    "Collateral",
                    "Valuation Date",
                    "Cashflow Dates",
                    "Time Elapsed",
                    "Coupons",
                    "Principal",
                    "Repurchase Amount",
                ]
            cashflow_date = cashflow_date[0]
            cashflow_date = pd.to_datetime(cashflow_date, dayfirst=True).strftime("%Y-%m-%d")

            cashflow_results = [
                Collateral,
                config_dict["inputs"]["Valuation_date"],
                cashflow_date,
                TTM_array[0],
                "-",
                Face_Value,
                ReSale_Amount,
            ]
            cashflow_model_results = pd.DataFrame(data=cashflow_results, index=index_values).transpose()
            if position_direction == "Sell":
                cashflow_model_results = cashflow_model_results.astype(
                    {
                        "Time Elapsed": "float64",
                        "Principal": "float64",
                        "Resale Amount": "float64",
                    }
                )
            elif position_direction == "Buy":
                cashflow_model_results = cashflow_model_results.astype(
                    {
                        "Time Elapsed": "float64",
                        "Principal": "float64",
                        "Repurchase Amount": "float64",
                    }
                )
            if config_dict["outputs"]["Valuation"] == "Yes":
                if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                    zero_rate_curve = Discount_Curve[0]
                    zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
                    interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
                    extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                    curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[
                        0
                    ]
                    tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                    rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                    zero_rates = np.empty([0], dtype="float64")
                    for j in range(len(TTM_array)):
                        if interpolation_algorithm == "Linear":
                            if linearinterp(tenor, rates, TTM_array[j]) is None:
                                if extrapolation_algorithm == "Linear":
                                    extrapolated_value = linearexterp(tenor, rates, TTM_array[j])
                                else:
                                    extrapolated_value = flatexterp(tenor, rates, TTM_array[j])
                                zero_rates = np.append(zero_rates, extrapolated_value)
                            else:
                                interpolated_value = linearinterp(tenor, rates, TTM_array[j])
                                zero_rates = np.append(zero_rates, interpolated_value)
                    if bool(credit_spread_rate[0]):
                        all_in_rate = zero_rates[0] + float(credit_spread_rate[0])
                    elif len(Credit_Spread_Curve) > 0:
                        spread_rate_curve = Credit_Spread_Curve[0]
                        credit_spread_curve_data = spread_curve_data.loc[
                            (spread_curve_data["credit_spread_curve_name"] == spread_rate_curve), :
                        ]
                        if len(credit_spread_curve_data) > 0:
                            spread_tenor = np.array(credit_spread_curve_data.tenor.tolist())
                            spread_tenor_unit = np.array(credit_spread_curve_data.tenor_unit.tolist())
                            cs_interpolation_algorithm = credit_spread_curve_data[
                                "interpolation_algorithm"
                            ].iloc[0]
                            cs_extrapolation_algorithm = credit_spread_curve_data[
                                "extrapolation_algorithm"
                            ].iloc[0]
                            tenor_extrac = np.vectorize(tenor_extraction)
                            spread_tenor = tenor_extrac(spread_tenor, spread_tenor_unit)
                            spread_rates = np.array(credit_spread_curve_data.spread_value.tolist())
                            credit_spread_rates = np.empty([0], dtype="float64")
                            for j in range(len(TTM_array)):
                                if linearinterp(spread_tenor, spread_rates, TTM_array[j]) is None:
                                    if cs_extrapolation_algorithm == "Linear":
                                        calculated_value = linearexterp(
                                            spread_tenor, spread_rates, TTM_array[j]
                                        )
                                    else:
                                        calculated_value = flatexterp(
                                            spread_tenor, spread_rates, TTM_array[j]
                                        )
                                else:
                                    calculated_value = linearinterp(spread_tenor, spread_rates, TTM_array[j])
                                credit_spread_rates = np.append(credit_spread_rates, calculated_value)
                            all_in_rate = zero_rates + credit_spread_rates
                    ReSale_Amount = np.array([ReSale_Amount])
                    PV, TTM_array, df, PV_plus_1bps, PV_minus_1bps = commercial_paper_valuation(
                        TTM_array,
                        ReSale_Amount,
                        all_in_rate,
                        curve_compounding_frequency=curve_compounding_frequency,
                    )
                    valuation_output = {
                        "Collateral": config_dict["inputs"]["Unique_Reference_Id"],
                        "Valuation Date": config_dict["inputs"]["Valuation_date"],
                        "PV": PV[0],
                    }
                    valuation_results.append(valuation_output)
                    cashflow_model_results["DF"] = df
                    cashflow_model_results["PV of Principal"] = ReSale_Amount * df
                elif config_dict["inputs"]["Valuation_Method"] == "mtm_valuation":
                    PV = np.array(
                        [
                            mtm_data[
                                (
                                    mtm_data["security_identifier"]
                                    == config_dict["inputs"]["Unique_Reference_Id"]
                                )
                                & (
                                    mtm_data["extract_date"]
                                    == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                                )
                            ]["quoted_price"].iloc[0]
                        ]
                    )
                    Valuation_Date = pd.to_datetime(
                        mtm_data.loc[
                            mtm_data["security_identifier"] == config_dict["inputs"]["Unique_Reference_Id"],
                            "extract_date",
                        ].iloc[0],
                        dayfirst=True,
                    ).strftime("%Y-%m-%d %H:%M:%S")
                    valuation_output = {
                        "Collateral": config_dict["inputs"]["Unique_Reference_Id"],
                        "Valuation Date": Valuation_Date,
                        "PV": PV[0],
                    }
                    valuation_results.append(valuation_output)

                if config_dict["outputs"]["Sensitivity_Analysis"] == "Yes":
                    if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                        (
                            macaulay_duration,
                            modified_duration,
                            PV01,
                            effective_duration,
                            ytm,
                        ) = valuation_models.commercial_paper_sensitivity_analysis(
                            PV, TTM_array, ReSale_Amount, PV_plus_1bps, PV_minus_1bps
                        )
                        sensitivity_analysis.append(
                            {
                                "Macaulay_Duration": macaulay_duration[0],
                                "Effective Duration": effective_duration[0],
                                "Modified_Duration": modified_duration[0],
                                "PV01 per unit": PV01[0],
                            }
                        )
                    elif config_dict["inputs"]["Valuation_Method"] == "mtm_valuation":
                        modified_duration = mtm_data[
                            (mtm_data["security_identifier"] == config_dict["inputs"]["Unique_Reference_Id"])
                            & (
                                mtm_data["extract_date"]
                                == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                            )
                        ]["modified_duration"].iloc[0]
                        ytm = np.array(
                            [
                                mtm_data[
                                    (
                                        mtm_data["security_identifier"]
                                        == config_dict["inputs"]["Unique_Reference_Id"]
                                    )
                                    & (
                                        mtm_data["extract_date"]
                                        == pd.to_datetime(
                                            config_dict["inputs"]["Valuation_date"], dayfirst=True
                                        )
                                    )
                                ]["yield"].iloc[0]
                            ]
                        )
                        (
                            macaulay_duration,
                            modified_duration,
                            PV01,
                            effective_duration,
                            ytm,
                        ) = valuation_models.commercial_paper_mtm_sensitivity_analysis(
                            PV[0], TTM_array, ReSale_Amount, ytm, modified_duration
                        )
                        sensitivity_analysis.append(
                            {
                                "Macaulay_Duration": macaulay_duration,
                                "Effective Duration": effective_duration[0],
                                "Modified_Duration": modified_duration,
                                "PV01 per unit": PV01,
                            }
                        )

        return cashflow_model_results, valuation_results, sensitivity_analysis

    elif config_dict["inputs"]["model_code"] in ["M009", "M013"]:
        if len(df) > 0:
            pass
        else:
            Unique_Reference_Id = np.array([config_dict["inputs"]["Unique_Reference_Id"]])
            Valuation_Date = np.array(
                [pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)]
            )
            valuation_date = np.array(
                [
                    pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True).strftime(
                        "%Y-%m-%d %H:%M:%S"
                    )
                ]
            )
            cashflow_results = [Unique_Reference_Id, valuation_date, "-", "-", "-", "-", "-"]
            index_values = [
                "Unique Reference ID",
                "Valuation Date",
                "Cashflow Dates",
                "Time Elapsed",
                "Coupons",
                "Principal",
                "Total Amount",
            ]
            cashflow_model_results = pd.DataFrame(data=cashflow_results, index=index_values).transpose()
            valuation_results = []
            sensitivity_analysis = []

            if config_dict["outputs"]["Valuation"] == "Yes":
                quantity = float(config_dict["inputs"]["Quantity"])
                if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                    valuation_output = {
                        "Unique Reference Id": config_dict["inputs"]["Unique_Reference_Id"],
                        "Issuer": config_dict["inputs"]["Issuer"],
                        "Valuation Date": config_dict["inputs"]["Valuation_date"],
                        "Quantity": config_dict["inputs"]["Quantity"],
                        "Price per Unit": config_dict["inputs"]["Purchase_Price"],
                        "Total Amount": round(Total_Amount[0], 4),
                    }
                elif config_dict["inputs"]["Valuation_Method"] == "mtm_valuation":
                    price = mtm_data[
                        (mtm_data["security_identifier"] == config_dict["inputs"]["Unique_Reference_Id"])
                        & (
                            mtm_data["extract_date"]
                            == pd.to_datetime(config_dict["inputs"]["Valuation_date"], dayfirst=True)
                        )
                    ]["quoted_price"].iloc[0]
                    valuation_date = pd.to_datetime(
                        config_dict["inputs"]["Valuation_date"], dayfirst=True
                    ).strftime("%Y-%m-%d %H:%M:%S")
                    total_amount = quantity * price
                    valuation_output = {
                        "Unique Reference ID": config_dict["inputs"]["Unique_Reference_Id"],
                        "Issuer": config_dict["inputs"]["Issuer"],
                        "Valuation Date": valuation_date,
                        "Quantity": quantity,
                        "Price per Unit": price,
                        "Total Amount": total_amount,
                    }
                    valuation_results.append(valuation_output)

                if config_dict["outputs"]["Sensitivity_Analysis"] == "Yes":
                    if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                        sensitivity_analysis.append(
                            {
                                "Macaulay_Duration": "-",
                                "Effective Duration": "-",
                                "Modified_Duration": "-",
                                "PV01 per unit": "-",
                            }
                        )
                    elif config_dict["inputs"]["Valuation_Method"] == "mtm_valuation":
                        sensitivity_analysis.append(
                            {
                                "Macaulay_Duration": "-",
                                "Effective Duration": "-",
                                "Modified_Duration": "-",
                                "PV01 per unit": "-",
                            }
                        )

    return cashflow_model_results, valuation_results, sensitivity_analysis


@wrap_non_picklable_objects
def Value_extraction_pf(
    row,
    column_index_dict,
    config_dict,
    curve_repo_data,
    curve_components_data,
    cs_curve_repo_data,
    cs_curve_components_data,
    vol_repo_data,
    vol_components_data,
    holiday_calendar,
    currency_data,
    NMD_adjustments,
    repayment_schedule,
    mtm_data=None,
    vix_data=None,
    cf_analysis_id=None,
    cashflow_uploaded_data=None,
    underlying_position_data=None,
    custom_daycount_conventions=None,
    dpd_ruleset=None,
    overdue_bucketing_data=None,
    dpd_schedule=None,
    product_holiday_code=None,
    request=None,
):
    curve_component_transformation_vect = np.vectorize(curve_component_transformation)
    curve_component_transformation_result = curve_component_transformation_vect(
        curve_repo_data.to_dict("records")
    )
    curve_data = pd.concat(curve_component_transformation_result, ignore_index=True)

    del curve_component_transformation_result

    curve_data = curve_data.merge(
        curve_components_data, left_on="curve_components", right_on="id", how="left"
    ).drop(columns=["curve_components", "id"])
    curve_data["tenor"] = np.where(
        curve_data["tenor_unit"] == "D",
        curve_data["tenor_value"] / 365.25,
        np.where(curve_data["tenor_unit"] == "M", curve_data["tenor_value"] / 12, curve_data["tenor_value"]),
    )
    curve_data = (
        curve_data.merge(
            mtm_data.loc[
                mtm_data["extract_date"]
                == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True),
                ["security_identifier", "quoted_price"],
            ],
            left_on="curve_component",
            right_on="security_identifier",
            how="left",
        )
        .drop(columns=["security_identifier"])
        .rename(columns={"quoted_price": "rate"})
    )
    curve_data.sort_values(by=["curve_name", "tenor"], inplace=True)
    cs_curve_component_transformation_result = curve_component_transformation_vect(
        cs_curve_repo_data.to_dict("records")
    )
    cs_curve_data = pd.concat(cs_curve_component_transformation_result, ignore_index=True)
    del cs_curve_component_transformation_result
    cs_curve_data = cs_curve_data.merge(
        cs_curve_components_data, left_on="curve_components", right_on="id", how="left"
    ).drop(columns=["curve_components", "id"])
    cs_curve_data["tenor"] = np.where(
        cs_curve_data["tenor_unit"] == "D",
        cs_curve_data["tenor_value"] / 365.25,
        np.where(
            cs_curve_data["tenor_unit"] == "M",
            cs_curve_data["tenor_value"] / 12,
            cs_curve_data["tenor_value"],
        ),
    )
    credit_spread_data = (
        cs_curve_data.merge(
            mtm_data.loc[
                mtm_data["extract_date"]
                == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True),
                ["security_identifier", "quoted_price"],
            ],
            left_on="curve_component",
            right_on="security_identifier",
            how="left",
        )
        .drop(columns=["security_identifier"])
        .rename(columns={"quoted_price": "spread_value", "curve_name": "credit_spread_curve_name"})
    )
    del cs_curve_data
    credit_spread_data.sort_values(by=["credit_spread_curve_name", "tenor"], inplace=True)
    credit_spread_data = credit_spread_data.drop(columns=["tenor"]).rename(columns={"tenor_value": "tenor"})

    if row[column_index_dict["model_code"]] in [
        "M027",
        "M014",
        "M015",
        "M016",
        "M017",
        "M040",
        "M041",
        "M042",
        "M043",
        "M044",
    ]:
        vol_component_transformation_vect = np.vectorize(vol_component_transformation)
        vol_component_transformation_result = vol_component_transformation_vect(
            vol_repo_data.to_dict("records")
        )
        vol_data = pd.concat(vol_component_transformation_result, ignore_index=True)
        del vol_component_transformation_result
        vol_data = vol_data.merge(
            vol_components_data, left_on="vol_surface_component", right_on="id", how="left"
        ).drop(columns=["vol_surface_component", "id"])
        vol_data["tenor"] = np.where(
            vol_data["tenor_unit"] == "D",
            vol_data["tenor_value"] / 365.25,
            np.where(vol_data["tenor_unit"] == "M", vol_data["tenor_value"] / 12, vol_data["tenor_value"]),
        )
        vol_data = vol_data.merge(
            mtm_data.loc[
                mtm_data["extract_date"]
                == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True),
                ["security_identifier", "volatility"],
            ],
            left_on="surface_component",
            right_on="security_identifier",
            how="left",
        ).drop(columns=["security_identifier"])
        vol_data.sort_values(by=["surface_name", "tenor"], inplace=True)
    else:
        vol_data = pd.DataFrame()
    Unique_Reference_Id = row[column_index_dict["unique_reference_id"]]
    Position_Id = row[column_index_dict["position_id"]]
    Valuation_Date = np.array([np.datetime64(row[column_index_dict["reporting_date"]], "D")])
    currency = row[column_index_dict["primary_currency"]]
    asset_liability_type = row[column_index_dict["asset_liability_type"]]
    product_variant_name = row[column_index_dict["product_variant_name"]]
    business_days = product_holiday_code.loc[
        product_holiday_code["product_variant_name"] == product_variant_name, "business_days"
    ].iloc[0]
    z_spread_calculation = product_holiday_code.loc[
        product_holiday_code["product_variant_name"] == product_variant_name, "z_spread_calculation"
    ].iloc[0]
    fund = row[column_index_dict["fund_code"]]
    portfolio = row[column_index_dict["pool_id"]]
    entity = row[column_index_dict["legal_entity"]]
    reference_dimension = "Security"
    cashflow_status = "Unrealised"
    Quantity = row[column_index_dict["quantity"]]
    if str(Quantity) not in ["nan", "None", ""]:
        Quantity = float(Quantity)
    else:
        Quantity = 1
    holiday_calendar_name = row[column_index_dict["holiday_calendar"]]

    if str(holiday_calendar_name) in ["nan", "None"]:
        holiday_calendar_name = currency_data.loc[
            currency_data["currency_code"] == currency, "default_holiday_calendar"
        ]
        if len(holiday_calendar_name) > 0:
            holiday_calendar_name = holiday_calendar_name.iloc[0]
            holiday_calendar = np.array(
                holiday_calendar.loc[
                    holiday_calendar["holiday_calendar"] == holiday_calendar_name, "holiday_date"
                ]
            ).astype("datetime64[D]")
        else:
            holiday_calendar = []

    if row[column_index_dict["model_code"]] in ["M001", "M035"]:
        final_output_dict = {}
        Maturity_Date = np.array(np.datetime64(row[column_index_dict["maturity_date"]], "D"))
        Redemption_Amount = np.array([float(row[column_index_dict["redemption_amount"]])])
        Discount_Daycount = np.array([row[column_index_dict["discount_daycount_convention"]]])
        Accrual_Daycount = np.array([row[column_index_dict["accrual_daycount_convention"]]])
        Discount_Curve = row[column_index_dict["discounting_curve"]]
        Business_day_convention = np.array([row[column_index_dict["business_convention"]]])
        discount_convention_code = valuation_models.daycount_convention_code(Discount_Daycount)
        convention_code = valuation_models.busday_convention_code(Business_day_convention)
        cashflow_date = conventions.business_day(
            Maturity_Date, convention_code, holiday_calendar, business_days=business_days
        )
        yield_compounding_frequency = row[column_index_dict["yield_compounding_frequency"]]
        yield_compounding_frequency_unit = row[column_index_dict["yield_compounding_frequency_units"]]
        if str(yield_compounding_frequency) not in ["nan", "None", ""] and str(
            yield_compounding_frequency_unit
        ) not in ["nan", "None", ""]:
            ytm_frequency = valuation_models.coupon_Frequency(
                yield_compounding_frequency, yield_compounding_frequency_unit
            )
        else:
            ytm_frequency = 1
        Maturity_Date = np.array(
            [
                business_day_val(
                    pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True).date(),
                    convention_code,
                    [],
                )
            ],
            dtype="datetime64[D]",
        )
        TTM_array = conventions.D_day_count(
            Valuation_Date,
            Maturity_Date,
            discount_convention_code,
            custom_daycount_conventions=custom_daycount_conventions,
        )
        valuation_results = []
        sensitivity_analysis = []
        if cashflow_uploaded_data is not None and len(cashflow_uploaded_data) > 0:
            cashflow_uploaded_data_position = cashflow_uploaded_data.loc[
                cashflow_uploaded_data["position_id"] == Position_Id
            ]
        else:
            cashflow_uploaded_data_position = pd.DataFrame()
        if len(cashflow_uploaded_data_position) > 0:
            cashflow_upload = True
            cashflow_uploaded_data_position["cashflow"] = (
                cashflow_uploaded_data_position["cashflow"] / Quantity
            )
            cashflow_model_results = cashflow_uploaded_data_position
            cashflow_model_results[["cashflow_status", "discount_factor", "present_value"]] = [
                cashflow_status,
                "",
                "",
            ]
            del cashflow_uploaded_data_position
        else:
            cashflow_upload = False
            cashflow_model_results = {
                "extract_date": Valuation_Date[0],
                "transaction_date": pd.to_datetime(cashflow_date, dayfirst=True),
                "unique_reference_id": Unique_Reference_Id,
                "reference_dimension": reference_dimension,
                "cashflow_type": "Redemption Proceeds",
                "cashflow_status": cashflow_status,
                "cashflow": Redemption_Amount[0],
                "time_to_maturity": TTM_array[0],
                "discount_factor": None,
                "present_value": None,
                "currency": currency,
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": "",
                "entity": entity,
            }
            cashflow_model_results = pd.DataFrame([cashflow_model_results])

        cashflow_model_results = cashflow_model_results.astype(
            {
                "time_to_maturity": "float64",
                "cashflow": "float64",
            }
        )
        measure_value = []

        output_msg = output_check_fn(cashflow_results=cashflow_model_results)

        if output_msg["CF_Output"] == "Present":

            if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
                if not cashflow_upload:
                    cashflow_model_results["cashflow_type"] = "Redemption Proceeds"
                if (
                    config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation"
                    and row[column_index_dict["model_code"]] != "M035"
                ):
                    zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == Discount_Curve), :]
                    tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                    rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                    extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                    curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[
                        0
                    ]
                    zero_rates = np.empty([0], dtype="float64")
                    for j in TTM_array:
                        if zero_rate_curve_points["interpolation_algorithm"].iloc[0] == "Linear":
                            interp_val = linearinterp(tenor, rates, j)
                            if interp_val is None:
                                if extrapolation_algorithm == "Linear":
                                    extrapolated_value = linearexterp(tenor, rates, j)
                                else:
                                    extrapolated_value = flatexterp(tenor, rates, j)
                                zero_rates = np.append(zero_rates, extrapolated_value)
                            else:
                                interpolated_value = interp_val
                                zero_rates = np.append(zero_rates, interpolated_value)
                    tenor = None
                    rates = None
                    del tenor
                    del rates
                    del zero_rate_curve_points

                    PV, TTM_array, df, PV_plus_1bps, PV_minus_1bps = commercial_paper_valuation(
                        TTM_array,
                        Redemption_Amount,
                        zero_rates,
                        curve_compounding_frequency=curve_compounding_frequency,
                    )

                    if z_spread_calculation == "Yes":
                        market_data = mtm_data[
                            (mtm_data["security_identifier"] == Unique_Reference_Id)
                            & (mtm_data["extract_date"] == Valuation_Date[0])
                        ]
                        if len(market_data) > 0 and str(market_data["quoted_price"].iloc[0]) not in [
                            "nan",
                            "None",
                            "",
                        ]:
                            (PV, TTM_array, df, PV_plus_1bps, PV_minus_1bps) = (
                                z_spread_calculation_and_revaluation_zcb(
                                    TTM_array,
                                    Redemption_Amount,
                                    zero_rates,
                                    market_data,
                                    curve_compounding_frequency=curve_compounding_frequency,
                                    request=request,
                                )
                            )

                    cashflow_model_results["discount_factor"] = df
                    cashflow_model_results["present_value"] = Redemption_Amount * df

                    output_msg = output_check_fn(valuation_output=PV)

                    if output_msg["Val_Output"] == "Present":
                        valuation_output = {
                            "PV": PV[0],
                        }
                        measure_dict_val = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value per unit",
                            "measure_value": round(PV[0], 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_dict_val_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value",
                            "measure_value": round(PV[0] * Quantity, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_val)
                        measure_value.append(measure_dict_val_position)
                        valuation_results.append(valuation_output)
                        total_holding = Quantity * valuation_results[0]["PV"]

                        if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":
                            (
                                macaulay_duration,
                                modified_duration,
                                PV01,
                                effective_duration,
                                ytm,
                            ) = valuation_models.commercial_paper_sensitivity_analysis(
                                PV, TTM_array, Redemption_Amount, PV_plus_1bps, PV_minus_1bps
                            )
                            sensitivity_analysis.append(
                                {
                                    "Macaulay Duration": macaulay_duration[0],
                                    "Effective Duration": effective_duration[0],
                                    "Modified Duration": modified_duration[0],
                                    "PV01 per unit": PV01,
                                }
                            )
                            if isinstance(ytm, (np.ndarray)):
                                ytm = ytm[0]
                            else:
                                ytm = ytm
                            measure_dict_ytm = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Yield to Maturity",
                                "measure_value": ytm,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_ytm)
                            measure_dict_mac_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Macaulay Duration",
                                "measure_value": macaulay_duration[0],
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mac_dur)
                            measure_dict_eff_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Effective Duration",
                                "measure_value": effective_duration[0],
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_eff_dur)
                            measure_dict_mod_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Modified Duration",
                                "measure_value": modified_duration[0],
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mod_dur)
                            measure_dict_pv01 = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01 per unit",
                                "measure_value": PV01,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01)
                            measure_dict_pv01_position = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01",
                                "measure_value": PV01 * Quantity,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01_position)

                    else:
                        valuation_output = {
                            "PV": "None",
                        }
                        total_holding = "None"
                        valuation_results.append(valuation_output)

                elif (
                    config_dict["inputs"]["Valuation_Method"] == "mtm_valuation"
                    or row[column_index_dict["model_code"]] == "M035"
                ):
                    security_mtm_data = mtm_data[
                        (mtm_data["security_identifier"] == Unique_Reference_Id)
                        & (mtm_data["extract_date"] == Valuation_Date[0])
                    ]
                    output_msg = output_check_fn(price_df=security_mtm_data)
                    if (
                        output_msg["Val_df_Output"] == "Present"
                        and row[column_index_dict["model_code"]] != "M035"
                    ):
                        PV = security_mtm_data["quoted_price"].iloc[0]
                        total_holding = Quantity * PV
                        valuation_output = {
                            "PV": round(PV, 4),
                        }
                        measure_dict_val = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value per unit",
                            "measure_value": round(PV, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_dict_val_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value",
                            "measure_value": round(PV * Quantity, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_val)
                        measure_value.append(measure_dict_val_position)
                        valuation_results.append(valuation_output)

                        if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":
                            modified_duration = security_mtm_data["modified_duration"].iloc[0]
                            ytm = np.array([security_mtm_data["yield"].iloc[0]])
                            PV_input = np.array([PV])
                            (
                                macaulay_duration,
                                modified_duration,
                                PV01,
                                effective_duration,
                                ytm,
                            ) = valuation_models.commercial_paper_mtm_sensitivity_analysis(
                                PV_input, TTM_array, Redemption_Amount, ytm, modified_duration
                            )
                            sensitivity_analysis.append(
                                {
                                    "Macaulay_Duration": macaulay_duration,
                                    "Effective Duration": effective_duration[0],
                                    "Modified_Duration": modified_duration,
                                    "PV01 per unit": PV01,
                                }
                            )
                            if isinstance(ytm, (np.ndarray)):
                                ytm = ytm[0]
                            else:
                                ytm = ytm
                            measure_dict_ytm = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Yield to Maturity",
                                "measure_value": ytm,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_ytm)
                            measure_dict_mac_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Macaulay Duration",
                                "measure_value": macaulay_duration,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mac_dur)
                            measure_dict_eff_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Effective Duration",
                                "measure_value": effective_duration[0],
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_eff_dur)
                            measure_dict_mod_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Modified Duration",
                                "measure_value": modified_duration,
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mod_dur)
                            measure_dict_pv01 = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01 per unit",
                                "measure_value": PV01,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01)
                            measure_dict_pv01_position = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01",
                                "measure_value": PV01 * Quantity,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01_position)

                    else:
                        ytm = np.array([security_mtm_data["yield"].iloc[0]])
                        PV, TTM_array, df = commercial_paper_mtm_valuation(
                            TTM_array, Redemption_Amount, ytm, ytm_frequency=ytm_frequency
                        )
                        cashflow_model_results["discount_factor"] = df
                        cashflow_model_results["present_value"] = Redemption_Amount * df
                        total_holding = Quantity * PV[0]
                        valuation_output = {
                            "PV": round(PV[0], 4),
                        }
                        measure_dict_val = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value per unit",
                            "measure_value": round(PV[0], 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_dict_val_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value",
                            "measure_value": round(PV[0] * Quantity, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_val)
                        measure_value.append(measure_dict_val_position)
                        valuation_results.append(valuation_output)

                        if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":
                            modified_duration = security_mtm_data["modified_duration"].iloc[0]
                            ytm = np.array([security_mtm_data["yield"].iloc[0]])
                            PV_input = np.array([PV])
                            (
                                macaulay_duration,
                                modified_duration,
                                PV01,
                                effective_duration,
                                ytm,
                            ) = valuation_models.commercial_paper_mtm_sensitivity_analysis(
                                PV_input,
                                TTM_array,
                                Redemption_Amount,
                                ytm,
                                modified_duration,
                                ytm_frequency=ytm_frequency,
                            )
                            if isinstance(macaulay_duration, (np.ndarray)):
                                macaulay_duration = macaulay_duration[0]
                            else:
                                macaulay_duration = macaulay_duration
                            if isinstance(modified_duration, (np.ndarray)):
                                modified_duration = modified_duration[0]
                            else:
                                modified_duration = modified_duration
                            if isinstance(effective_duration, (np.ndarray)):
                                effective_duration = effective_duration[0]
                            else:
                                effective_duration = effective_duration
                            sensitivity_analysis.append(
                                {
                                    "Macaulay_Duration": macaulay_duration,
                                    "Effective Duration": effective_duration[0],
                                    "Modified_Duration": modified_duration,
                                    "PV01 per unit": PV01,
                                }
                            )
                            if isinstance(ytm, (np.ndarray)):
                                ytm = ytm[0]
                            else:
                                ytm = ytm

                            measure_dict_ytm = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Yield to Maturity",
                                "measure_value": ytm,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_ytm)
                            measure_dict_mac_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Macaulay Duration",
                                "measure_value": macaulay_duration,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mac_dur)
                            measure_dict_eff_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Effective Duration",
                                "measure_value": effective_duration[0],
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_eff_dur)
                            measure_dict_mod_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Modified Duration",
                                "measure_value": modified_duration,
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mod_dur)
                            measure_dict_pv01 = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01 per unit",
                                "measure_value": PV01,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01)
                            measure_dict_pv01_position = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01",
                                "measure_value": PV01 * Quantity,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01_position)

            else:
                sensitivity_analysis.append(
                    {
                        "Macaulay_Duration": "-",
                        "Effective Duration": "-",
                        "Modified_Duration": "-",
                        "PV01 per unit": "-",
                    }
                )
                valuation_output = {
                    "PV": "None",
                }
                total_holding = "None"
                valuation_results.append(valuation_output)

        else:
            sensitivity_analysis.append(
                {
                    "Macaulay_Duration": "-",
                    "Effective Duration": "-",
                    "Modified_Duration": "-",
                    "PV01 per unit": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        cashflow_model_results = cashflow_model_results[cashflow_model_results["time_to_maturity"] != 0]
        cashflow_model_results["cashflow"] = cashflow_model_results["cashflow"] * Quantity
        cashflow_model_results["present_value"] = present_value_check_function(
            cashflow_model_results["present_value"], Quantity
        )
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = Unique_Reference_Id
        final_output_dict["Position_Id"] = Position_Id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = Valuation_Date[0]
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Quantity"] = Quantity
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        measure_value = pd.DataFrame(measure_value)
        measure_value["currency"] = currency
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] in ["M002", "M036"]:
        final_output_dict = {}
        Issue_Date = pd.to_datetime(row[column_index_dict["issue_date"]], dayfirst=True)
        Maturity_Date = np.array([pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True)])
        Face_Value = np.array([float(row[column_index_dict["face_value"]])])
        Redemption_Amount = np.array([float(row[column_index_dict["redemption_amount"]])])
        Coupon_Rate = np.array([float(row[column_index_dict["base_rate"]]) / 100])
        Coupon_Frequency = row[column_index_dict["payment_frequency"]]
        Coupon_Frequency_unit = row[column_index_dict["payment_frequency_units"]]
        Discount_Daycount = np.array([row[column_index_dict["discount_daycount_convention"]]])
        Accrual_Daycount = np.array([row[column_index_dict["accrual_daycount_convention"]]])
        Discount_Curve = row[column_index_dict["discounting_curve"]]
        Business_day_convention = np.array([row[column_index_dict["business_convention"]]])
        Last_coupon_date = row[column_index_dict["last_payment_date"]]
        if str(Last_coupon_date) not in ["nan", "NaT", "None", "-"]:
            Last_coupon_date = np.datetime64(row[column_index_dict["last_payment_date"]], "D")
        stub_date = row[column_index_dict["stub_date"]]
        if str(stub_date) not in ["nan", "NaT", "None", "-"]:
            stub_date = np.datetime64(row[column_index_dict["stub_date"]], "D")
        accrued_interest = row[column_index_dict["accrued_interest"]]
        interest_calculation_methodology = row[column_index_dict["interest_calculation_methodology"]]
        compounding_frequency = row[column_index_dict["compounding_frequency"]]
        compounding_frequency_unit = row[column_index_dict["compounding_frequency_unit"]]
        yield_compounding_frequency = row[column_index_dict["yield_compounding_frequency"]]
        yield_compounding_frequency_unit = row[column_index_dict["yield_compounding_frequency_units"]]
        principal_business_day_convention = row[column_index_dict["principal_business_day_convention"]]
        if str(yield_compounding_frequency) not in ["nan", "None", ""] and str(
            yield_compounding_frequency_unit
        ) not in ["nan", "None", ""]:
            ytm_frequency = valuation_models.coupon_Frequency(
                yield_compounding_frequency, yield_compounding_frequency_unit
            )
        else:
            ytm_frequency = 1
        if str(accrued_interest) not in ["nan", "None", ""]:
            accrued_interest = np.array([float(accrued_interest / Quantity)], dtype="float")
        valuation_results = []
        sensitivity_analysis = []
        if cashflow_uploaded_data is not None and len(cashflow_uploaded_data) > 0:
            cashflow_uploaded_data_position = cashflow_uploaded_data.loc[
                cashflow_uploaded_data["position_id"] == Position_Id
            ]
        else:
            cashflow_uploaded_data_position = pd.DataFrame()
        if len(cashflow_uploaded_data_position) > 0:
            cashflow_upload = True
            cashflow_uploaded_data_position["cashflow"] = (
                cashflow_uploaded_data_position["cashflow"] / Quantity
            )
            accrued_interest = cashflow_model_results.loc[
                cashflow_model_results["cashflow_type"] == "Accrued Interest", "cashflow"
            ]
            if len(accrued_interest) > 0:
                accrued_interest = np.array([accrued_interest.iloc[0]], dtype="float")
            else:
                accrued_interest = None
            cashflow_model_results = cashflow_model_results.loc[
                cashflow_model_results["cashflow_type"] != "Accrued Interest"
            ]
            cashflow_model_results = cashflow_uploaded_data_position.copy()
            cashflow_uploaded_data_position["coupons"] = np.where(
                cashflow_uploaded_data_position["cashflow_type"] == "Interest Proceeds",
                cashflow_uploaded_data_position["cashflow"],
                0,
            )
            cashflow_uploaded_data_position["principal"] = np.where(
                cashflow_uploaded_data_position["cashflow_type"] == "Redemption Proceeds",
                cashflow_uploaded_data_position["cashflow"],
                0,
            )
            coupon_array = cashflow_uploaded_data_position["coupons"].to_numpy()
            principal_amount_array = cashflow_uploaded_data_position["principal"].to_numpy()
            total_amount_array = cashflow_uploaded_data_position["cashflow"].to_numpy()
            cashflow_model_results[["cashflow_status", "discount_factor", "present_value"]] = [
                cashflow_status,
                "",
                "",
            ]
            del cashflow_uploaded_data_position
        else:
            cashflow_upload = False
            cashflow_results_output = valuation_models.fixed_coupon_cashflow_generation(
                Unique_Reference_Id,
                Issue_Date,
                Maturity_Date,
                Face_Value,
                Redemption_Amount,
                Coupon_Rate,
                Coupon_Frequency,
                Coupon_Frequency_unit,
                Valuation_Date,
                Discount_Daycount,
                Accrual_Daycount,
                Discount_Curve,
                Business_day_convention,
                Last_coupon_date,
                holiday_calendar,
                custom_daycount_conventions,
                accrued_interest,
                interest_calculation_methodology,
                compounding_frequency,
                compounding_frequency_unit,
                stub_date=stub_date,
                business_days=business_days,
                principal_business_day_convention = principal_business_day_convention
            )
            coupon_array = cashflow_results_output[4]
            principal_amount_array = cashflow_results_output[5]
            accrued_interest = cashflow_results_output[7]
            maturity_date =  cashflow_results_output[8]
            cashflow_model_results_interest = pd.DataFrame({
                "extract_date": Valuation_Date[0],
                "transaction_date": cashflow_results_output[2],
                "unique_reference_id": Unique_Reference_Id,
                "reference_dimension": reference_dimension,
                "cashflow_type": "Interest Proceeds",
                "cashflow_status": cashflow_status,
                "cashflow": cashflow_results_output[4],
                "time_to_maturity": cashflow_results_output[3],
                "discount_factor": None,
                "present_value": None,
                "currency": currency,
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": None,
                "entity": entity,
            })
            cashflow_model_results_principal = pd.DataFrame([{
                "extract_date": Valuation_Date[0],
                "transaction_date":  maturity_date,
                "unique_reference_id": Unique_Reference_Id,
                "reference_dimension": reference_dimension,
                "cashflow_type": "Redemption Proceeds",
                "cashflow_status": cashflow_status,
                "cashflow": principal_amount_array[0],
                "time_to_maturity": cashflow_results_output[9][0],
                "discount_factor": None,
                "present_value": None,
                "currency": currency,
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": None,
                "entity": entity,
            }])
            cashflow_model_results = pd.concat([cashflow_model_results_interest,cashflow_model_results_principal], ignore_index=True)

        measure_value = []
        PV_principal = []
        cashflow_model_results = cashflow_model_results.astype(
            {"time_to_maturity": "float64", "cashflow": "float64", "transaction_date": "datetime64[ns]"}
        )

        output_msg = output_check_fn(
            cashflow_results=cashflow_model_results[cashflow_model_results["time_to_maturity"] != 0]
        )

        if output_msg["CF_Output"] == "Present":
            if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
                TTM = cashflow_model_results["time_to_maturity"].to_numpy(dtype="float64")
                total_amount_array = cashflow_model_results['cashflow'].to_numpy(dtype="float64")
                if row[column_index_dict["model_code"]] != "M036":
                    zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == Discount_Curve), :]
                    tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                    rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                    zero_rates = np.empty([0], dtype="float64")
                    extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                    curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[
                        0
                    ]
                    for j in TTM:
                        if zero_rate_curve_points["interpolation_algorithm"].iloc[0] == "Linear":
                            inter_val = linearinterp(tenor, rates, j)
                            if inter_val is None:
                                if extrapolation_algorithm == "Linear":
                                    extrapolated_value = linearexterp(tenor, rates, j)
                                else:
                                    extrapolated_value = flatexterp(tenor, rates, j)
                                zero_rates = np.append(zero_rates, extrapolated_value)
                            else:
                                interpolated_value = inter_val
                                zero_rates = np.append(zero_rates, interpolated_value)
                    zero_rates = zero_rates.astype("float64")
                    zero_rate_curve_points = None
                    tenor = None
                    rates = None
                    del zero_rate_curve_points
                    del tenor
                    del rates

                if (
                    config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation"
                    and row[column_index_dict["model_code"]] != "M036"
                ):

                    (
                        PV_output,
                        PV_table,
                        TTM_array,
                        Total_amount_array,
                        DF,
                        PV_plus_1bps,
                        PV_minus_1bps,
                    ) = fixed_income_valuation_investments(
                        TTM,
                        total_amount_array,
                        zero_rates,
                        curve_compounding_frequency=curve_compounding_frequency,
                    )

                    if z_spread_calculation == "Yes":
                        market_data = mtm_data[
                            (mtm_data["security_identifier"] == Unique_Reference_Id)
                            & (mtm_data["extract_date"] == Valuation_Date[0])
                        ]

                        if len(market_data) > 0 and str(market_data["quoted_price"].iloc[0]) not in [
                            "nan",
                            "None",
                            "",
                        ]:

                            (
                                PV_output,
                                PV_table,
                                TTM_array,
                                Total_amount_array,
                                DF,
                                PV_plus_1bps,
                                PV_minus_1bps,
                            ) = z_spread_calculation_and_revaluation(
                                TTM,
                                total_amount_array,
                                zero_rates,
                                market_data,
                                accrued_interest[0],
                                curve_compounding_frequency=curve_compounding_frequency,
                                request=request,
                            )

                    cashflow_model_results["present_value"] = PV_table
                    cashflow_model_results["discount_factor"] = DF
                    output_msg = output_check_fn(valuation_output=PV_output)

                    if output_msg["Val_Output"] == "Present":
                        valuation_output = {
                            "PV": PV_output,
                        }
                        measure_dict_val = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value per unit",
                            "measure_value": round(PV_output, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_dict_val_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value",
                            "measure_value": round(PV_output * Quantity, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_val)
                        measure_value.append(measure_dict_val_position)
                        valuation_results.append(valuation_output)
                        total_holding = Quantity * valuation_results[0]["PV"]

                        if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":
                            (
                                PV01,
                                macaulay_duration,
                                modified_duration,
                                effective_duration,
                                ytm,
                            ) = valuation_models.fixed_income_sensitivity_analysis(
                                PV_table,
                                TTM_array,
                                Total_amount_array,
                                Coupon_Frequency,
                                Coupon_Frequency_unit,
                                PV_output,
                                PV_plus_1bps,
                                PV_minus_1bps,
                            )
                            sensitivity_analysis.append(
                                {
                                    "Macaulay Duration": macaulay_duration,
                                    "Effective Duration": effective_duration,
                                    "Modified Duration": modified_duration,
                                    "PV01 per unit": PV01,
                                }
                            )
                            if isinstance(ytm, (np.ndarray)):
                                ytm = ytm[0]
                            else:
                                ytm = ytm
                            measure_dict_ytm = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Yield to Maturity",
                                "measure_value": ytm,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_ytm)
                            measure_dict_mac_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Macaulay Duration",
                                "measure_value": macaulay_duration,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mac_dur)
                            measure_dict_eff_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Effective Duration",
                                "measure_value": effective_duration,
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_eff_dur)
                            measure_dict_mod_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Modified Duration",
                                "measure_value": modified_duration,
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mod_dur)
                            measure_dict_pv01 = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01 per unit",
                                "measure_value": PV01,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01)
                            measure_dict_pv01_position = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01",
                                "measure_value": PV01 * Quantity,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01_position)
                    else:
                        valuation_output = {
                            "PV": "None",
                        }
                        total_holding = "None"
                        valuation_results.append(valuation_output)

                elif (
                    config_dict["inputs"]["Valuation_Method"] == "mtm_valuation"
                    or row[column_index_dict["model_code"]] == "M036"
                ):
                    security_mtm_data = mtm_data[
                        (mtm_data["security_identifier"] == Unique_Reference_Id)
                        & (mtm_data["extract_date"] == Valuation_Date[0])
                    ]
                    if not cashflow_upload:
                        cashflow_model_results["cashflow_type"] = "Interest Proceeds"
                    output_msg = output_check_fn(price_df=security_mtm_data)
                    if (
                        output_msg["Val_df_Output"] == "Present"
                        and row[column_index_dict["model_code"]] != "M036"
                    ):
                        PV = security_mtm_data["quoted_price"].iloc[0]
                        total_holding = Quantity * PV
                        valuation_output = {
                            "PV": PV,
                        }
                        measure_dict_val = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value per unit",
                            "measure_value": round(PV, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_dict_val_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value",
                            "measure_value": round(PV * Quantity, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_val)
                        measure_value.append(measure_dict_val_position)
                        valuation_results.append(valuation_output)
                    elif (
                        output_msg["YTM_Output"] == "Present" and output_msg["Val_df_Output"] != "Present"
                    ) or (
                        output_msg["YTM_Output"] == "Present"
                        and row[column_index_dict["model_code"]] == "M036"
                    ):
                        ytm = np.array([security_mtm_data["yield"].iloc[0]])
                        (
                            PV,
                            PV_table,
                            TTM_array,
                            Total_amount_array,
                            DF,
                            PV_coupons,
                            PV_principal,
                        ) = valuation_models.fixed_income_mtm_valuation(
                            TTM,
                            total_amount_array.astype("float64"),
                            coupon_array.astype("float64"),
                            principal_amount_array.astype("float64"),
                            ytm,
                            ytm_frequency=ytm_frequency,
                        )
                        valuation_output = {
                            "PV": PV,
                        }
                        total_holding = int(Quantity) * PV
                        valuation_results.append(valuation_output)
                        measure_dict_val = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value per unit",
                            "measure_value": round(PV, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_dict_val_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value",
                            "measure_value": round(PV * Quantity, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_val)
                        measure_value.append(measure_dict_val_position)
                        cashflow_model_results["discount_factor"] = DF
                        if not cashflow_upload:
                            cashflow_model_results["present_value"] = PV_coupons
                        else:
                            cashflow_model_results["present_value"] = PV_table
                    else:
                        valuation_output = {
                            "PV": "None",
                        }
                        total_holding = "None"
                        valuation_results.append(valuation_output)
                    if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":
                        modified_duration = security_mtm_data["modified_duration"].iloc[0]
                        ytm = np.array([security_mtm_data["yield"].iloc[0]])
                        PV_input = np.array([PV])
                        (
                            PV01,
                            macaulay_duration,
                            modified_duration,
                            effective_duration,
                            ytm,
                        ) = valuation_models.fixed_income_mtm_sensitivity_analysis(
                            modified_duration,
                            ytm,
                            TTM,
                            total_amount_array.astype("float64"),
                            Coupon_Frequency,
                            Coupon_Frequency_unit,
                            PV_input,
                            ytm_frequency=ytm_frequency,
                        )

                        sensitivity_analysis.append(
                            {
                                "Macaulay_Duration": macaulay_duration[0],
                                "Effective Duration": effective_duration[0],
                                "Modified_Duration": modified_duration,
                                "PV01 per unit": PV01,
                            }
                        )
                        if isinstance(ytm, (np.ndarray)):
                            ytm = ytm[0]
                        else:
                            ytm = ytm
                        measure_dict_ytm = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Yield to Maturity",
                            "measure_value": ytm,
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_ytm)
                        measure_dict_mac_dur = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Macaulay Duration",
                            "measure_value": macaulay_duration[0],
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_mac_dur)
                        measure_dict_eff_dur = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Effective Duration",
                            "measure_value": effective_duration[0],
                            "absolute_relative": "Relative",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_eff_dur)
                        measure_dict_mod_dur = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Modified Duration",
                            "measure_value": modified_duration,
                            "absolute_relative": "Relative",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_mod_dur)
                        measure_dict_pv01 = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "PV01 per unit",
                            "measure_value": PV01,
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_pv01)
                        measure_dict_pv01_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "PV01",
                            "measure_value": PV01 * Quantity,
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_pv01_position)

            else:
                sensitivity_analysis.append(
                    {
                        "Macaulay_Duration": "-",
                        "Effective Duration": "-",
                        "Modified_Duration": "-",
                        "PV01 per unit": "-",
                    }
                )
                valuation_output = {
                    "PV": "None",
                }
                total_holding = "None"
                valuation_results.append(valuation_output)

        else:
            sensitivity_analysis.append(
                {
                    "Macaulay_Duration": "-",
                    "Effective Duration": "-",
                    "Modified_Duration": "-",
                    "PV01 per unit": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)
      
        cashflow_model_results = cashflow_model_results[cashflow_model_results["time_to_maturity"] != 0]
        if str(accrued_interest[0]) not in ["", "0.0", "None", "nan"]:
            cashflow_model_results = pd.concat(
                [cashflow_model_results, cashflow_model_results.iloc[[-1]]], ignore_index=True
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow")] = (
                accrued_interest[0]
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow_type")] = (
                "Accrued Interest"
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("transaction_date")] = (
                pd.to_datetime(Valuation_Date[0])
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("present_value")] = 0
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("time_to_maturity")] = (
                cashflow_model_results["time_to_maturity"].iloc[0]
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("discount_factor")] = 0
            cashflow_model_results = cashflow_model_results.sort_values(
                by=["transaction_date", "cashflow_type"], ascending=True
            )
        cashflow_model_results["cashflow"] = cashflow_model_results["cashflow"] * Quantity
        cashflow_model_results["present_value"] = present_value_check_function(
            cashflow_model_results["present_value"], Quantity
        )
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = Unique_Reference_Id
        final_output_dict["Position_Id"] = Position_Id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = Valuation_Date[0]
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Quantity"] = Quantity
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Quantity"] = Quantity
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        measure_value = pd.DataFrame(measure_value)
        measure_value["currency"] = currency
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] == "M003":

        final_output_dict = {}
        Issue_Date = pd.to_datetime(row[column_index_dict["issue_date"]], dayfirst=True)
        Maturity_Date = np.array([pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True)])
        Face_Value = np.array([row[column_index_dict["face_value"]]], dtype="float64")
        Redemption_Amount = np.array([row[column_index_dict["redemption_amount"]]], dtype="float64")

        Spread_Over_Benchmark = row[column_index_dict["fixed_spread"]]
        Coupon_Frequency = row[column_index_dict["payment_frequency"]]
        Coupon_Frequency_unit = row[column_index_dict["payment_frequency_units"]]
        current_benchmark_rate = row[column_index_dict["current_benchmark_rate"]]
        Discount_Daycount = np.array([row[column_index_dict["discount_daycount_convention"]]])
        Accrual_Daycount = np.array([row[column_index_dict["accrual_daycount_convention"]]])
        Discount_Curve = np.array([row[column_index_dict["discounting_curve"]]])
        Business_day_convention = np.array([row[column_index_dict["business_convention"]]])
        Last_coupon_date = row[column_index_dict["last_payment_date"]]
        if str(Last_coupon_date) not in ["nan", "NaT", "None", "-"]:
            Last_coupon_date = np.datetime64(row[column_index_dict["last_payment_date"]], "D")
        stub_date = row[column_index_dict["stub_date"]]
        if str(stub_date) not in ["nan", "NaT", "None", "-"]:
            stub_date = np.datetime64(row[column_index_dict["stub_date"]], "D")
        Coupon_Benchmark_Curve = row[column_index_dict["forward_benchmark_curve"]]
        Next_Repricing_Date = pd.to_datetime(row[column_index_dict["last_payment_date"]], dayfirst=True)
        Last_Repricing_Date = pd.to_datetime(row[column_index_dict["last_reset_date"]], dayfirst=True)
        Repricing_Frequency = row[column_index_dict["reset_frequency"]]
        Repricing_Frequency_unit = row[column_index_dict["reset_frequency_unit"]]
        accrued_interest = row[column_index_dict["accrued_interest"]]
        if str(accrued_interest) not in ["nan", "None", ""]:
            accrued_interest = np.array([float(accrued_interest / Quantity)], dtype="float")
        valuation_results = []
        sensitivity_analysis = []
        PV_principal = []
        measure_value = []
        if cashflow_uploaded_data is not None and len(cashflow_uploaded_data) > 0:
            cashflow_uploaded_data_position = cashflow_uploaded_data.loc[
                cashflow_uploaded_data["position_id"] == Position_Id
            ]
        else:
            cashflow_uploaded_data_position = pd.DataFrame()
        if len(cashflow_uploaded_data_position) > 0:
            cashflow_upload = True
            cashflow_uploaded_data_position["cashflow"] = (
                cashflow_uploaded_data_position["cashflow"] / Quantity
            )
            accrued_interest = cashflow_model_results.loc[
                cashflow_model_results["cashflow_type"] == "Accrued Interest", "cashflow"
            ]
            if len(accrued_interest) > 0:
                accrued_interest = np.array([accrued_interest.iloc[0]], dtype="float")
            else:
                accrued_interest = None
            cashflow_model_results = cashflow_model_results.loc[
                cashflow_model_results["cashflow_type"] != "Accrued Interest"
            ]
            cashflow_model_results = cashflow_uploaded_data_position.copy()
            cashflow_uploaded_data_position["coupons"] = np.where(
                cashflow_uploaded_data_position["cashflow_type"] == "Interest Proceeds",
                cashflow_uploaded_data_position["cashflow"],
                0,
            )
            cashflow_uploaded_data_position["principal"] = np.where(
                cashflow_uploaded_data_position["cashflow_type"] == "Redemption Proceeds",
                cashflow_uploaded_data_position["cashflow"],
                0,
            )
            coupon_array = cashflow_uploaded_data_position["coupons"].to_numpy()
            principal_amount_array = cashflow_uploaded_data_position["principal"].to_numpy()
            total_amount_array = cashflow_uploaded_data_position["cashflow"].to_numpy()
            cashflow_model_results[["cashflow_status", "discount_factor", "present_value"]] = [
                cashflow_status,
                "",
                "",
            ]
            del cashflow_uploaded_data_position
        else:
            cashflow_upload = False
            cashflow_results_output = valuation_models.floating_coupon_cashflow_generation(
                Unique_Reference_Id,
                Issue_Date,
                Maturity_Date,
                Face_Value,
                Redemption_Amount,
                Spread_Over_Benchmark,
                Coupon_Frequency,
                Coupon_Frequency_unit,
                Valuation_Date,
                Discount_Daycount,
                Accrual_Daycount,
                Discount_Curve,
                Business_day_convention,
                Last_coupon_date,
                Coupon_Benchmark_Curve,
                Next_Repricing_Date,
                Last_Repricing_Date,
                curve_data,
                Repricing_Frequency,
                Repricing_Frequency_unit,
                holiday_calendar,
                current_benchmark_rate,
                custom_daycount_conventions,
                accrued_interest,
                stub_date=stub_date,
                business_days=business_days,
            )
            coupon_array = cashflow_results_output[4]
            total_amount_array = cashflow_results_output[6]
            principal_amount_array = cashflow_results_output[5]
            accrued_interest = cashflow_results_output[7]
            cashflow_model_results = {
                "extract_date": Valuation_Date[0],
                "transaction_date": cashflow_results_output[2],
                "unique_reference_id": Unique_Reference_Id,
                "reference_dimension": reference_dimension,
                "cashflow_type": "",
                "cashflow_status": cashflow_status,
                "cashflow": cashflow_results_output[4],
                "time_to_maturity": cashflow_results_output[3],
                "discount_factor": None,
                "present_value": None,
                "currency": currency,
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": "",
                "entity": entity,
            }
            cashflow_model_results = pd.DataFrame(cashflow_model_results)
            cashflow_model_results["cashflow_type"] = "Interest Proceeds"

        cashflow_model_results = cashflow_model_results.astype(
            {"time_to_maturity": "float64", "cashflow": "float64", "transaction_date": "datetime64[ns]"}
        )

        output_msg = output_check_fn(
            cashflow_results=cashflow_model_results[cashflow_model_results["time_to_maturity"] != 0]
        )

        if output_msg["CF_Output"] == "Present":

            if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
                TTM = (cashflow_model_results["time_to_maturity"].to_numpy()).astype("float64")

                if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                    zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == Discount_Curve), :]
                    tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                    rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                    zero_rates = np.empty([0], dtype="float64")
                    extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                    curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[
                        0
                    ]
                    for j in TTM:
                        if zero_rate_curve_points["interpolation_algorithm"].iloc[0] == "Linear":
                            inter_val = linearinterp(tenor, rates, j)
                            if inter_val is None:
                                if extrapolation_algorithm == "Linear":
                                    extrapolated_value = linearexterp(tenor, rates, j)
                                else:
                                    extrapolated_value = flatexterp(tenor, rates, j)
                                zero_rates = np.append(zero_rates, extrapolated_value)
                            else:
                                interpolated_value = inter_val
                                zero_rates = np.append(zero_rates, interpolated_value)
                    (
                        PV_output,
                        PV_table,
                        TTM_array,
                        Total_amount_array,
                        DF,
                        PV_coupons,
                        PV_principal,
                        PV_plus_1bps,
                        PV_minus_1bps,
                    ) = fixed_income_valuation(
                        TTM,
                        total_amount_array.astype("float64"),
                        zero_rates,
                        coupon_array.astype("float64"),
                        principal_amount_array.astype("float64"),
                        curve_compounding_frequency=curve_compounding_frequency,
                    )
                    cashflow_model_results["discount_factor"] = DF
                    if not cashflow_upload:
                        cashflow_model_results["present_value"] = PV_coupons
                    else:
                        cashflow_model_results["present_value"] = PV_table
                    output_msg = output_check_fn(valuation_output=PV_output)

                    if output_msg["Val_Output"] == "Present":
                        valuation_output = {
                            "PV": round(PV_output, 4),
                        }
                        measure_dict_val = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value per unit",
                            "measure_value": round(PV_output, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_dict_val_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value",
                            "measure_value": round(PV_output * Quantity[0], 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_val)
                        measure_value.append(measure_dict_val_position)
                        valuation_results.append(valuation_output)
                        total_holding = Quantity * valuation_results[0]["PV"]

                        if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":
                            if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                                (
                                    PV01,
                                    macaulay_duration,
                                    modified_duration,
                                    effective_duration,
                                    ytm,
                                ) = valuation_models.fixed_income_sensitivity_analysis(
                                    PV_table,
                                    TTM_array,
                                    Total_amount_array,
                                    Coupon_Frequency,
                                    Coupon_Frequency_unit,
                                    PV_output,
                                    PV_plus_1bps,
                                    PV_minus_1bps,
                                )
                                sensitivity_analysis.append(
                                    {
                                        "Macaulay Duration": macaulay_duration,
                                        "Effective Duration": effective_duration,
                                        "Modified Duration": modified_duration,
                                        "PV01 per unit": PV01,
                                    }
                                )
                                if isinstance(ytm, (np.ndarray)):
                                    ytm = ytm[0]
                                else:
                                    ytm = ytm
                                measure_dict_ytm = {
                                    "measure_run_date": datetime.now(),
                                    "valuation_date": Valuation_Date[0],
                                    "unique_reference_id": Unique_Reference_Id,
                                    "position_id": Position_Id,
                                    "reference_dimension": reference_dimension,
                                    "measure_type": "Yield to Maturity",
                                    "measure_value": ytm,
                                    "absolute_relative": "Absolute",
                                    "residual_maturity": TTM_array[-1],
                                    "asset_liability_type": asset_liability_type,
                                    "product_variant_name": product_variant_name,
                                    "fund": fund,
                                    "portfolio": portfolio,
                                    "cohort": "",
                                    "entity": entity,
                                }
                                measure_value.append(measure_dict_ytm)
                                measure_dict_mac_dur = {
                                    "measure_run_date": datetime.now(),
                                    "valuation_date": Valuation_Date[0],
                                    "unique_reference_id": Unique_Reference_Id,
                                    "position_id": Position_Id,
                                    "reference_dimension": reference_dimension,
                                    "measure_type": "Macaulay Duration",
                                    "measure_value": macaulay_duration,
                                    "absolute_relative": "Absolute",
                                    "residual_maturity": TTM_array[-1],
                                    "asset_liability_type": asset_liability_type,
                                    "product_variant_name": product_variant_name,
                                    "fund": fund,
                                    "portfolio": portfolio,
                                    "cohort": "",
                                    "entity": entity,
                                }
                                measure_value.append(measure_dict_mac_dur)
                                measure_dict_eff_dur = {
                                    "measure_run_date": datetime.now(),
                                    "valuation_date": Valuation_Date[0],
                                    "unique_reference_id": Unique_Reference_Id,
                                    "position_id": Position_Id,
                                    "reference_dimension": reference_dimension,
                                    "measure_type": "Effective Duration",
                                    "measure_value": effective_duration,
                                    "absolute_relative": "Relative",
                                    "residual_maturity": TTM_array[-1],
                                    "asset_liability_type": asset_liability_type,
                                    "product_variant_name": product_variant_name,
                                    "fund": fund,
                                    "portfolio": portfolio,
                                    "cohort": "",
                                    "entity": entity,
                                }
                                measure_value.append(measure_dict_eff_dur)
                                measure_dict_mod_dur = {
                                    "measure_run_date": datetime.now(),
                                    "valuation_date": Valuation_Date[0],
                                    "unique_reference_id": Unique_Reference_Id,
                                    "position_id": Position_Id,
                                    "reference_dimension": reference_dimension,
                                    "measure_type": "Modified Duration",
                                    "measure_value": modified_duration,
                                    "absolute_relative": "Relative",
                                    "residual_maturity": TTM_array[-1],
                                    "asset_liability_type": asset_liability_type,
                                    "product_variant_name": product_variant_name,
                                    "fund": fund,
                                    "portfolio": portfolio,
                                    "cohort": "",
                                    "entity": entity,
                                }
                                measure_value.append(measure_dict_mod_dur)
                                measure_dict_pv01 = {
                                    "measure_run_date": datetime.now(),
                                    "valuation_date": Valuation_Date[0],
                                    "unique_reference_id": Unique_Reference_Id,
                                    "position_id": Position_Id,
                                    "reference_dimension": reference_dimension,
                                    "measure_type": "PV01 per unit",
                                    "measure_value": PV01,
                                    "absolute_relative": "Absolute",
                                    "residual_maturity": TTM_array[-1],
                                    "asset_liability_type": asset_liability_type,
                                    "product_variant_name": product_variant_name,
                                    "fund": fund,
                                    "portfolio": portfolio,
                                    "cohort": "",
                                    "entity": entity,
                                }
                                measure_value.append(measure_dict_pv01)
                                measure_dict_pv01_position = {
                                    "measure_run_date": datetime.now(),
                                    "valuation_date": Valuation_Date[0],
                                    "unique_reference_id": Unique_Reference_Id,
                                    "position_id": Position_Id,
                                    "reference_dimension": reference_dimension,
                                    "measure_type": "PV01",
                                    "measure_value": PV01 * Quantity[0],
                                    "absolute_relative": "Absolute",
                                    "residual_maturity": TTM_array[-1],
                                    "asset_liability_type": asset_liability_type,
                                    "product_variant_name": product_variant_name,
                                    "fund": fund,
                                    "portfolio": portfolio,
                                    "cohort": "",
                                    "entity": entity,
                                }
                                measure_value.append(measure_dict_pv01_position)

                    else:
                        valuation_output = {
                            "PV": "None",
                        }
                        total_holding = "None"
                        valuation_results.append(valuation_output)

                elif config_dict["inputs"]["Valuation_Method"] == "mtm_valuation":
                    security_mtm_data = mtm_data[
                        (mtm_data["security_identifier"] == Unique_Reference_Id)
                        & (mtm_data["extract_date"] == Valuation_Date[0])
                    ]

                    output_msg = output_check_fn(price_df=security_mtm_data)
                    if output_msg["Val_df_Output"] == "Present":
                        PV = security_mtm_data["quoted_price"].iloc[0]
                        total_holding = Quantity * PV
                        valuation_output = {
                            "PV": round(PV, 4),
                        }
                        measure_dict_val = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value per unit",
                            "measure_value": round(PV, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_dict_val_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value",
                            "measure_value": round(PV * Quantity, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_val)
                        measure_value.append(measure_dict_val_position)
                        valuation_results.append(valuation_output)

                    elif output_msg["YTM_Output"] == "Present" and output_msg["Val_df_Output"] != "Present":
                        ytm = np.array([security_mtm_data["yield"].iloc[0]])
                        (
                            PV,
                            PV_table,
                            TTM_array,
                            Total_amount_array,
                            DF,
                            PV_coupons,
                            PV_principal,
                        ) = valuation_models.fixed_income_mtm_valuation(
                            TTM,
                            total_amount_array.astype("float64"),
                            coupon_array.astype("float64"),
                            principal_amount_array.astype("float64"),
                            ytm,
                        )
                        valuation_output = {
                            "PV": round(PV, 4),
                        }
                        total_holding = Quantity * PV
                        valuation_results.append(valuation_output)
                        measure_dict_val = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value per unit",
                            "measure_value": round(PV, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_dict_val_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value",
                            "measure_value": round(PV * Quantity, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_val)
                        measure_value.append(measure_dict_val_position)
                        cashflow_model_results["discount_factor"] = DF
                        if not cashflow_upload:
                            cashflow_model_results["present_value"] = PV_coupons
                        else:
                            cashflow_model_results["present_value"] = PV_table
                    else:
                        valuation_output = {
                            "PV": "None",
                        }
                        total_holding = "None"
                        valuation_results.append(valuation_output)
                    if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":
                        if output_msg["Sensitivity_output"] == "Present":
                            modified_duration = security_mtm_data["modified_duration"].iloc[0]
                            ytm = np.array([security_mtm_data["yield"].iloc[0]])
                            PV_input = np.array([PV])
                            (
                                PV01,
                                macaulay_duration,
                                modified_duration,
                                effective_duration,
                                ytm,
                            ) = valuation_models.fixed_income_mtm_sensitivity_analysis(
                                modified_duration,
                                ytm,
                                TTM,
                                total_amount_array.astype("float64"),
                                Coupon_Frequency,
                                Coupon_Frequency_unit,
                                PV_input,
                            )
                            sensitivity_analysis.append(
                                {
                                    "Macaulay_Duration": macaulay_duration[0],
                                    "Effective Duration": effective_duration[0],
                                    "Modified_Duration": modified_duration,
                                    "PV01 per unit": PV01,
                                }
                            )
                            if isinstance(ytm, (np.ndarray)):
                                ytm = ytm[0]
                            else:
                                ytm = ytm
                            measure_dict_ytm = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Yield to Maturity",
                                "measure_value": ytm,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM[len(TTM) - 1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_ytm)
                            measure_dict_mac_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Macaulay Duration",
                                "measure_value": macaulay_duration[0],
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM[len(TTM) - 1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mac_dur)
                            measure_dict_eff_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Effective Duration",
                                "measure_value": effective_duration[0],
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM[len(TTM) - 1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_eff_dur)
                            measure_dict_mod_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Modified Duration",
                                "measure_value": modified_duration,
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM[len(TTM) - 1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mod_dur)
                            measure_dict_pv01 = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01 per unit",
                                "measure_value": PV01,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM[len(TTM) - 1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01)
                            measure_dict_pv01_position = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01",
                                "measure_value": PV01 * Quantity,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM[len(TTM) - 1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01_position)

                        else:
                            sensitivity_analysis.append(
                                {
                                    "Macaulay_Duration": "-",
                                    "Effective Duration": "-",
                                    "Modified_Duration": "-",
                                    "PV01 per unit": "-",
                                }
                            )

            else:
                sensitivity_analysis.append(
                    {
                        "Macaulay_Duration": "-",
                        "Effective Duration": "-",
                        "Modified_Duration": "-",
                        "PV01 per unit": "-",
                    }
                )
                valuation_output = {
                    "PV": "None",
                }
                total_holding = "None"
                valuation_results.append(valuation_output)

        else:
            sensitivity_analysis.append(
                {
                    "Macaulay_Duration": "-",
                    "Effective Duration": "-",
                    "Modified_Duration": "-",
                    "PV01 per unit": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        cashflow_model_results["extract_date"] = cashflow_model_results["extract_date"].astype(str)
        cashflow_model_results["transaction_date"] = cashflow_model_results["transaction_date"].astype(str)
        if not cashflow_upload:
            cashflow_model_results = pd.concat(
                [cashflow_model_results, cashflow_model_results.iloc[[-1]]], ignore_index=True
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow")] = (
                Redemption_Amount
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow_type")] = (
                "Redemption Proceeds"
            )
            if len(PV_principal) > 0:
                cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("present_value")] = (
                    PV_principal[len(PV_principal) - 1]
                )
        cashflow_model_results = cashflow_model_results[cashflow_model_results["time_to_maturity"] != 0]
        if str(accrued_interest[0]) not in ["", "0.0", "None", "nan"]:
            cashflow_model_results = pd.concat(
                [cashflow_model_results, cashflow_model_results.iloc[[-1]]], ignore_index=True
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow")] = (
                accrued_interest[0]
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow_type")] = (
                "Accrued Interest"
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("transaction_date")] = (
                pd.to_datetime(Valuation_Date[0])
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("present_value")] = None
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("time_to_maturity")] = (
                cashflow_model_results["time_to_maturity"].iloc[0]
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("discount_factor")] = None
            cashflow_model_results = cashflow_model_results.sort_values(
                by=["transaction_date", "cashflow_type"], ascending=True
            )
        cashflow_model_results["cashflow"] = cashflow_model_results["cashflow"] * Quantity
        cashflow_model_results["present_value"] = present_value_check_function(
            cashflow_model_results["present_value"], Quantity
        )
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = Unique_Reference_Id
        final_output_dict["Position_Id"] = Position_Id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = pd.to_datetime(Valuation_Date[0]).strftime("%Y-%m-%d")
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Quantity"] = Quantity[0]
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        measure_value = pd.DataFrame(measure_value)
        measure_value["currency"] = currency
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] in ["M005", "M030", "M031", "M033", "M034"]:
        final_output_dict = {}
        Issue_Date = pd.to_datetime(row[column_index_dict["issue_date"]], dayfirst=True)
        Maturity_Date = np.array(np.datetime64(row[column_index_dict["maturity_date"]], "D"))
        Redemption_Amount = row[column_index_dict["redemption_amount"]]
        if str(Redemption_Amount) not in ["nan", "None", ""]:
            Redemption_Amount = np.array([float(Redemption_Amount)])
        else:
            Redemption_Amount = np.array([float(row[column_index_dict["outstanding_amount"]])])

        Discount_Daycount = np.array([row[column_index_dict["discount_daycount_convention"]]])
        Accrual_Daycount = np.array([row[column_index_dict["accrual_daycount_convention"]]])
        Discount_Curve = row[column_index_dict["discounting_curve"]]
        Business_day_convention = np.array([row[column_index_dict["business_convention"]]])
        credit_spread_rate = row[column_index_dict["credit_spread_rate"]]
        Credit_Spread_Curve = row[column_index_dict["credit_spread_curve"]]
        discount_convention_code = valuation_models.daycount_convention_code(Discount_Daycount)
        convention_code = valuation_models.busday_convention_code(Business_day_convention)
        cashflow_date = conventions.business_day(
            Maturity_Date, convention_code, holiday_calendar, business_days=business_days
        )
        Maturity_Date = np.array(
            [
                business_day_val(
                    pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True).date(),
                    convention_code,
                    [],
                )
            ],
            dtype="datetime64[D]",
        )
        TTM_array = conventions.D_day_count(
            Valuation_Date,
            Maturity_Date,
            discount_convention_code,
            custom_daycount_conventions=custom_daycount_conventions,
        )
        time_period_till_maturity = conventions.D_day_count(
            np.array(Issue_Date, dtype="datetime64[D]"),
            Maturity_Date,
            discount_convention_code,
            custom_daycount_conventions=custom_daycount_conventions,
        )
        time_period_till_valuation = conventions.D_day_count(
            np.array(Issue_Date, dtype="datetime64[D]"),
            np.array(Valuation_Date, dtype="datetime64[D]"),
            discount_convention_code,
            custom_daycount_conventions=custom_daycount_conventions,
        )
        accrued_interest = row[column_index_dict["accrued_interest"]]
        if str(accrued_interest) not in ["nan", "None", ""]:
            accrued_interest = np.array([float(accrued_interest / Quantity)], dtype="float")
        valuation_results = []
        sensitivity_analysis = []
        measure_value = []

        if row[column_index_dict["model_code"]] == "M030":
            redemption_premium = float(row[column_index_dict["redemption_premium"]]) / Quantity
            if str(accrued_interest) in ["nan", "None", ""]:
                accrued_interest = (
                    redemption_premium / time_period_till_maturity
                ) * time_period_till_valuation
            consideration_amount = None
        elif row[column_index_dict["model_code"]] == "M031":
            consideration_amount = np.array(
                [float(row[column_index_dict["consideration_amount"]]) / Quantity]
            )
            interest_amount = Redemption_Amount[0] - consideration_amount[0]
            if str(accrued_interest) in ["nan", "None", ""]:
                accrued_interest = (interest_amount / time_period_till_maturity) * time_period_till_valuation
            Redemption_Amount = consideration_amount
            redemption_premium = None
        elif row[column_index_dict["model_code"]] == "M033":
            consideration_amount = np.array(
                [float(row[column_index_dict["consideration_amount"]]) / Quantity]
            )
            redemption_premium = float(row[column_index_dict["redemption_premium"]]) / Quantity
            if str(accrued_interest) in ["nan", "None", ""]:
                accrued_interest = (
                    redemption_premium / time_period_till_maturity
                ) * time_period_till_valuation
            reissuance_price = float(row[column_index_dict["reissuance_price"]])
            Redemption_Amount = consideration_amount[0] * reissuance_price / 100
            Redemption_Amount = np.array([float(Redemption_Amount)])
        elif row[column_index_dict["model_code"]] == "M034":
            base_rate = float(row[column_index_dict["base_rate"]]) / 100
            if str(row[column_index_dict["fixed_spread"]]) not in ["", "nan", "None"]:
                fixed_spread = float(row[column_index_dict["fixed_spread"]]) / 100
            else:
                fixed_spread = 0
            interest_rate = base_rate + fixed_spread
            compounding_frequency = row[column_index_dict["compounding_frequency"]]
            compounding_frequency_unit = row[column_index_dict["compounding_frequency_unit"]]
            compound_interest_calculation_methodology = row[
                column_index_dict["compound_interest_calculation_methodology"]
            ]
            if compound_interest_calculation_methodology == "Formula":
                interest_amount = compound_interest_calculation_formula(
                    compounding_frequency,
                    compounding_frequency_unit,
                    time_period_till_maturity,
                    Redemption_Amount,
                    interest_rate,
                )
                accrued_interest = compound_interest_calculation_formula(
                    compounding_frequency,
                    compounding_frequency_unit,
                    time_period_till_valuation,
                    Redemption_Amount,
                    interest_rate,
                )
            else:
                compound_interest_schedule = compound_interest_schedule_generation(
                    compounding_frequency,
                    compounding_frequency_unit,
                    pd.to_datetime(row[column_index_dict["issue_date"]], dayfirst=True),
                    pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True),
                    "",
                    "",
                    "",
                    Redemption_Amount,
                    interest_rate,
                    discount_convention_code,
                    custom_daycount_conventions=custom_daycount_conventions,
                )
                interest_amount = compound_interest_schedule["interest"].iloc[-1]
                accrued_interest_subset = compound_interest_schedule.loc[
                    compound_interest_schedule["date"]
                    == compound_interest_schedule.loc[
                        compound_interest_schedule["date"] <= Valuation_Date[0], "date"
                    ].max()
                ]
                if len(accrued_interest_subset) == 0:
                    # No interest compounding before the valuation date
                    accrued_interest = Redemption_Amount * interest_rate * time_period_till_valuation
                else:
                    if accrued_interest_subset["date"].iloc[0] != Valuation_Date[0]:
                        # Accrued cumulative compound interest from the issue date to the valuation date when the last compounding date is not equal to the valuation date
                        accrued_interest = accrued_interest_subset["interest"].iloc[
                            0
                        ] + accrued_interest_subset["outstanding_balance_after_payout"].iloc[
                            0
                        ] * interest_rate * conventions.D_day_count(
                            np.array(accrued_interest_subset["date"].iloc[0], dtype="datetime64[D]"),
                            np.array(Valuation_Date, dtype="datetime64[D]"),
                            discount_convention_code,
                            custom_daycount_conventions=custom_daycount_conventions,
                        )
                    else:
                        # Accrued cumulative compound interest from the issue date to the valuation date when the last compounding date is equal to the valuation date
                        accrued_interest = accrued_interest_subset["interest"].iloc[0]
        else:
            redemption_premium = None
            consideration_amount = None
            accrued_interest = None

        if cashflow_uploaded_data is not None and len(cashflow_uploaded_data) > 0:
            cashflow_uploaded_data_position = cashflow_uploaded_data.loc[
                cashflow_uploaded_data["position_id"] == Position_Id
            ]
        else:
            cashflow_uploaded_data_position = pd.DataFrame()
        if len(cashflow_uploaded_data_position) > 0:
            cashflow_upload = True
            cashflow_uploaded_data_position["cashflow"] = (
                cashflow_uploaded_data_position["cashflow"] / Quantity
            )
            accrued_interest = cashflow_model_results.loc[
                cashflow_model_results["cashflow_type"] == "Accrued Interest", "cashflow"
            ]
            if len(accrued_interest) > 0:
                accrued_interest = np.array([accrued_interest.iloc[0]], dtype="float")
            else:
                accrued_interest = None
            cashflow_model_results = cashflow_model_results.loc[
                cashflow_model_results["cashflow_type"] != "Accrued Interest"
            ]
            cashflow_model_results = cashflow_uploaded_data_position
            cashflow_model_results[["cashflow_status", "discount_factor", "present_value"]] = [
                cashflow_status,
                "",
                "",
            ]
            del cashflow_uploaded_data_position
        else:
            cashflow_upload = False
            cashflow_model_results = []
            if row[column_index_dict["model_code"]] in ["M030", "M033"]:
                interest_cashflow = {
                    "extract_date": Valuation_Date[0],
                    "transaction_date": cashflow_date,
                    "unique_reference_id": Unique_Reference_Id,
                    "reference_dimension": reference_dimension,
                    "cashflow_type": "Interest Proceeds",
                    "cashflow_status": cashflow_status,
                    "cashflow": redemption_premium,
                    "time_to_maturity": TTM_array[0],
                    "discount_factor": None,
                    "present_value": None,
                    "currency": currency,
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }
                cashflow_model_results.append(interest_cashflow)
            elif row[column_index_dict["model_code"]] in ["M031", "M034"]:
                interest_cashflow = {
                    "extract_date": Valuation_Date[0],
                    "transaction_date": cashflow_date,
                    "unique_reference_id": Unique_Reference_Id,
                    "reference_dimension": reference_dimension,
                    "cashflow_type": "Interest Proceeds",
                    "cashflow_status": cashflow_status,
                    "cashflow": interest_amount,
                    "time_to_maturity": TTM_array[0],
                    "discount_factor": None,
                    "present_value": None,
                    "currency": currency,
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }
                cashflow_model_results.append(interest_cashflow)

            principal_cashflow = {
                "extract_date": Valuation_Date[0],
                "transaction_date": cashflow_date,
                "unique_reference_id": Unique_Reference_Id,
                "reference_dimension": reference_dimension,
                "cashflow_type": "Redemption Proceeds",
                "cashflow_status": cashflow_status,
                "cashflow": Redemption_Amount[0],
                "time_to_maturity": TTM_array[0],
                "discount_factor": None,
                "present_value": None,
                "currency": currency,
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": "",
                "entity": entity,
            }
            cashflow_model_results.append(principal_cashflow)
            cashflow_model_results = pd.DataFrame(cashflow_model_results)

        cashflow_model_results = cashflow_model_results.astype(
            {"time_to_maturity": "float64", "cashflow": "float64", "transaction_date": "datetime64[ns]"}
        )
        output_msg = output_check_fn(
            cashflow_results=cashflow_model_results[cashflow_model_results["time_to_maturity"] != 0]
        )
        TTM_array = cashflow_model_results["time_to_maturity"].to_numpy(dtype="float64")
        cashflows = cashflow_model_results["cashflow"].to_numpy(dtype="float64")
        if output_msg["CF_Output"] == "Present":
            if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
                if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                    zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == Discount_Curve), :]
                    tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                    rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                    zero_rates = np.empty([0], dtype="float64")
                    extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                    curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[
                        0
                    ]
                    for j in TTM_array:
                        if zero_rate_curve_points["interpolation_algorithm"].iloc[0] == "Linear":
                            interp_val = linearinterp(tenor, rates, j)
                            if interp_val is None:
                                if extrapolation_algorithm == "Linear":
                                    extrapolated_value = linearexterp(tenor, rates, j)
                                else:
                                    extrapolated_value = flatexterp(tenor, rates, j)
                                zero_rates = np.append(zero_rates, extrapolated_value)
                            else:
                                interpolated_value = interp_val
                                zero_rates = np.append(zero_rates, interpolated_value)
                    tenor = None
                    rates = None
                    del tenor
                    del rates
                    del zero_rate_curve_points
                    if str(credit_spread_rate) not in ["nan", "None"]:
                        all_in_rate = zero_rates + float(credit_spread_rate)
                    elif str(Credit_Spread_Curve) not in ["nan", "None"]:
                        credit_spread_curve_data = credit_spread_data.loc[
                            (credit_spread_data["credit_spread_curve_name"] == Credit_Spread_Curve), :
                        ]

                        if len(credit_spread_curve_data) > 0:
                            spread_tenor = np.array(credit_spread_curve_data.tenor.tolist())
                            spread_tenor_unit = np.array(credit_spread_curve_data.tenor_unit.tolist())
                            cs_interpolation_algorithm = credit_spread_curve_data[
                                "interpolation_algorithm"
                            ].iloc[0]
                            cs_extrapolation_algorithm = credit_spread_curve_data[
                                "extrapolation_algorithm"
                            ].iloc[0]
                            tenor_extrac = np.vectorize(tenor_extraction)
                            spread_tenor = tenor_extrac(spread_tenor, spread_tenor_unit)
                            spread_tenor_unit = None
                            del spread_tenor_unit
                            spread_rates = credit_spread_curve_data.spread_value.to_numpy()
                            credit_spread_rates = np.empty([0], dtype="float64")
                            for j in range(len(TTM_array)):
                                if linearinterp(spread_tenor, spread_rates, TTM_array[j]) is None:
                                    if cs_extrapolation_algorithm == "Linear":
                                        calculated_value = linearexterp(spread_tenor, spread_rates, j)
                                    else:
                                        calculated_value = flatexterp(spread_tenor, spread_rates, j)
                                else:
                                    calculated_value = linearinterp(spread_tenor, spread_rates, TTM_array[j])
                                credit_spread_rates = np.append(credit_spread_rates, calculated_value)
                            all_in_rate = zero_rates + credit_spread_rates
                            credit_spread_rates = None
                            spread_tenor = None
                            spread_rates = None
                            del credit_spread_rates
                            del spread_tenor
                            del spread_rates
                        else:
                            all_in_rate = zero_rates
                        del credit_spread_curve_data
                    else:
                        all_in_rate = zero_rates

                    if row[column_index_dict["model_code"]] in ["M030", "M031", "M033", "M034"]:
                        (
                            PV,
                            PV_table,
                            TTM_array,
                            Total_amount_array,
                            df,
                            PV_coupons,
                            PV_principal,
                            PV_plus_1bps,
                            PV_minus_1bps,
                        ) = fixed_income_valuation(
                            TTM_array,
                            cashflows,
                            all_in_rate,
                            cashflows,
                            cashflows,
                            curve_compounding_frequency=curve_compounding_frequency,
                        )
                        PV = np.array([PV], dtype="float64")
                        cashflow_model_results["present_value"] = PV_table

                    else:
                        PV, TTM_array, df, PV_plus_1bps, PV_minus_1bps = commercial_paper_valuation(
                            TTM_array,
                            cashflows,
                            all_in_rate,
                            curve_compounding_frequency=curve_compounding_frequency,
                        )
                        if z_spread_calculation == "Yes":
                            market_data = mtm_data[
                                (mtm_data["security_identifier"] == Unique_Reference_Id)
                                & (mtm_data["extract_date"] == Valuation_Date[0])
                            ]
                            if len(market_data) > 0 and str(market_data["quoted_price"].iloc[0]) not in [
                                "nan",
                                "None",
                                "",
                            ]:
                                (PV, TTM_array, df, PV_plus_1bps, PV_minus_1bps) = (
                                    z_spread_calculation_and_revaluation_zcb(
                                        TTM_array,
                                        cashflows,
                                        all_in_rate,
                                        market_data,
                                        curve_compounding_frequency=curve_compounding_frequency,
                                        request=request,
                                    )
                                )
                        cashflow_model_results["present_value"] = Redemption_Amount * df
                    valuation_output = {
                        "PV": PV[0],
                    }
                    valuation_results.append(valuation_output)
                    cashflow_model_results["discount_factor"] = df
                    output_msg = output_check_fn(valuation_output=PV)

                    if output_msg["Val_Output"] == "Present":
                        valuation_output = {
                            "PV": PV[0],
                        }
                        measure_dict_val = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value per unit",
                            "measure_value": round(PV[0], 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_dict_val_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value",
                            "measure_value": round(PV[0] * Quantity, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_val)
                        measure_value.append(measure_dict_val_position)
                        valuation_results.append(valuation_output)
                        total_holding = Quantity * valuation_results[0]["PV"]

                        if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":

                            if row[column_index_dict["model_code"]] in ["M030", "M031", "M033", "M034"]:
                                (
                                    PV01,
                                    macaulay_duration,
                                    modified_duration,
                                    effective_duration,
                                    ytm,
                                ) = valuation_models.fixed_income_sensitivity_analysis(
                                    PV_table,
                                    TTM_array,
                                    Total_amount_array,
                                    "",
                                    "",
                                    PV,
                                    PV_plus_1bps,
                                    PV_minus_1bps,
                                )
                                macaulay_duration = np.array([macaulay_duration], dtype="float64")
                                effective_duration = np.array([effective_duration], dtype="float64")
                                modified_duration = np.array([modified_duration], dtype="float64")

                            else:
                                (
                                    macaulay_duration,
                                    modified_duration,
                                    PV01,
                                    effective_duration,
                                    ytm,
                                ) = valuation_models.commercial_paper_sensitivity_analysis(
                                    PV, TTM_array, Redemption_Amount, PV_plus_1bps, PV_minus_1bps
                                )

                            sensitivity_analysis.append(
                                {
                                    "Macaulay_Duration": macaulay_duration.tolist()[0],
                                    "Effective Duration": effective_duration.tolist()[0],
                                    "Modified_Duration": modified_duration.tolist()[0],
                                    "PV01 per unit": PV01,
                                }
                            )
                            if isinstance(ytm, (np.ndarray)):
                                ytm = ytm[0]
                            else:
                                ytm = ytm
                            measure_dict_ytm = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Yield to Maturity",
                                "measure_value": ytm,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_ytm)
                            measure_dict_mac_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Macaulay Duration",
                                "measure_value": macaulay_duration[0],
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mac_dur)
                            measure_dict_eff_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Effective Duration",
                                "measure_value": effective_duration[0],
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_eff_dur)
                            measure_dict_mod_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Modified Duration",
                                "measure_value": modified_duration[0],
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mod_dur)
                            measure_dict_pv01 = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01 per unit",
                                "measure_value": PV01,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01)
                            measure_dict_pv01_position = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01",
                                "measure_value": PV01 * Quantity,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01_position)
                    else:
                        valuation_output = {
                            "PV": "None",
                        }
                        total_holding = "None"
                        valuation_results.append(valuation_output)

                elif config_dict["inputs"]["Valuation_Method"] == "mtm_valuation":
                    security_mtm_data = mtm_data[
                        (mtm_data["security_identifier"] == Unique_Reference_Id[0])
                        & (mtm_data["extract_date"] == Valuation_Date[0])
                    ]

                    cashflow_model_results = cashflow_model_results.astype(
                        {
                            "time_to_maturity": "float64",
                            "cashflow": "float64",
                            "transaction_date": "datetime64[ns]",
                        }
                    )

                    output_msg = output_check_fn(price_df=security_mtm_data)

                    if output_msg["Val_df_Output"] == "Present":
                        PV = security_mtm_data["quoted_price"].iloc[0]
                        total_holding = Quantity * PV
                        valuation_output = {
                            "PV": round(PV, 4),
                        }
                        measure_dict_val = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value per unit",
                            "measure_value": round(PV, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_dict_val_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value",
                            "measure_value": round(PV * Quantity, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_val)
                        measure_value.append(measure_dict_val_position)
                        valuation_results.append(valuation_output)

                        if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":
                            if output_msg["Sensitivity_output"] == "Present":
                                modified_duration = security_mtm_data["modified_duration"].iloc[0]
                                ytm = np.array([security_mtm_data["yield"].iloc[0]])
                                PV_input = np.array([PV])
                                if row[column_index_dict["model_code"]] in ["M030", "M031", "M033", "M034"]:
                                    (
                                        PV01,
                                        macaulay_duration,
                                        modified_duration,
                                        effective_duration,
                                        ytm,
                                    ) = valuation_models.fixed_income_mtm_sensitivity_analysis(
                                        modified_duration,
                                        ytm,
                                        TTM_array,
                                        cashflows,
                                        "",
                                        "",
                                        PV_input,
                                    )
                                else:
                                    (
                                        macaulay_duration,
                                        modified_duration,
                                        PV01,
                                        effective_duration,
                                        ytm,
                                    ) = valuation_models.commercial_paper_mtm_sensitivity_analysis(
                                        PV_input, TTM_array, Redemption_Amount, ytm, modified_duration
                                    )

                                sensitivity_analysis.append(
                                    {
                                        "Macaulay_Duration": macaulay_duration,
                                        "Effective Duration": effective_duration[0],
                                        "Modified_Duration": modified_duration,
                                        "PV01 per unit": PV01,
                                    }
                                )
                                if isinstance(ytm, (np.ndarray)):
                                    ytm = ytm[0]
                                else:
                                    ytm = ytm
                                measure_dict_ytm = {
                                    "measure_run_date": datetime.now(),
                                    "valuation_date": Valuation_Date[0],
                                    "unique_reference_id": Unique_Reference_Id,
                                    "position_id": Position_Id,
                                    "reference_dimension": reference_dimension,
                                    "measure_type": "Yield to Maturity",
                                    "measure_value": ytm,
                                    "absolute_relative": "Absolute",
                                    "residual_maturity": TTM_array[-1],
                                    "asset_liability_type": asset_liability_type,
                                    "product_variant_name": product_variant_name,
                                    "fund": fund,
                                    "portfolio": portfolio,
                                    "cohort": "",
                                    "entity": entity,
                                }
                                measure_value.append(measure_dict_ytm)
                                measure_dict_mac_dur = {
                                    "measure_run_date": datetime.now(),
                                    "valuation_date": Valuation_Date[0],
                                    "unique_reference_id": Unique_Reference_Id,
                                    "position_id": Position_Id,
                                    "reference_dimension": reference_dimension,
                                    "measure_type": "Macaulay Duration",
                                    "measure_value": macaulay_duration,
                                    "absolute_relative": "Absolute",
                                    "residual_maturity": TTM_array[-1],
                                    "asset_liability_type": asset_liability_type,
                                    "product_variant_name": product_variant_name,
                                    "fund": fund,
                                    "portfolio": portfolio,
                                    "cohort": "",
                                    "entity": entity,
                                }
                                measure_value.append(measure_dict_mac_dur)
                                measure_dict_eff_dur = {
                                    "measure_run_date": datetime.now(),
                                    "valuation_date": Valuation_Date[0],
                                    "unique_reference_id": Unique_Reference_Id,
                                    "position_id": Position_Id,
                                    "reference_dimension": reference_dimension,
                                    "measure_type": "Effective Duration",
                                    "measure_value": effective_duration[0],
                                    "absolute_relative": "Relative",
                                    "residual_maturity": TTM_array[-1],
                                    "asset_liability_type": asset_liability_type,
                                    "product_variant_name": product_variant_name,
                                    "fund": fund,
                                    "portfolio": portfolio,
                                    "cohort": "",
                                    "entity": entity,
                                }
                                measure_value.append(measure_dict_eff_dur)
                                measure_dict_mod_dur = {
                                    "measure_run_date": datetime.now(),
                                    "valuation_date": Valuation_Date[0],
                                    "unique_reference_id": Unique_Reference_Id,
                                    "position_id": Position_Id,
                                    "reference_dimension": reference_dimension,
                                    "measure_type": "Modified Duration",
                                    "measure_value": modified_duration,
                                    "absolute_relative": "Relative",
                                    "residual_maturity": TTM_array[-1],
                                    "asset_liability_type": asset_liability_type,
                                    "product_variant_name": product_variant_name,
                                    "fund": fund,
                                    "portfolio": portfolio,
                                    "cohort": "",
                                    "entity": entity,
                                }
                                measure_value.append(measure_dict_mod_dur)
                                measure_dict_pv01 = {
                                    "measure_run_date": datetime.now(),
                                    "valuation_date": Valuation_Date[0],
                                    "unique_reference_id": Unique_Reference_Id,
                                    "position_id": Position_Id,
                                    "reference_dimension": reference_dimension,
                                    "measure_type": "PV01 per unit",
                                    "measure_value": PV01,
                                    "absolute_relative": "Absolute",
                                    "residual_maturity": TTM_array[-1],
                                    "asset_liability_type": asset_liability_type,
                                    "product_variant_name": product_variant_name,
                                    "fund": fund,
                                    "portfolio": portfolio,
                                    "cohort": "",
                                    "entity": entity,
                                }
                                measure_value.append(measure_dict_pv01)
                                measure_dict_pv01_position = {
                                    "measure_run_date": datetime.now(),
                                    "valuation_date": Valuation_Date[0],
                                    "unique_reference_id": Unique_Reference_Id,
                                    "position_id": Position_Id,
                                    "reference_dimension": reference_dimension,
                                    "measure_type": "PV01",
                                    "measure_value": PV01 * Quantity,
                                    "absolute_relative": "Absolute",
                                    "residual_maturity": TTM_array[-1],
                                    "asset_liability_type": asset_liability_type,
                                    "product_variant_name": product_variant_name,
                                    "fund": fund,
                                    "portfolio": portfolio,
                                    "cohort": "",
                                    "entity": entity,
                                }
                                measure_value.append(measure_dict_pv01_position)
                            else:
                                sensitivity_analysis.append(
                                    {
                                        "Macaulay_Duration": "-",
                                        "Effective Duration": "-",
                                        "Modified_Duration": "-",
                                        "PV01 per unit": "-",
                                    }
                                )
                    else:
                        valuation_output = {
                            "PV": "None",
                        }
                        total_holding = "None"
                        valuation_results.append(valuation_output)

            else:
                sensitivity_analysis.append(
                    {
                        "Macaulay_Duration": "-",
                        "Effective Duration": "-",
                        "Modified_Duration": "-",
                        "PV01 per unit": "-",
                    }
                )
                valuation_output = {
                    "PV": "None",
                }
                total_holding = "None"
                valuation_results.append(valuation_output)

        else:
            sensitivity_analysis.append(
                {
                    "Macaulay_Duration": "-",
                    "Effective Duration": "-",
                    "Modified_Duration": "-",
                    "PV01 per unit": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        cashflow_model_results = cashflow_model_results[cashflow_model_results["time_to_maturity"] != 0]
        if accrued_interest is not None:
            if len(accrued_interest) > 0 and str(accrued_interest[0]) not in ["", "0.0", "None", "nan"]:
                cashflow_model_results = pd.concat(
                    [cashflow_model_results, cashflow_model_results.iloc[[-1]]], ignore_index=True
                )
                cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow")] = (
                    accrued_interest[0]
                )
                cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow_type")] = (
                    "Accrued Interest"
                )
                cashflow_model_results.iloc[
                    -1, cashflow_model_results.columns.get_loc("transaction_date")
                ] = pd.to_datetime(Valuation_Date[0])
                cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("present_value")] = (
                    None
                )
                cashflow_model_results.iloc[
                    -1, cashflow_model_results.columns.get_loc("time_to_maturity")
                ] = cashflow_model_results["time_to_maturity"].iloc[0]
                cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("discount_factor")] = (
                    None
                )
                cashflow_model_results = cashflow_model_results.sort_values(
                    by=["transaction_date", "cashflow_type"], ascending=True
                )

        cashflow_model_results["cashflow"] = cashflow_model_results["cashflow"] * Quantity
        cashflow_model_results["present_value"] = present_value_check_function(
            cashflow_model_results["present_value"], Quantity
        )
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = Unique_Reference_Id
        final_output_dict["Position_Id"] = Position_Id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = Valuation_Date[0]
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Quantity"] = Quantity
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Quantity"] = Quantity
            final_output_dict["Total_Holding"] = total_holding

        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        measure_value = pd.DataFrame(measure_value)
        measure_value["currency"] = currency
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] == "M006":

        final_output_dict = {}
        Issue_Date = pd.to_datetime(row[column_index_dict["issue_date"]], dayfirst=True)
        Maturity_Date = np.array([pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True)])
        Face_Value = np.array([float(row[column_index_dict["face_value"]])])
        Redemption_Amount = np.array([float(row[column_index_dict["redemption_amount"]])])
        accrued_interest = row[column_index_dict["accrued_interest"]]
        if str(accrued_interest) not in ["nan", "None", ""]:
            accrued_interest = np.array([float(accrued_interest / Quantity)], dtype="float")
        Coupon_Rate = np.array([float(row[column_index_dict["base_rate"]]) / 100])
        Coupon_Frequency = row[column_index_dict["payment_frequency"]]
        Coupon_Frequency_unit = row[column_index_dict["payment_frequency_units"]]
        Discount_Daycount = row[column_index_dict["discount_daycount_convention"]]
        Accrual_Daycount = row[column_index_dict["accrual_daycount_convention"]]
        Discount_Curve = row[column_index_dict["discounting_curve"]]
        Business_day_convention = np.array([row[column_index_dict["business_convention"]]])
        Last_coupon_date = row[column_index_dict["last_payment_date"]]
        if str(Last_coupon_date) not in ["nan", "NaT", "None", "-"]:
            Last_coupon_date = np.datetime64(row[column_index_dict["last_payment_date"]], "D")
        stub_date = row[column_index_dict["stub_date"]]
        if str(stub_date) not in ["nan", "NaT", "None", "-"]:
            stub_date = np.datetime64(row[column_index_dict["stub_date"]], "D")

        Credit_Spread_Rate = row[column_index_dict["credit_spread_rate"]]
        Credit_Spread_Curve = row[column_index_dict["credit_spread_curve"]]
        interest_calculation_methodology = row[column_index_dict["interest_calculation_methodology"]]
        compounding_frequency = row[column_index_dict["compounding_frequency"]]
        compounding_frequency_unit = row[column_index_dict["compounding_frequency_unit"]]
        principal_business_day_convention = row[column_index_dict["principal_business_day_convention"]]
        if cashflow_uploaded_data is not None and len(cashflow_uploaded_data) > 0:
            cashflow_uploaded_data_position = cashflow_uploaded_data.loc[
                cashflow_uploaded_data["position_id"] == Position_Id
            ]
        else:
            cashflow_uploaded_data_position = pd.DataFrame()
        if len(cashflow_uploaded_data_position) > 0:
            cashflow_upload = True
            cashflow_uploaded_data_position["cashflow"] = (
                cashflow_uploaded_data_position["cashflow"] / Quantity
            )
            accrued_interest = cashflow_model_results.loc[
                cashflow_model_results["cashflow_type"] == "Accrued Interest", "cashflow"
            ]
            if len(accrued_interest) > 0:
                accrued_interest = np.array([accrued_interest.iloc[0]], dtype="float")
            else:
                accrued_interest = None
            cashflow_model_results = cashflow_model_results.loc[
                cashflow_model_results["cashflow_type"] != "Accrued Interest"
            ]
            cashflow_model_results = cashflow_uploaded_data_position.copy()
            cashflow_uploaded_data_position["coupons"] = np.where(
                cashflow_uploaded_data_position["cashflow_type"] == "Interest Proceeds",
                cashflow_uploaded_data_position["cashflow"],
                0,
            )
            cashflow_uploaded_data_position["principal"] = np.where(
                cashflow_uploaded_data_position["cashflow_type"] == "Redemption Proceeds",
                cashflow_uploaded_data_position["cashflow"],
                0,
            )
            coupon_array = cashflow_uploaded_data_position["coupons"].to_numpy()
            principal_amount_array = cashflow_uploaded_data_position["principal"].to_numpy()
            total_amount_array = cashflow_uploaded_data_position["cashflow"].to_numpy()
            cashflow_model_results[["cashflow_status", "discount_factor", "present_value"]] = [
                cashflow_status,
                "",
                "",
            ]
            del cashflow_uploaded_data_position
        else:
            cashflow_upload = False
            cashflow_results_output = valuation_models.fixed_coupon_cashflow_generation(
                Unique_Reference_Id,
                Issue_Date,
                Maturity_Date,
                Face_Value,
                Redemption_Amount,
                Coupon_Rate,
                Coupon_Frequency,
                Coupon_Frequency_unit,
                Valuation_Date,
                Discount_Daycount,
                Accrual_Daycount,
                Discount_Curve,
                Business_day_convention,
                Last_coupon_date,
                holiday_calendar,
                custom_daycount_conventions,
                accrued_interest,
                interest_calculation_methodology,
                compounding_frequency,
                compounding_frequency_unit,
                stub_date=stub_date,
                business_days=business_days,
                principal_business_day_convention = principal_business_day_convention
            )
            coupon_array = cashflow_results_output[4]
            principal_amount_array = cashflow_results_output[5]
            accrued_interest = cashflow_results_output[7]
            maturity_date =  cashflow_results_output[8]
            cashflow_model_results_interest = pd.DataFrame({
                "extract_date": Valuation_Date[0],
                "transaction_date": cashflow_results_output[2],
                "unique_reference_id": Unique_Reference_Id,
                "reference_dimension": reference_dimension,
                "cashflow_type": "Interest Proceeds",
                "cashflow_status": cashflow_status,
                "cashflow": cashflow_results_output[4],
                "time_to_maturity": cashflow_results_output[3],
                "discount_factor": None,
                "present_value": None,
                "currency": currency,
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": None,
                "entity": entity,
            })
            cashflow_model_results_principal = pd.DataFrame([{
                "extract_date": Valuation_Date[0],
                "transaction_date":  maturity_date,
                "unique_reference_id": Unique_Reference_Id,
                "reference_dimension": reference_dimension,
                "cashflow_type": "Redemption Proceeds",
                "cashflow_status": cashflow_status,
                "cashflow": principal_amount_array[0],
                "time_to_maturity": cashflow_results_output[9][0],
                "discount_factor": None,
                "present_value": None,
                "currency": currency,
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": None,
                "entity": entity,
            }])
            cashflow_model_results = pd.concat([cashflow_model_results_interest,cashflow_model_results_principal], ignore_index=True)

        measure_value = []
        cashflow_model_results = cashflow_model_results.astype(
            {"time_to_maturity": "float64", "cashflow": "float64", "transaction_date": "datetime64[ns]"}
        )
        valuation_results = []
        sensitivity_analysis = []
        PV_principal = []
        output_msg = output_check_fn(
            cashflow_results=cashflow_model_results[cashflow_model_results["time_to_maturity"] != 0]
        )
        if output_msg["CF_Output"] == "Present":
            if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
                TTM = cashflow_model_results["time_to_maturity"].to_numpy(dtype="float64")
                total_amount_array = cashflow_model_results["cashflow"].to_numpy(dtype="float64")
                if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                    zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == Discount_Curve), :]
                    tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                    rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                    zero_rates = np.empty([0], dtype="float64")
                    extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                    curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[
                        0
                    ]
                    for j in range(len(TTM)):
                        if zero_rate_curve_points["interpolation_algorithm"].iloc[0] == "Linear":
                            inter_val = linearinterp(tenor, rates, TTM[j])
                            if inter_val is None:
                                if extrapolation_algorithm == "Linear":
                                    extrapolated_value = linearexterp(tenor, rates, TTM[j])
                                else:
                                    extrapolated_value = flatexterp(tenor, rates, TTM[j])
                                zero_rates = np.append(zero_rates, extrapolated_value)
                            else:
                                interpolated_value = inter_val
                                zero_rates = np.append(zero_rates, interpolated_value)
                    zero_rate_curve_points = None
                    tenor = None
                    rates = None
                    del zero_rate_curve_points
                    del tenor
                    del rates
                    # Add Credit Spread Rate to zero_rates
                    if str(Credit_Spread_Rate) not in ["nan", "None"]:
                        zero_rates = zero_rates + float(Credit_Spread_Rate)
                    elif str(Credit_Spread_Curve) not in ["nan", "None"]:
                        credit_spread_curve_data = credit_spread_data.loc[
                            (credit_spread_data["credit_spread_curve_name"] == Credit_Spread_Curve), :
                        ]
                        cs_interpolation_algorithm = credit_spread_curve_data["interpolation_algorithm"].iloc[
                            0
                        ]
                        cs_extrapolation_algorithm = credit_spread_curve_data["extrapolation_algorithm"].iloc[
                            0
                        ]

                        if not credit_spread_curve_data.empty:
                            spread_tenor = credit_spread_curve_data.tenor.to_numpy()
                            spread_tenor_unit = credit_spread_curve_data.tenor_unit.to_numpy()
                            tenor_extrac = np.vectorize(tenor_extraction)
                            spread_tenor = tenor_extrac(spread_tenor, spread_tenor_unit)
                            del spread_tenor_unit
                            spread_rates = credit_spread_curve_data.spread_value.to_numpy()
                            credit_spread_rates = np.empty([0], dtype="float64")

                            for j in TTM:
                                interp_val = linearinterp(spread_tenor, spread_rates, j)
                                if interp_val is None:
                                    if cs_extrapolation_algorithm == "Linear":
                                        extrapolated_value = linearexterp(spread_tenor, spread_rates, j)
                                    else:
                                        extrapolated_value = flatexterp(spread_tenor, spread_rates, j)
                                    credit_spread_rates = np.append(credit_spread_rates, extrapolated_value)
                                else:
                                    interpolated_value = interp_val
                                    credit_spread_rates = np.append(credit_spread_rates, interpolated_value)
                            zero_rates = zero_rates + credit_spread_rates
                            credit_spread_curve_data = None
                            credit_spread_rates = None
                            del credit_spread_curve_data
                            del spread_tenor
                            del spread_rates
                            del credit_spread_rates
                    zero_rates = zero_rates.astype("float64")
                    (
                        PV_output,
                        PV_table,
                        TTM_array,
                        Total_amount_array,
                        DF,
                        PV_plus_1bps,
                        PV_minus_1bps,
                    ) = fixed_income_valuation_investments(
                        TTM,
                        total_amount_array.astype("float64"),
                        zero_rates,
                        curve_compounding_frequency=curve_compounding_frequency,
                    )
                    if z_spread_calculation == "Yes":
                        market_data = mtm_data[
                            (mtm_data["security_identifier"] == Unique_Reference_Id)
                            & (mtm_data["extract_date"] == Valuation_Date[0])
                        ]
                        if len(market_data) > 0 and str(market_data["quoted_price"].iloc[0]) not in [
                            "nan",
                            "None",
                            "",
                        ]:
                            (
                                PV_output,
                                PV_table,
                                TTM_array,
                                Total_amount_array,
                                DF,
                                PV_plus_1bps,
                                PV_minus_1bps,
                            ) = z_spread_calculation_and_revaluation(
                                TTM,
                                total_amount_array.astype("float64"),
                                zero_rates,
                                market_data,
                                accrued_interest[0],
                                curve_compounding_frequency=curve_compounding_frequency,
                                request=request,
                            )

                    cashflow_model_results["present_value"] = PV_table
                    cashflow_model_results["discount_factor"] = DF
                    
                    output_msg = output_check_fn(valuation_output=PV_output)

                    if output_msg["Val_Output"] == "Present":
                        valuation_output = {
                            "PV": round(PV_output, 4),
                        }
                        measure_dict_val = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value per unit",
                            "measure_value": round(PV_output, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_dict_val_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value",
                            "measure_value": round(PV_output * Quantity, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_val)
                        measure_value.append(measure_dict_val_position)
                        valuation_results.append(valuation_output)
                        total_holding = Quantity * valuation_results[0]["PV"]

                        if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":

                            (
                                PV01,
                                macaulay_duration,
                                modified_duration,
                                effective_duration,
                                ytm,
                            ) = valuation_models.fixed_income_sensitivity_analysis(
                                PV_table,
                                TTM_array,
                                Total_amount_array,
                                Coupon_Frequency,
                                Coupon_Frequency_unit,
                                PV_output,
                                PV_plus_1bps,
                                PV_minus_1bps,
                            )
                            sensitivity_analysis.append(
                                {
                                    "Macaulay_Duration": macaulay_duration,
                                    "Effective Duration": effective_duration,
                                    "Modified_Duration": modified_duration,
                                    "PV01 per unit": PV01,
                                }
                            )
                            if isinstance(ytm, (np.ndarray)):
                                ytm = ytm[0]
                            else:
                                ytm = ytm
                            measure_dict_ytm = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Yield to Maturity",
                                "measure_value": ytm,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_ytm)
                            measure_dict_mac_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Macaulay Duration",
                                "measure_value": macaulay_duration,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mac_dur)
                            measure_dict_eff_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Effective Duration",
                                "measure_value": effective_duration,
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_eff_dur)
                            measure_dict_mod_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Modified Duration",
                                "measure_value": modified_duration,
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mod_dur)
                            measure_dict_pv01 = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01 per unit",
                                "measure_value": PV01,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01)
                            measure_dict_pv01_position = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01",
                                "measure_value": PV01 * Quantity,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01_position)
                    else:
                        valuation_output = {
                            "PV": "None",
                        }
                        total_holding = "None"
                        valuation_results.append(valuation_output)

                elif config_dict["inputs"]["Valuation_Method"] == "mtm_valuation":
                    security_mtm_data = mtm_data[
                        (mtm_data["security_identifier"] == Unique_Reference_Id)
                        & (mtm_data["extract_date"] == Valuation_Date[0])
                    ]
                    output_msg = output_check_fn(price_df=security_mtm_data)
                    if output_msg["Val_df_Output"] == "Present":
                        PV = security_mtm_data["quoted_price"].iloc[0]
                        total_holding = Quantity * PV
                        valuation_output = {
                            "PV": round(PV, 4),
                        }
                        measure_dict_val = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value per unit",
                            "measure_value": round(PV, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_dict_val_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value",
                            "measure_value": round(PV * Quantity, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_val)
                        measure_value.append(measure_dict_val_position)
                        valuation_results.append(valuation_output)
                    elif output_msg["YTM_Output"] == "Present" and output_msg["Val_df_Output"] != "Present":
                        ytm = np.array([security_mtm_data["yield"].iloc[0]])
                        (
                            PV,
                            PV_table,
                            TTM_array,
                            Total_amount_array,
                            DF,
                            PV_coupons,
                            PV_principal,
                        ) = valuation_models.fixed_income_mtm_valuation(
                            TTM,
                            total_amount_array.astype("float64"),
                            coupon_array.astype("float64"),
                            principal_amount_array.astype("float64"),
                            ytm,
                        )
                        valuation_output = {
                            "PV": round(PV, 4),
                        }
                        total_holding = Quantity * PV
                        valuation_results.append(valuation_output)
                        measure_dict_val = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value per unit",
                            "measure_value": round(PV, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_dict_val_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value",
                            "measure_value": round(PV * Quantity, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_val)
                        measure_value.append(measure_dict_val_position)
                        cashflow_model_results["discount_factor"] = DF
                        if not cashflow_upload:
                            cashflow_model_results["present_value"] = PV_coupons
                        else:
                            cashflow_model_results["present_value"] = PV_table
                    else:
                        valuation_output = {
                            "PV": "None",
                        }
                        total_holding = "None"
                        valuation_results.append(valuation_output)
                    if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":
                        if output_msg["Sensitivity_output"] == "Present":
                            modified_duration = security_mtm_data["modified_duration"].iloc[0]
                            ytm = np.array([security_mtm_data["yield"].iloc[0]])
                            PV_input = np.array([PV])
                            (
                                PV01,
                                macaulay_duration,
                                modified_duration,
                                effective_duration,
                                ytm,
                            ) = valuation_models.fixed_income_mtm_sensitivity_analysis(
                                modified_duration,
                                ytm,
                                TTM,
                                total_amount_array.astype("float64"),
                                Coupon_Frequency,
                                Coupon_Frequency_unit,
                                PV_input,
                            )
                            sensitivity_analysis.append(
                                {
                                    "Macaulay_Duration": macaulay_duration[0],
                                    "Effective Duration": effective_duration[0],
                                    "Modified_Duration": modified_duration,
                                    "PV01 per unit": PV01,
                                }
                            )
                            if isinstance(ytm, (np.ndarray)):
                                ytm = ytm[0]
                            else:
                                ytm = ytm
                            measure_dict_ytm = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Yield to Maturity",
                                "measure_value": ytm,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM[len(TTM) - 1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_ytm)
                            measure_dict_mac_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Macaulay Duration",
                                "measure_value": macaulay_duration[0],
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM[len(TTM) - 1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mac_dur)
                            measure_dict_eff_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Effective Duration",
                                "measure_value": effective_duration[0],
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM[len(TTM) - 1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_eff_dur)
                            measure_dict_mod_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Modified Duration",
                                "measure_value": modified_duration,
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM[len(TTM) - 1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mod_dur)
                            measure_dict_pv01 = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01 per unit",
                                "measure_value": PV01,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM[len(TTM) - 1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01)
                            measure_dict_pv01_position = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01",
                                "measure_value": PV01 * Quantity,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM[len(TTM) - 1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01_position)

                        else:
                            sensitivity_analysis.append(
                                {
                                    "Macaulay_Duration": "-",
                                    "Effective Duration": "-",
                                    "Modified_Duration": "-",
                                    "PV01 per unit": "-",
                                }
                            )

            else:
                sensitivity_analysis.append(
                    {
                        "Macaulay_Duration": "-",
                        "Effective Duration": "-",
                        "Modified_Duration": "-",
                        "PV01 per unit": "-",
                    }
                )
                valuation_output = {
                    "PV": "None",
                }
                total_holding = "None"
                valuation_results.append(valuation_output)

        else:
            sensitivity_analysis.append(
                {
                    "Macaulay_Duration": "-",
                    "Effective Duration": "-",
                    "Modified_Duration": "-",
                    "PV01 per unit": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        cashflow_model_results = cashflow_model_results[cashflow_model_results["time_to_maturity"] != 0]
        if str(accrued_interest[0]) not in ["", "0.0", "None", "nan"]:
            cashflow_model_results = pd.concat(
                [cashflow_model_results, cashflow_model_results.iloc[[-1]]], ignore_index=True
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow")] = (
                accrued_interest[0]
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow_type")] = (
                "Accrued Interest"
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("transaction_date")] = (
                pd.to_datetime(Valuation_Date[0])
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("present_value")] = 0
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("time_to_maturity")] = (
                cashflow_model_results["time_to_maturity"].iloc[0]
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("discount_factor")] = 0
            cashflow_model_results = cashflow_model_results.sort_values(
                by=["transaction_date", "cashflow_type"], ascending=True
            )
        cashflow_model_results["cashflow"] = cashflow_model_results["cashflow"] * Quantity
        cashflow_model_results["present_value"] = present_value_check_function(
            cashflow_model_results["present_value"], Quantity
        )
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = Unique_Reference_Id
        final_output_dict["Position_Id"] = Position_Id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = Valuation_Date[0]
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Quantity"] = Quantity
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        measure_value = pd.DataFrame(measure_value)
        measure_value["currency"] = currency
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] == "M007":
        final_output_dict = {}
        Issue_Date = pd.to_datetime(row[column_index_dict["issue_date"]], dayfirst=True)
        Maturity_Date = np.array([pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True)])
        Face_Value = np.array([float(row[column_index_dict["face_value"]])])
        Redemption_Amount = np.array([float(row[column_index_dict["redemption_amount"]])])
        Spread_Over_Benchmark = row[column_index_dict["fixed_spread"]]
        current_benchmark_rate = row[column_index_dict["current_benchmark_rate"]]
        Coupon_Frequency = row[column_index_dict["payment_frequency"]]
        Coupon_Frequency_unit = row[column_index_dict["payment_frequency_units"]]
        Discount_Daycount = np.array([row[column_index_dict["discount_daycount_convention"]]])
        Accrual_Daycount = np.array([row[column_index_dict["accrual_daycount_convention"]]])
        Discount_Curve = row[column_index_dict["discounting_curve"]]
        Business_day_convention = np.array([row[column_index_dict["business_convention"]]])
        Last_coupon_date = row[column_index_dict["last_payment_date"]]
        if str(Last_coupon_date) not in ["nan", "NaT", "None", "-"]:
            Last_coupon_date = np.datetime64(row[column_index_dict["last_payment_date"]], "D")
        stub_date = row[column_index_dict["stub_date"]]
        if str(stub_date) not in ["nan", "NaT", "None", "-"]:
            stub_date = np.datetime64(row[column_index_dict["stub_date"]], "D")
        Coupon_Benchmark_Curve = row[column_index_dict["forward_benchmark_curve"]]
        Next_Repricing_Date = pd.to_datetime(row[column_index_dict["next_reset_date"]], dayfirst=True)
        Last_Repricing_Date = pd.to_datetime(row[column_index_dict["last_reset_date"]], dayfirst=True)
        Repricing_Frequency = row[column_index_dict["reset_frequency"]]
        Repricing_Frequency_unit = row[column_index_dict["reset_frequency_unit"]]
        Credit_Spread_Rate = row[column_index_dict["credit_spread_rate"]]
        Credit_Spread_Curve = row[column_index_dict["credit_spread_curve"]]
        accrued_interest = row[column_index_dict["accrued_interest"]]
        if str(accrued_interest) not in ["nan", "None", ""]:
            accrued_interest = np.array([float(accrued_interest / Quantity)], dtype="float")
        valuation_results = []
        sensitivity_analysis = []
        PV_principal = []
        measure_value = []
        if cashflow_uploaded_data is not None and len(cashflow_uploaded_data) > 0:
            cashflow_uploaded_data_position = cashflow_uploaded_data.loc[
                cashflow_uploaded_data["position_id"] == Position_Id
            ]
        else:
            cashflow_uploaded_data_position = pd.DataFrame()
        if len(cashflow_uploaded_data_position) > 0:
            cashflow_upload = True
            cashflow_uploaded_data_position["cashflow"] = (
                cashflow_uploaded_data_position["cashflow"] / Quantity
            )
            accrued_interest = cashflow_model_results.loc[
                cashflow_model_results["cashflow_type"] == "Accrued Interest", "cashflow"
            ]
            if len(accrued_interest) > 0:
                accrued_interest = np.array([accrued_interest.iloc[0]], dtype="float")
            else:
                accrued_interest = None
            cashflow_model_results = cashflow_model_results.loc[
                cashflow_model_results["cashflow_type"] != "Accrued Interest"
            ]
            cashflow_model_results = cashflow_uploaded_data_position.copy()
            cashflow_uploaded_data_position["coupons"] = np.where(
                cashflow_uploaded_data_position["cashflow_type"] == "Interest Proceeds",
                cashflow_uploaded_data_position["cashflow"],
                0,
            )
            cashflow_uploaded_data_position["principal"] = np.where(
                cashflow_uploaded_data_position["cashflow_type"] == "Redemption Proceeds",
                cashflow_uploaded_data_position["cashflow"],
                0,
            )
            coupon_array = cashflow_uploaded_data_position["coupons"].to_numpy()
            principal_amount_array = cashflow_uploaded_data_position["principal"].to_numpy()
            total_amount_array = cashflow_uploaded_data_position["cashflow"].to_numpy()
            cashflow_model_results[["cashflow_status", "discount_factor", "present_value"]] = [
                cashflow_status,
                "",
                "",
            ]
            del cashflow_uploaded_data_position
        else:
            cashflow_upload = False
            cashflow_results_output = valuation_models.floating_coupon_cashflow_generation(
                Unique_Reference_Id,
                Issue_Date,
                Maturity_Date,
                Face_Value,
                Redemption_Amount,
                Spread_Over_Benchmark,
                Coupon_Frequency,
                Coupon_Frequency_unit,
                Valuation_Date,
                Discount_Daycount,
                Accrual_Daycount,
                Discount_Curve,
                Business_day_convention,
                Last_coupon_date,
                Coupon_Benchmark_Curve,
                Next_Repricing_Date,
                Last_Repricing_Date,
                curve_data,
                Repricing_Frequency,
                Repricing_Frequency_unit,
                holiday_calendar,
                current_benchmark_rate,
                custom_daycount_conventions,
                accrued_interest,
                stub_date=stub_date,
                business_days=business_days,
            )
            coupon_array = cashflow_results_output[4]
            total_amount_array = cashflow_results_output[6]
            principal_amount_array = cashflow_results_output[5]
            accrued_interest = cashflow_results_output[7]
            cashflow_model_results = {
                "extract_date": Valuation_Date[0],
                "transaction_date": cashflow_results_output[2],
                "unique_reference_id": Unique_Reference_Id,
                "reference_dimension": reference_dimension,
                "cashflow_type": None,
                "cashflow_status": cashflow_status,
                "cashflow": cashflow_results_output[4],
                "time_to_maturity": cashflow_results_output[3],
                "discount_factor": None,
                "present_value": None,
                "currency": currency,
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": None,
                "entity": entity,
            }
            cashflow_model_results = pd.DataFrame(cashflow_model_results)
            cashflow_model_results["cashflow_type"] = "Interest Proceeds"

        cashflow_model_results = cashflow_model_results.astype(
            {"time_to_maturity": "float64", "cashflow": "float64", "transaction_date": "datetime64[ns]"}
        )

        output_msg = output_check_fn(
            cashflow_results=cashflow_model_results[cashflow_model_results["time_to_maturity"] != 0]
        )

        if output_msg["CF_Output"] == "Present":
            if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
                TTM = (cashflow_model_results["time_to_maturity"].to_numpy()).astype("float64")
                if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                    zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == Discount_Curve), :]
                    tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                    rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                    zero_rates = np.empty([0], dtype="float64")
                    extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                    curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[
                        0
                    ]
                    for j in TTM:
                        if zero_rate_curve_points["interpolation_algorithm"].iloc[0] == "Linear":
                            inter_val = linearinterp(tenor, rates, j)
                            if inter_val is None:
                                if extrapolation_algorithm == "Linear":
                                    extrapolated_value = linearexterp(tenor, rates, j)
                                else:
                                    extrapolated_value = flatexterp(tenor, rates, j)
                                zero_rates = np.append(zero_rates, extrapolated_value)
                            else:
                                interpolated_value = inter_val
                                zero_rates = np.append(zero_rates, interpolated_value)
                    zero_rate_curve_points = None
                    tenor = None
                    rates = None
                    del zero_rate_curve_points
                    del tenor
                    del rates
                    # Add Credit Spread Rate to zero_rates
                    if str(Credit_Spread_Rate) not in ["nan", "None"]:
                        zero_rates = zero_rates + float(Credit_Spread_Rate)
                    elif str(Credit_Spread_Curve) not in ["nan", "None"]:
                        credit_spread_curve_data = credit_spread_data.loc[
                            (credit_spread_data["credit_spread_curve_name"] == Credit_Spread_Curve), :
                        ]

                        if not credit_spread_curve_data.empty:
                            spread_tenor = credit_spread_curve_data.tenor.to_numpy()
                            spread_tenor_unit = credit_spread_curve_data.tenor_unit.to_numpy()
                            cs_interpolation_algorithm = credit_spread_curve_data[
                                "interpolation_algorithm"
                            ].iloc[0]
                            cs_extrapolation_algorithm = credit_spread_curve_data[
                                "extrapolation_algorithm"
                            ].iloc[0]
                            tenor_extrac = np.vectorize(tenor_extraction)
                            spread_tenor = tenor_extrac(spread_tenor, spread_tenor_unit)
                            del spread_tenor_unit
                            spread_rates = np.array(credit_spread_curve_data.spread_value.tolist())

                            credit_spread_rates = np.empty([0], dtype="float64")
                            for j in TTM:
                                interp_val = linearinterp(spread_tenor, spread_rates, j)
                                if interp_val is None:
                                    if cs_extrapolation_algorithm == "Linear":
                                        extrapolated_value = linearexterp(spread_tenor, spread_rates, j)
                                    else:
                                        extrapolated_value = flatexterp(spread_tenor, spread_rates, j)
                                    credit_spread_rates = np.append(credit_spread_rates, extrapolated_value)
                                else:
                                    interpolated_value = interp_val
                                    credit_spread_rates = np.append(credit_spread_rates, interpolated_value)
                            zero_rates = zero_rates + credit_spread_rates
                            credit_spread_curve_data = None
                            credit_spread_rates = None
                            del credit_spread_curve_data
                            del spread_tenor
                            del spread_rates
                            del credit_spread_rates
                    (
                        PV_output,
                        PV_table,
                        TTM_array,
                        Total_amount_array,
                        DF,
                        PV_coupons,
                        PV_principal,
                        PV_plus_1bps,
                        PV_minus_1bps,
                    ) = fixed_income_valuation(
                        TTM,
                        total_amount_array.astype("float64"),
                        zero_rates,
                        coupon_array.astype("float64"),
                        principal_amount_array.astype("float64"),
                        curve_compounding_frequency=curve_compounding_frequency,
                    )
                    cashflow_model_results["discount_factor"] = DF
                    if not cashflow_upload:
                        cashflow_model_results["present_value"] = PV_coupons
                    else:
                        cashflow_model_results["present_value"] = PV_table
                    output_msg = output_check_fn(valuation_output=PV_output)
                    if output_msg["Val_Output"] == "Present":
                        valuation_output = {
                            "PV": round(PV_output, 4),
                        }
                        measure_dict_val = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value per unit",
                            "measure_value": round(PV_output, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_dict_val_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value",
                            "measure_value": round(PV_output * Quantity, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_val)
                        measure_value.append(measure_dict_val_position)
                        valuation_results.append(valuation_output)
                        total_holding = Quantity * valuation_results[0]["PV"]

                        if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":
                            (
                                PV01,
                                macaulay_duration,
                                modified_duration,
                                effective_duration,
                                ytm,
                            ) = valuation_models.fixed_income_sensitivity_analysis(
                                PV_table,
                                TTM_array,
                                Total_amount_array,
                                Coupon_Frequency,
                                Coupon_Frequency_unit,
                                PV_output,
                                PV_plus_1bps,
                                PV_minus_1bps,
                            )
                            sensitivity_analysis.append(
                                {
                                    "Macaulay Duration": macaulay_duration,
                                    "Effective Duration": effective_duration,
                                    "Modified Duration": modified_duration,
                                    "PV01 per unit": PV01,
                                }
                            )
                            if isinstance(ytm, (np.ndarray)):
                                ytm = ytm[0]
                            else:
                                ytm = ytm
                            measure_dict_ytm = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Yield to Maturity",
                                "measure_value": ytm,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_ytm)
                            measure_dict_mac_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Macaulay Duration",
                                "measure_value": macaulay_duration,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mac_dur)
                            measure_dict_eff_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Effective Duration",
                                "measure_value": effective_duration,
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_eff_dur)
                            measure_dict_mod_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Modified Duration",
                                "measure_value": modified_duration,
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mod_dur)
                            measure_dict_pv01 = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01 per unit",
                                "measure_value": PV01,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01)
                            measure_dict_pv01_position = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01",
                                "measure_value": PV01 * Quantity,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01_position)

                    else:
                        valuation_output = {
                            "PV": "None",
                        }
                        total_holding = "None"
                        valuation_results.append(valuation_output)

                elif config_dict["inputs"]["Valuation_Method"] == "mtm_valuation":
                    security_mtm_data = mtm_data[
                        (mtm_data["security_identifier"] == Unique_Reference_Id)
                        & (mtm_data["extract_date"] == Valuation_Date[0])
                    ]
                    output_msg = output_check_fn(price_df=security_mtm_data)
                    if output_msg["Val_df_Output"] == "Present":
                        PV = security_mtm_data["quoted_price"].iloc[0]
                        total_holding = Quantity * PV
                        valuation_output = {
                            "PV": round(PV, 4),
                        }
                        measure_dict_val = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value per unit",
                            "measure_value": round(PV, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_dict_val_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value",
                            "measure_value": round(PV * Quantity, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_val)
                        measure_value.append(measure_dict_val_position)
                        valuation_results.append(valuation_output)
                    elif output_msg["YTM_Output"] == "Present" and output_msg["Val_df_Output"] != "Present":
                        ytm = np.array([security_mtm_data["yield"].iloc[0]])
                        (
                            PV,
                            PV_table,
                            TTM_array,
                            Total_amount_array,
                            DF,
                            PV_coupons,
                            PV_principal,
                        ) = valuation_models.fixed_income_mtm_valuation(
                            TTM,
                            total_amount_array.astype("float64"),
                            coupon_array.astype("float64"),
                            principal_amount_array.astype("float64"),
                            ytm,
                        )
                        valuation_output = {
                            "PV": round(PV, 4),
                        }
                        total_holding = Quantity * PV
                        valuation_results.append(valuation_output)
                        measure_dict_val = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value per unit",
                            "measure_value": round(PV, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_dict_val_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value",
                            "measure_value": round(PV * Quantity, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM[len(TTM) - 1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_val)
                        measure_value.append(measure_dict_val_position)
                        cashflow_model_results["discount_factor"] = DF
                        if not cashflow_upload:
                            cashflow_model_results["present_value"] = PV_coupons
                        else:
                            cashflow_model_results["present_value"] = PV_table
                    else:
                        valuation_output = {
                            "PV": "None",
                        }
                        total_holding = "None"
                        valuation_results.append(valuation_output)
                    if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":
                        if output_msg["Sensitivity_output"] == "Present":
                            modified_duration = security_mtm_data["modified_duration"].iloc[0]
                            ytm = np.array([security_mtm_data["yield"].iloc[0]])
                            PV_input = np.array([PV])
                            (
                                PV01,
                                macaulay_duration,
                                modified_duration,
                                effective_duration,
                                ytm,
                            ) = valuation_models.fixed_income_mtm_sensitivity_analysis(
                                modified_duration,
                                ytm,
                                TTM,
                                total_amount_array.astype("float64"),
                                Coupon_Frequency,
                                Coupon_Frequency_unit,
                                PV_input,
                            )
                            sensitivity_analysis.append(
                                {
                                    "Macaulay_Duration": macaulay_duration[0],
                                    "Effective Duration": effective_duration[0],
                                    "Modified_Duration": modified_duration,
                                    "PV01 per unit": PV01,
                                }
                            )
                            if isinstance(ytm, (np.ndarray)):
                                ytm = ytm[0]
                            else:
                                ytm = ytm
                            measure_dict_ytm = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Yield to Maturity",
                                "measure_value": ytm,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM[len(TTM) - 1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_ytm)
                            measure_dict_mac_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Macaulay Duration",
                                "measure_value": macaulay_duration[0],
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM[len(TTM) - 1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mac_dur)
                            measure_dict_eff_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Effective Duration",
                                "measure_value": effective_duration[0],
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM[len(TTM) - 1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_eff_dur)
                            measure_dict_mod_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Modified Duration",
                                "measure_value": modified_duration,
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM[len(TTM) - 1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mod_dur)
                            measure_dict_pv01 = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01 per unit",
                                "measure_value": PV01,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM[len(TTM) - 1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01)
                            measure_dict_pv01_position = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01",
                                "measure_value": PV01 * Quantity,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM[len(TTM) - 1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01_position)

                        else:
                            sensitivity_analysis.append(
                                {
                                    "Macaulay_Duration": "-",
                                    "Effective Duration": "-",
                                    "Modified_Duration": "-",
                                    "PV01 per unit": "-",
                                }
                            )

            else:
                sensitivity_analysis.append(
                    {
                        "Macaulay_Duration": "-",
                        "Effective Duration": "-",
                        "Modified_Duration": "-",
                        "PV01 per unit": "-",
                    }
                )
                valuation_output = {
                    "PV": "None",
                }
                total_holding = "None"
                valuation_results.append(valuation_output)

        else:
            sensitivity_analysis.append(
                {
                    "Macaulay_Duration": "-",
                    "Effective Duration": "-",
                    "Modified_Duration": "-",
                    "PV01 per unit": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)
        if not cashflow_upload:
            cashflow_model_results = pd.concat(
                [cashflow_model_results, cashflow_model_results.iloc[[-1]]], ignore_index=True
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow")] = (
                Redemption_Amount
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow_type")] = (
                "Redemption Proceeds"
            )
            if len(PV_principal) > 0:
                cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("present_value")] = (
                    PV_principal[-1]
                )
        cashflow_model_results = cashflow_model_results[cashflow_model_results["time_to_maturity"] != 0]
        if str(accrued_interest[0]) not in ["", "0.0", "None", "nan"]:
            cashflow_model_results = pd.concat(
                [cashflow_model_results, cashflow_model_results.iloc[[-1]]], ignore_index=True
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow")] = (
                accrued_interest[0]
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow_type")] = (
                "Accrued Interest"
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("transaction_date")] = (
                pd.to_datetime(Valuation_Date[0])
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("present_value")] = None
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("time_to_maturity")] = (
                cashflow_model_results["time_to_maturity"].iloc[0]
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("discount_factor")] = None
            cashflow_model_results = cashflow_model_results.sort_values(
                by=["transaction_date", "cashflow_type"], ascending=True
            )
        cashflow_model_results["cashflow"] = cashflow_model_results["cashflow"] * Quantity
        cashflow_model_results["present_value"] = present_value_check_function(
            cashflow_model_results["present_value"], Quantity
        )
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = Unique_Reference_Id
        final_output_dict["Position_Id"] = Position_Id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = Valuation_Date[0]
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Quantity"] = Quantity
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        measure_value = pd.DataFrame(measure_value)
        measure_value["currency"] = currency
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] in ["M009", "M013"]:
        measure_value = []
        cashflow_model_results = pd.DataFrame(
            columns=[
                "extract_date",
                "transaction_date",
                "unique_reference_id",
                "reference_dimension",
                "cashflow_type",
                "cashflow_status",
                "cashflow",
                "time_to_maturity",
                "discount_factor",
                "present_value",
                "currency",
                "asset_liability_type",
                "product_variant_name",
                "fund",
                "portfolio",
                "cohort",
                "entity",
            ]
        )
        valuation_results = []
        sensitivity_analysis = [
            {
                "Macaulay_Duration": "-",
                "Effective Duration": "-",
                "Modified_Duration": "-",
                "PV01 per unit": "-",
            }
        ]
        if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
            price_df = mtm_data[
                (mtm_data["security_identifier"] == Unique_Reference_Id)
                & (mtm_data["extract_date"] == Valuation_Date[0])
            ]["quoted_price"]

            if len(price_df) > 0:
                price = price_df.iloc[0]
                total_holding = Quantity * price
                valuation_output = {
                    "PV": round(price, 4),
                }
                measure_dict_val = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Fair Value per unit",
                    "measure_value": round(price, 4),
                    "absolute_relative": "Absolute",
                    "residual_maturity": None,
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }
                measure_dict_val_position = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Fair Value",
                    "measure_value": round(price * Quantity, 4),
                    "absolute_relative": "Absolute",
                    "residual_maturity": None,
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }
                measure_value.append(measure_dict_val)
                measure_value.append(measure_dict_val_position)

            else:
                total_holding = "None"
                valuation_output = {
                    "PV": "None",
                }

            valuation_results.append(valuation_output)
        else:
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        final_output_dict = {}
        final_output_dict["Unique_Reference_ID"] = Unique_Reference_Id
        final_output_dict["Position_Id"] = Position_Id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = Valuation_Date[0]
        final_output_dict["Cashflow_Result"] = json.dumps(
            [
                {
                    "extract_date": Valuation_Date[0],
                    "transaction_date": "-",
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "cashflow_type": "-",
                    "cashflow_status": cashflow_status,
                    "cashflow": "-",
                    "time_to_maturity": "-",
                    "discount_factor": None,
                    "present_value": None,
                    "currency": currency,
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "-",
                    "entity": entity,
                }
            ],
            cls=NpEncoder,
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Quantity"] = Quantity
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        measure_value = pd.DataFrame(measure_value)
        measure_value["currency"] = currency
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] in ["M014", "M027"]:  # For European Options
        Underlying_pos_id = np.array([row[column_index_dict["underlying_position_id"]]])
        Discount_Daycount = np.array([row[column_index_dict["discount_daycount_convention"]]])
        Maturity_Date = np.array(
            [pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True).strftime("%Y-%m-%d")]
        )
        MaturityDate = Maturity_Date.astype("datetime64[D]")
        position_direction = row[column_index_dict["position_direction"]]
        strike_price = np.array([row[column_index_dict["strike_price"]]])
        volatility_surface = row[column_index_dict["volatility_surface_id"]]
        if str(volatility_surface) not in ["nan", "NaT", "None", "-"]:
            vol_data_filtered = vol_data.loc[vol_data["surface_name"] == volatility_surface]
        else:
            vol_data_filtered = []
        discount_convention_code = valuation_models.daycount_convention_code(Discount_Daycount)
        TTM_array = conventions.D_day_count(
            Valuation_Date,
            MaturityDate,
            discount_convention_code,
            custom_daycount_conventions=discount_convention_code,
        )
        if row[column_index_dict["model_code"]] == "M027":
            primary_currency = row[column_index_dict["primary_currency"]]
            secondary_currency = row[column_index_dict["secondary_currency"]]
            currency_pair = secondary_currency + primary_currency
            spot_price = mtm_data.loc[
                (mtm_data["extract_date"] == Valuation_Date[0])
                & (mtm_data["security_identifier"] == currency_pair)
            ]["quoted_price"].values[0]
            if len(vol_data_filtered) <= 0:
                sigma = mtm_data.loc[
                    (mtm_data["extract_date"] == Valuation_Date[0])
                    & (mtm_data["security_identifier"] == currency_pair)
                ]["volatility"].values[0]
            else:
                sigma = None
            discount_curve_secondary_currency = row[column_index_dict["discounting_curve_secondary_currency"]]
            zero_rate_curve_points = curve_data.loc[
                (curve_data["curve_name"] == discount_curve_secondary_currency), :
            ]
            interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
            extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
            curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[0]
            tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
            rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
            if interpolation_algorithm == "Linear":
                if linearinterp(tenor, rates, TTM_array[0]) is None:
                    if extrapolation_algorithm == "Linear":
                        extrapolated_value = linearexterp(tenor, rates, TTM_array[0])
                    else:
                        extrapolated_value = flatexterp(tenor, rates, TTM_array[0])
                    rf = extrapolated_value
                else:
                    interpolated_value = linearinterp(tenor, rates, TTM_array[0])
                    rf = interpolated_value
            div = rf
            del tenor
            del rates
            del zero_rate_curve_points
        else:
            spot_price = mtm_data[
                (mtm_data["security_identifier"] == Underlying_pos_id[0])
                & (
                    mtm_data["extract_date"]
                    == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True)
                )
            ]["quoted_price"].iloc[0]
            if len(vol_data_filtered) <= 0:
                vix = vix_data.iloc[0]
                sigma = np.sqrt(vix) / 100
            else:
                sigma = None
            div = 0

        call_type = np.array([row[column_index_dict["put_call_type"]]])
        Discount_Curve = np.array([row[column_index_dict["discounting_curve"]]])

        cashflow_model_results = {
            "extract_date": Valuation_Date[0],
            "transaction_date": MaturityDate[0],
            "unique_reference_id": Unique_Reference_Id,
            "reference_dimension": reference_dimension,
            "cashflow_type": "-",
            "cashflow_status": "-",
            "cashflow": None,
            "time_to_maturity": TTM_array[0],
            "discount_factor": None,
            "present_value": None,
            "currency": currency,
            "asset_liability_type": asset_liability_type,
            "product_variant_name": product_variant_name,
            "fund": fund,
            "portfolio": portfolio,
            "cohort": "",
            "entity": entity,
        }
        cashflow_model_results = pd.DataFrame([cashflow_model_results])
        measure_value = []
        valuation_results = []
        sensitivity_analysis = []

        if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
            zero_rate_curve = Discount_Curve[0]
            quantity = float(row[column_index_dict["quantity"]])
            zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
            interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
            extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
            tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
            rates = np.array(zero_rate_curve_points["rate"], dtype="float64")

            if interpolation_algorithm == "Linear":
                if linearinterp(tenor, rates, TTM_array[0]) is None:
                    if extrapolation_algorithm == "Linear":
                        zero_rate = linearexterp(tenor, rates, TTM_array[0])
                    else:
                        zero_rate = flatexterp(tenor, rates, TTM_array[0])
                else:
                    zero_rate = linearinterp(tenor, rates, TTM_array[0])

            if sigma is None:
                sigma = volatility_calculation_from_surface(
                    vol_data_filtered,
                    spot_price=spot_price,
                    strike_price=strike_price[0].astype(float),
                    T=TTM_array[0].astype(float),
                    r=zero_rate,
                    q=div,
                )

            BS = Options_Pricing.Black_Scholes(
                S=spot_price,
                K=strike_price[0].astype(float),
                T=TTM_array[0].astype(float),
                r=zero_rate,
                div=div,
                sigma=sigma,
            )

            if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                if call_type[0] == "call":
                    price_df = BS.call()
                else:
                    price_df = BS.put()
            else:
                price_df = mtm_data[
                    (mtm_data["security_identifier"] == Unique_Reference_Id[0])
                    & (
                        mtm_data["extract_date"]
                        == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True)
                    )
                ]["quoted_price"]
                price_df = price_df.iloc[0]

            price = price_df
            if position_direction == "Sell":
                price = price * -1
            cashflow_model_results["present_value"] = price
            total_holding = np.round(quantity * price, 4)
            valuation_output = {
                "PV": np.round(price, 4),
            }
            measure_dict_val = {
                "measure_run_date": datetime.now(),
                "valuation_date": Valuation_Date[0],
                "unique_reference_id": Unique_Reference_Id,
                "position_id": Position_Id,
                "reference_dimension": reference_dimension,
                "measure_type": "Fair Value per unit",
                "measure_value": np.round(price, 4),
                "absolute_relative": "Absolute",
                "residual_maturity": TTM_array[-1],
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": "",
                "entity": entity,
            }
            measure_dict_val_position = {
                "measure_run_date": datetime.now(),
                "valuation_date": Valuation_Date[0],
                "unique_reference_id": Unique_Reference_Id,
                "position_id": Position_Id,
                "reference_dimension": reference_dimension,
                "measure_type": "Fair Value",
                "measure_value": np.round(price * Quantity, 4),
                "absolute_relative": "Absolute",
                "residual_maturity": TTM_array[-1],
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": "",
                "entity": entity,
            }
            measure_value.append(measure_dict_val)
            measure_value.append(measure_dict_val_position)

            valuation_results.append(valuation_output)

            if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":

                delta_val = np.round(BS.delta(call_type[0]), 4)
                gamma_val = np.round(BS.gamma(), 4)
                rho_val = np.round(BS.rho(call_type[0]), 4)
                phi_val = np.round(BS.phi(call_type[0]), 4)
                vanna_val = np.round(BS.vanna(), 4)
                vega_val = np.round(BS.vega(), 4)

                measure_dict_delta = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Delta",
                    "measure_value": delta_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_gamma = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Gamma",
                    "measure_value": gamma_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_rho = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Rho",
                    "measure_value": rho_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_phi = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Phi",
                    "measure_value": phi_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_vanna = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Vanna",
                    "measure_value": vanna_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_vega = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Vega",
                    "measure_value": vega_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_value.append(measure_dict_delta)
                measure_value.append(measure_dict_gamma)
                measure_value.append(measure_dict_rho)
                measure_value.append(measure_dict_phi)
                measure_value.append(measure_dict_vanna)
                measure_value.append(measure_dict_vega)

                sensitivity_analysis.append(
                    {
                        "Delta": delta_val,
                        "Gamma": gamma_val,
                        "Rho": rho_val,
                        "Phi": phi_val,
                        "Vanna": vanna_val,
                        "Vega": vega_val,
                    }
                )

        else:
            sensitivity_analysis.append(
                {
                    "Delta": "-",
                    "Gamma": "-",
                    "Rho": "-",
                    "Phi": "-",
                    "Vanna": "-",
                    "Vega": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        cashflow_model_results["extract_date"] = cashflow_model_results["extract_date"].astype(str)
        cashflow_model_results["transaction_date"] = cashflow_model_results["transaction_date"].astype(str)
        cashflow_model_results["present_value"] = present_value_check_function(
            cashflow_model_results["present_value"], Quantity
        )
        final_output_dict = {}
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = Unique_Reference_Id
        final_output_dict["Position_Id"] = Position_Id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = pd.to_datetime(Valuation_Date[0]).strftime("%Y-%m-%d")
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Quantity"] = Quantity
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Quantity"] = Quantity
            final_output_dict["Total_Holding"] = total_holding

        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        cashflow_model_results = cashflow_model_results[cashflow_model_results["time_to_maturity"] != "-"]
        measure_value = pd.DataFrame(measure_value)
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] in ["M015", "M041"]:  # For American Options
        Underlying_pos_id = np.array([row[column_index_dict["underlying_position_id"]]])
        Discount_Daycount = np.array([row[column_index_dict["discount_daycount_convention"]]])
        Maturity_Date = np.array(
            [pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True).strftime("%Y-%m-%d")]
        )
        MaturityDate = Maturity_Date.astype("datetime64[D]")
        position_direction = row[column_index_dict["position_direction"]]
        strike_price = np.array([row[column_index_dict["strike_price"]]])
        volatility_surface = row[column_index_dict["volatility_surface_id"]]
        if str(volatility_surface) not in ["nan", "NaT", "None", "-"]:
            vol_data_filtered = vol_data.loc[vol_data["surface_name"] == volatility_surface]
        else:
            vol_data_filtered = []
        discount_convention_code = valuation_models.daycount_convention_code(Discount_Daycount)
        TTM_array = conventions.D_day_count(
            Valuation_Date,
            MaturityDate,
            discount_convention_code,
            custom_daycount_conventions=discount_convention_code,
        )
        if row[column_index_dict["model_code"]] == "M041":
            primary_currency = row[column_index_dict["primary_currency"]]
            secondary_currency = row[column_index_dict["secondary_currency"]]
            currency_pair = secondary_currency + primary_currency
            spot_price = mtm_data.loc[
                (mtm_data["extract_date"] == Valuation_Date[0])
                & (mtm_data["security_identifier"] == currency_pair)
            ]["quoted_price"].values[0]
            if len(vol_data_filtered) <= 0:
                sigma = [
                    mtm_data.loc[
                        (mtm_data["extract_date"] == Valuation_Date[0])
                        & (mtm_data["security_identifier"] == currency_pair)
                    ]["volatility"].values[0]
                ]
            else:
                sigma = None
            discount_curve_secondary_currency = row[column_index_dict["discounting_curve_secondary_currency"]]
            zero_rate_curve_points = curve_data.loc[
                (curve_data["curve_name"] == discount_curve_secondary_currency), :
            ]
            interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
            extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
            tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
            rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
            if interpolation_algorithm == "Linear":
                if linearinterp(tenor, rates, TTM_array[0]) is None:
                    if extrapolation_algorithm == "Linear":
                        extrapolated_value = linearexterp(tenor, rates, TTM_array[0])
                    else:
                        extrapolated_value = flatexterp(tenor, rates, TTM_array[0])
                    rf = extrapolated_value
                else:
                    interpolated_value = linearinterp(tenor, rates, TTM_array[0])
                    rf = interpolated_value
            div = rf
            n_step = int(row[column_index_dict["tree_method_no_of_steps"]])
            del tenor
            del rates
            del zero_rate_curve_points
        else:
            spot_price = mtm_data[
                (mtm_data["security_identifier"] == Underlying_pos_id[0])
                & (
                    mtm_data["extract_date"]
                    == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True)
                )
            ]["quoted_price"].iloc[0]
            if len(vol_data_filtered) <= 0:
                vix = vix_data.iloc[0]
                sigma = np.sqrt(vix) / 100
            else:
                sigma = None
            div = 0
            n_step = int(abs(MaturityDate - ValuationDate) / np.timedelta64(1, "D"))

        call_type = np.array([row[column_index_dict["put_call_type"]]])
        Discount_Curve = np.array([row[column_index_dict["discounting_curve"]]])
        cashflow_model_results = {
            "extract_date": Valuation_Date[0],
            "transaction_date": MaturityDate[0],
            "unique_reference_id": Unique_Reference_Id,
            "reference_dimension": reference_dimension,
            "cashflow_type": "-",
            "cashflow_status": "-",
            "cashflow": None,
            "time_to_maturity": TTM_array[0],
            "discount_factor": None,
            "present_value": None,
            "currency": currency,
            "asset_liability_type": asset_liability_type,
            "product_variant_name": product_variant_name,
            "fund": fund,
            "portfolio": portfolio,
            "cohort": "",
            "entity": entity,
        }
        cashflow_model_results = pd.DataFrame([cashflow_model_results])
        measure_value = []
        valuation_results = []
        sensitivity_analysis = []

        if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
            zero_rate_curve = Discount_Curve[0]
            zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
            interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
            extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
            tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
            rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
            if interpolation_algorithm == "Linear":
                if linearinterp(tenor, rates, TTM_array[0]) is None:
                    if extrapolation_algorithm == "Linear":
                        zero_rate = linearexterp(tenor, rates, TTM_array[0])
                    else:
                        zero_rate = flatexterp(tenor, rates, TTM_array[0])
                else:
                    zero_rate = linearinterp(tenor, rates, TTM_array[0])
            quantity = float(row[column_index_dict["quantity"]])

            if sigma is None:
                sigma = [
                    volatility_calculation_from_surface(
                        vol_data_filtered,
                        spot_price=spot_price,
                        strike_price=strike_price[0].astype(float),
                        T=TTM_array[0].astype(float),
                        r=zero_rate,
                        q=div,
                    )
                ]

            BT = Options_Pricing.Binomial_Tree(
                n=n_step,
                S=spot_price,
                K=strike_price[0].astype(float),
                T=TTM_array[0].astype(float),
                r=zero_rate,
                q=div,
                sigma=sigma[0],
            )

            if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                price_df = BT.binomial(call_type[0])
            else:
                price_df = mtm_data[
                    (mtm_data["security_identifier"] == Unique_Reference_Id[0])
                    & (
                        mtm_data["extract_date"]
                        == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True)
                    )
                ]["quoted_price"]
                price_df = price_df.iloc[0]

            price = price_df
            if position_direction == "Sell":
                price = price * -1
            cashflow_model_results["present_value"] = price
            total_holding = np.round(quantity * price, 4)
            valuation_output = {
                "PV": np.round(price, 4),
            }
            measure_dict_val = {
                "measure_run_date": datetime.now(),
                "valuation_date": Valuation_Date[0],
                "unique_reference_id": Unique_Reference_Id,
                "position_id": Position_Id,
                "reference_dimension": reference_dimension,
                "measure_type": "Fair Value per unit",
                "measure_value": np.round(price, 4),
                "absolute_relative": "Absolute",
                "residual_maturity": TTM_array[-1],
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": "",
                "entity": entity,
            }
            measure_dict_val_position = {
                "measure_run_date": datetime.now(),
                "valuation_date": Valuation_Date[0],
                "unique_reference_id": Unique_Reference_Id,
                "position_id": Position_Id,
                "reference_dimension": reference_dimension,
                "measure_type": "Fair Value",
                "measure_value": np.round(price * Quantity, 4),
                "absolute_relative": "Absolute",
                "residual_maturity": TTM_array[-1],
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": "",
                "entity": entity,
            }
            measure_value.append(measure_dict_val)
            measure_value.append(measure_dict_val_position)

            valuation_results.append(valuation_output)

            if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":

                delta_val = np.round(BT.delta(call_type[0]), 4)
                gamma_val = np.round(BT.gamma(), 4)
                rho_val = np.round(BT.rho(call_type[0]), 4)
                phi_val = np.round(BT.phi(call_type[0]), 4)
                vanna_val = np.round(BT.vanna(), 4)
                vega_val = np.round(BT.vega(), 4)

                measure_dict_delta = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Delta",
                    "measure_value": delta_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_gamma = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Gamma",
                    "measure_value": gamma_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_rho = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Rho",
                    "measure_value": rho_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_phi = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Phi",
                    "measure_value": phi_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_vanna = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Vanna",
                    "measure_value": vanna_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_vega = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Vega",
                    "measure_value": vega_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_value.append(measure_dict_delta)
                measure_value.append(measure_dict_gamma)
                measure_value.append(measure_dict_rho)
                measure_value.append(measure_dict_phi)
                measure_value.append(measure_dict_vanna)
                measure_value.append(measure_dict_vega)

                sensitivity_analysis.append(
                    {
                        "Delta": delta_val,
                        "Gamma": gamma_val,
                        "Rho": rho_val,
                        "Phi": phi_val,
                        "Vanna": vanna_val,
                        "Vega": vega_val,
                    }
                )

        else:
            sensitivity_analysis.append(
                {
                    "Delta": "-",
                    "Gamma": "-",
                    "Rho": "-",
                    "Phi": "-",
                    "Vanna": "-",
                    "Vega": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        cashflow_model_results["extract_date"] = cashflow_model_results["extract_date"].astype(str)
        cashflow_model_results["transaction_date"] = cashflow_model_results["transaction_date"].astype(str)
        cashflow_model_results["present_value"] = present_value_check_function(
            cashflow_model_results["present_value"], Quantity
        )
        final_output_dict = {}
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = Unique_Reference_Id
        final_output_dict["Position_Id"] = Position_Id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = pd.to_datetime(Valuation_Date[0]).strftime("%Y-%m-%d")
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Quantity"] = Quantity
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Quantity"] = Quantity
            final_output_dict["Total_Holding"] = total_holding

        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        cashflow_model_results = cashflow_model_results[cashflow_model_results["time_to_maturity"] != "-"]
        measure_value = pd.DataFrame(measure_value)
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] in ["M016", "M040"]:  # For Digital Options
        Underlying_pos_id = np.array([row[column_index_dict["underlying_position_id"]]])
        Redemption_Value = np.array([row[column_index_dict["redemption_amount"]]])
        if str(Redemption_Value) not in ["nan", "NaT", "None", "-"]:
            Redemption_Value = np.array([1])
        position_direction = row[column_index_dict["position_direction"]]
        Discount_Daycount = np.array([row[column_index_dict["discount_daycount_convention"]]])
        Maturity_Date = np.array(
            [pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True).strftime("%Y-%m-%d")]
        )
        MaturityDate = Maturity_Date.astype("datetime64[D]")
        volatility_surface = row[column_index_dict["volatility_surface_id"]]
        if str(volatility_surface) not in ["nan", "NaT", "None", "-"]:
            vol_data_filtered = vol_data.loc[vol_data["surface_name"] == volatility_surface]
        else:
            vol_data_filtered = []
        strike_price = np.array([row[column_index_dict["strike_price"]]])
        discount_convention_code = valuation_models.daycount_convention_code(Discount_Daycount)
        TTM_array = conventions.D_day_count(
            Valuation_Date,
            MaturityDate,
            discount_convention_code,
            custom_daycount_conventions=discount_convention_code,
        )
        if row[column_index_dict["model_code"]] == "M040":
            primary_currency = row[column_index_dict["primary_currency"]]
            secondary_currency = row[column_index_dict["secondary_currency"]]
            currency_pair = secondary_currency + primary_currency
            spot_price = mtm_data.loc[
                (mtm_data["extract_date"] == Valuation_Date[0])
                & (mtm_data["security_identifier"] == currency_pair)
            ]["quoted_price"].values[0]
            if len(vol_data_filtered) <= 0:
                sigma = [
                    mtm_data.loc[
                        (mtm_data["extract_date"] == Valuation_Date[0])
                        & (mtm_data["security_identifier"] == currency_pair)
                    ]["volatility"].values[0]
                ]
            else:
                sigma = None
            discount_curve_secondary_currency = row[column_index_dict["discounting_curve_secondary_currency"]]
            zero_rate_curve_points = curve_data.loc[
                (curve_data["curve_name"] == discount_curve_secondary_currency), :
            ]
            interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
            extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
            tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
            rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
            if interpolation_algorithm == "Linear":
                if linearinterp(tenor, rates, TTM_array[0]) is None:
                    if extrapolation_algorithm == "Linear":
                        extrapolated_value = linearexterp(tenor, rates, TTM_array[0])
                    else:
                        extrapolated_value = flatexterp(tenor, rates, TTM_array[0])
                    rf = extrapolated_value
                else:
                    interpolated_value = linearinterp(tenor, rates, TTM_array[0])
                    rf = interpolated_value
            div = rf
            del tenor
            del rates
            del zero_rate_curve_points

        else:
            spot_price = mtm_data[
                (mtm_data["security_identifier"] == Underlying_pos_id[0])
                & (
                    mtm_data["extract_date"]
                    == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True)
                )
            ]["quoted_price"].iloc[0]
            if len(vol_data_filtered) <= 0:
                vix = vix_data.iloc[0]
                sigma = np.sqrt(vix) / 100
            else:
                sigma = None
            div = 0

        call_type = np.array([row[column_index_dict["put_call_type"]]])
        Discount_Curve = np.array([row[column_index_dict["discounting_curve"]]])
        cashflow_model_results = {
            "extract_date": Valuation_Date[0],
            "transaction_date": MaturityDate[0],
            "unique_reference_id": Unique_Reference_Id,
            "reference_dimension": reference_dimension,
            "cashflow_type": "-",
            "cashflow_status": "-",
            "cashflow": None,
            "time_to_maturity": TTM_array[0],
            "discount_factor": None,
            "present_value": None,
            "currency": currency,
            "asset_liability_type": asset_liability_type,
            "product_variant_name": product_variant_name,
            "fund": fund,
            "portfolio": portfolio,
            "cohort": "",
            "entity": entity,
        }
        cashflow_model_results = pd.DataFrame([cashflow_model_results])
        measure_value = []
        valuation_results = []
        sensitivity_analysis = []

        if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
            zero_rate_curve = Discount_Curve[0]
            zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
            interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
            extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
            tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
            rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
            if interpolation_algorithm == "Linear":
                if linearinterp(tenor, rates, TTM_array[0]) is None:
                    if extrapolation_algorithm == "Linear":
                        zero_rate = linearexterp(tenor, rates, TTM_array[0])
                    else:
                        zero_rate = flatexterp(tenor, rates, TTM_array[0])
                else:
                    zero_rate = linearinterp(tenor, rates, TTM_array[0])
            quantity = float(row[column_index_dict["quantity"]])

            if sigma is None:
                sigma = [
                    volatility_calculation_from_surface(
                        vol_data_filtered,
                        spot_price=spot_price,
                        strike_price=strike_price[0].astype(float),
                        T=TTM_array[0].astype(float),
                        r=zero_rate,
                        q=div,
                    )
                ]

            DT = Options_Pricing.Digital_Option(
                S=spot_price,
                K=strike_price[0].astype(float),
                T=TTM_array[0].astype(float),
                r=zero_rate,
                div=div,
                sigma=sigma[0],
                nominal_val=Redemption_Value[0].astype(float),
            )

            if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                if call_type[0] == "call":
                    price_df = DT.call()
                else:
                    price_df = DT.put()

            else:
                price_df = mtm_data[
                    (mtm_data["security_identifier"] == Unique_Reference_Id[0])
                    & (
                        mtm_data["extract_date"]
                        == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True)
                    )
                ]["quoted_price"]
                price_df = price_df.iloc[0]

            price = price_df
            if position_direction == "Sell":
                price = price * -1
            cashflow_model_results["present_value"] = price
            total_holding = np.round(quantity * price, 4)
            valuation_output = {
                "PV": np.round(price, 4),
            }
            measure_dict_val = {
                "measure_run_date": datetime.now(),
                "valuation_date": Valuation_Date[0],
                "unique_reference_id": Unique_Reference_Id,
                "position_id": Position_Id,
                "reference_dimension": reference_dimension,
                "measure_type": "Fair Value per unit",
                "measure_value": np.round(price, 4),
                "absolute_relative": "Absolute",
                "residual_maturity": TTM_array[-1],
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": "",
                "entity": entity,
            }
            measure_dict_val_position = {
                "measure_run_date": datetime.now(),
                "valuation_date": Valuation_Date[0],
                "unique_reference_id": Unique_Reference_Id,
                "position_id": Position_Id,
                "reference_dimension": reference_dimension,
                "measure_type": "Fair Value",
                "measure_value": np.round(price * Quantity, 4),
                "absolute_relative": "Absolute",
                "residual_maturity": TTM_array[-1],
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": "",
                "entity": entity,
            }
            measure_value.append(measure_dict_val)
            measure_value.append(measure_dict_val_position)

            valuation_results.append(valuation_output)

            if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":

                # Delta
                DO_up = Options_Pricing.Digital_Option(
                    S=spot_price + 0.0001 * spot_price,
                    K=strike_price[0].astype(float),
                    T=TTM_array[0].astype(float),
                    r=zero_rate,
                    sigma=sigma[0],
                    div=div,
                    nominal_val=Redemption_Value[0].astype(float),
                )
                DO_down = Options_Pricing.Digital_Option(
                    S=spot_price - 0.0001 * spot_price,
                    K=strike_price[0].astype(float),
                    T=TTM_array[0].astype(float),
                    r=zero_rate,
                    sigma=sigma[0],
                    div=div,
                    nominal_val=Redemption_Value[0].astype(float),
                )

                spot_change_up = digital_fx_greeks_computation(DO_up, call_type)
                spot_change_down = digital_fx_greeks_computation(DO_down, call_type)
                delta_val = (
                    (abs(spot_change_up - price_df) + abs(spot_change_down - price_df)) / 2
                ) * Quantity

                # Vega
                DO_up = Options_Pricing.Digital_Option(
                    S=spot_price,
                    K=strike_price[0].astype(float),
                    T=TTM_array[0].astype(float),
                    r=zero_rate,
                    sigma=sigma[0] + 0.0001,
                    div=div,
                    nominal_val=Redemption_Value[0].astype(float),
                )
                DO_down = Options_Pricing.Digital_Option(
                    S=spot_price,
                    K=strike_price[0].astype(float),
                    T=TTM_array[0].astype(float),
                    r=zero_rate,
                    sigma=sigma[0] - 0.0001,
                    div=div,
                    nominal_val=Redemption_Value[0].astype(float),
                )
                vol_change_up = digital_fx_greeks_computation(DO_up, call_type)
                vol_change_down = digital_fx_greeks_computation(DO_down, call_type)
                vega_val = ((abs(vol_change_up - price_df) + abs(vol_change_down - price_df)) / 2) * Quantity

                # Theta
                ttm_up = TTM_array[0].astype(float) + 0.00273972602739726
                ttm_down = TTM_array[0].astype(float) - 0.00273972602739726

                zero_rate_curve_points = curve_data.loc[
                    (curve_data["curve_name"] == discount_curve_secondary_currency), :
                ]
                interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
                extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                if interpolation_algorithm == "Linear":
                    if linearinterp(tenor, rates, ttm_up) is None:
                        if extrapolation_algorithm == "Linear":
                            extrapolated_value = linearexterp(tenor, rates, ttm_up)
                        else:
                            extrapolated_value = flatexterp(tenor, rates, ttm_up)
                        rf_up = extrapolated_value
                    else:
                        interpolated_value = linearinterp(tenor, rates, ttm_up)
                        rf_up = interpolated_value
                if interpolation_algorithm == "Linear":
                    if linearinterp(tenor, rates, ttm_down) is None:
                        if extrapolation_algorithm == "Linear":
                            extrapolated_value = linearexterp(tenor, rates, ttm_down)
                        else:
                            extrapolated_value = flatexterp(tenor, rates, ttm_down)
                        rf_down = extrapolated_value
                    else:
                        interpolated_value = linearinterp(tenor, rates, ttm_down)
                        rf_down = interpolated_value

                zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
                interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
                extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                if interpolation_algorithm == "Linear":
                    if linearinterp(tenor, rates, ttm_up) is None:
                        if extrapolation_algorithm == "Linear":
                            rd_up = linearexterp(tenor, rates, ttm_up)
                        else:
                            rd_up = flatexterp(tenor, rates, ttm_up)
                    else:
                        rd_up = linearinterp(tenor, rates, ttm_up)
                if interpolation_algorithm == "Linear":
                    if linearinterp(tenor, rates, ttm_down) is None:
                        if extrapolation_algorithm == "Linear":
                            rd_down = linearexterp(tenor, rates, ttm_down)
                        else:
                            rd_down = flatexterp(tenor, rates, ttm_down)
                    else:
                        rd_down = linearinterp(tenor, rates, ttm_down)

                DO_up = Options_Pricing.Digital_Option(
                    S=spot_price,
                    K=strike_price[0].astype(float),
                    T=ttm_up,
                    r=rd_up,
                    sigma=sigma[0],
                    div=rf_up,
                    nominal_val=Redemption_Value[0].astype(float),
                )
                DO_down = Options_Pricing.Digital_Option(
                    S=spot_price,
                    K=strike_price[0].astype(float),
                    T=ttm_down,
                    r=rd_down,
                    sigma=sigma[0],
                    div=rf_down,
                    nominal_val=Redemption_Value[0].astype(float),
                )
                ttm_change_up = digital_fx_greeks_computation(DO_up, call_type)
                ttm_change_down = digital_fx_greeks_computation(DO_down, call_type)
                theta_val = ((abs(ttm_change_up - price_df) + abs(ttm_change_down - price_df)) / 2) * Quantity

                # Rho
                DO_up = Options_Pricing.Digital_Option(
                    S=spot_price,
                    K=strike_price[0].astype(float),
                    T=TTM_array[0].astype(float),
                    r=zero_rate + 0.0001,
                    sigma=sigma[0],
                    div=div,
                    nominal_val=Redemption_Value[0].astype(float),
                )
                DO_down = Options_Pricing.Digital_Option(
                    S=spot_price,
                    K=strike_price[0].astype(float),
                    T=TTM_array[0].astype(float),
                    r=zero_rate - 0.0001,
                    sigma=sigma[0],
                    div=div,
                    nominal_val=Redemption_Value[0].astype(float),
                )
                rd_change_up = digital_fx_greeks_computation(DO_up, call_type)
                rd_change_down = digital_fx_greeks_computation(DO_down, call_type)
                rho_val = ((abs(rd_change_up - price_df) + abs(rd_change_down - price_df)) / 2) * Quantity

                # Phi
                DO_up = Options_Pricing.Digital_Option(
                    S=spot_price,
                    K=strike_price[0].astype(float),
                    T=TTM_array[0].astype(float),
                    r=zero_rate,
                    sigma=sigma[0],
                    div=div + 0.0001,
                    nominal_val=Redemption_Value[0].astype(float),
                )
                DO_down = Options_Pricing.Digital_Option(
                    S=spot_price,
                    K=strike_price[0].astype(float),
                    T=TTM_array[0].astype(float),
                    r=zero_rate,
                    sigma=sigma[0],
                    div=div - 0.0001,
                    nominal_val=Redemption_Value[0].astype(float),
                )
                rf_change_up = digital_fx_greeks_computation(DO_up, call_type)
                rf_change_down = digital_fx_greeks_computation(DO_down, call_type)
                phi_val = ((abs(rf_change_up - price_df) + abs(rf_change_down - price_df)) / 2) * Quantity

                measure_dict_delta = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Delta",
                    "measure_value": delta_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_vega = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Vega",
                    "measure_value": vega_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_theta = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Theta",
                    "measure_value": theta_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_rho = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Rho",
                    "measure_value": rho_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_phi = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Phi",
                    "measure_value": phi_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_value.append(measure_dict_delta)
                measure_value.append(measure_dict_vega)
                measure_value.append(measure_dict_theta)
                measure_value.append(measure_dict_rho)
                measure_value.append(measure_dict_phi)

                sensitivity_analysis.append(
                    {
                        "Delta": round(delta_val, 6),
                        "Vega": round(vega_val, 6),
                        "Theta": round(theta_val, 6),
                        "Rho": round(rho_val, 6),
                        "Phi": round(phi_val, 6),
                    }
                )

        else:
            sensitivity_analysis.append({"Delta": "-", "Vega": "-", "Theta": "-", "Rho": "-", "Phi": "-"})
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        cashflow_model_results["extract_date"] = cashflow_model_results["extract_date"].astype(str)
        cashflow_model_results["transaction_date"] = cashflow_model_results["transaction_date"].astype(str)
        cashflow_model_results["present_value"] = present_value_check_function(
            cashflow_model_results["present_value"], Quantity
        )
        final_output_dict = {}
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = Unique_Reference_Id
        final_output_dict["Position_Id"] = Position_Id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = pd.to_datetime(Valuation_Date[0]).strftime("%Y-%m-%d")
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Quantity"] = Quantity
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Quantity"] = Quantity
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        cashflow_model_results = cashflow_model_results[cashflow_model_results["time_to_maturity"] != "-"]
        measure_value = pd.DataFrame(measure_value)
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] in ["M017"]:  # For Asian Options
        Unique_Reference_Id = np.array([row[column_index_dict["unique_reference_id"]]])
        Underlying_pos_id = np.array([row[column_index_dict["underlying_position_id"]]])
        Position_Id = np.array([row[column_index_dict["position_id"]]])
        Quantity = np.array([row[column_index_dict["quantity"]]])
        reference_dimension = np.array(["Security"])
        cashflow_status = np.array(["Unrealised"])
        currency = np.array([row[column_index_dict["primary_currency"]]])
        asset_liability_type = np.array(["Asset"])
        product_variant_name = np.array([row[column_index_dict["product_variant_name"]]])
        fund = np.array([row[column_index_dict["fund_code"]]])
        portfolio = np.array([row[column_index_dict["pool_id"]]])
        entity = np.array([row[column_index_dict["legal_entity"]]])
        Valuation_Date = np.array(
            [pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True).strftime("%Y-%m-%d")]
        )
        ValuationDate = Valuation_Date.astype("datetime64[D]")
        Discount_Daycount = np.array([row[column_index_dict["discount_daycount_convention"]]])
        Maturity_Date = np.array(
            [pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True).strftime("%Y-%m-%d")]
        )
        MaturityDate = Maturity_Date.astype("datetime64[D]")
        spot_price = mtm_data[
            (mtm_data["security_identifier"] == Underlying_pos_id[0])
            & (
                mtm_data["extract_date"]
                == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True)
            )
        ]["quoted_price"].iloc[0]
        strike_price = np.array([row[column_index_dict["strike_price"]]])
        discount_convention_code = valuation_models.daycount_convention_code(Discount_Daycount)
        TTM_array = conventions.D_day_count(
            ValuationDate,
            MaturityDate,
            discount_convention_code,
            custom_daycount_conventions=custom_daycount_conventions,
        )
        vix = vix_data.iloc[0]
        sigma = np.sqrt(vix) / 100
        call_type = np.array([row[column_index_dict["put_call_type"]]])
        Discount_Curve = np.array([row[column_index_dict["discounting_curve"]]])
        time_intervals = []
        if discount_convention_code == "Actual/365":
            time_intervals.append(TTM_array[0] * 365)
        else:
            time_intervals.append(TTM_array[0] * 252)

        cashflow_results = [
            Valuation_Date,
            "-",
            Position_Id,
            reference_dimension,
            "-",
            "-",
            "-",
            "-",
            "-",
            "-",
            currency,
            asset_liability_type,
            product_variant_name,
            fund,
            portfolio,
            "",
            entity,
        ]
        index_values = [
            "extract_date",
            "transaction_date",
            "unique_reference_id",
            "reference_dimension",
            "cashflow_type",
            "cashflow_status",
            "cashflow",
            "time_to_maturity",
            "discount_factor",
            "present_value",
            "currency",
            "asset_liability_type",
            "product_variant_name",
            "fund",
            "portfolio",
            "cohort",
            "entity",
        ]
        measure_value = []
        cashflow_model_results = pd.DataFrame(data=cashflow_results, index=index_values).transpose()
        valuation_results = []
        sensitivity_analysis = []

        if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
            zero_rate_curve = Discount_Curve[0]
            zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
            interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
            extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
            tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
            rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
            if interpolation_algorithm == "Linear":
                if linearinterp(tenor, rates, TTM_array[0]) is None:
                    if extrapolation_algorithm == "Linear":
                        zero_rate = linearexterp(tenor, rates, TTM_array[0])
                    else:
                        zero_rate = flatexterp(tenor, rates, TTM_array[0])
                else:
                    zero_rate = linearinterp(tenor, rates, TTM_array[0])
            quantity = float(row[column_index_dict["quantity"]])

            AO = Options_Pricing.Asian_Option(
                S=spot_price,
                K=strike_price[0].astype(float),
                T=TTM_array[0].astype(float),
                r=zero_rate,
                sigma=sigma[0],
                Nt=time_intervals[0],
                div=0,
            )

            if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                price_df = AO.price_estimate(call_type[0])
            else:
                price_df = mtm_data[
                    (mtm_data["security_identifier"] == Unique_Reference_Id[0])
                    & (
                        mtm_data["extract_date"]
                        == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True)
                    )
                ]["quoted_price"]
                price_df = price_df.iloc[0]

            price = price_df
            total_holding = np.round(quantity * price, 4)
            valuation_output = {
                "PV": np.round(price, 4),
            }
            measure_dict_val = {
                "measure_run_date": datetime.now(),
                "valuation_date": Valuation_Date[0],
                "unique_reference_id": Unique_Reference_Id,
                "position_id": Position_Id,
                "reference_dimension": reference_dimension,
                "measure_type": "Fair Value per unit",
                "measure_value": np.round(price, 4),
                "absolute_relative": "Absolute",
                "residual_maturity": TTM_array[-1],
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": "",
                "entity": entity,
            }
            measure_dict_val_position = {
                "measure_run_date": datetime.now(),
                "valuation_date": Valuation_Date[0],
                "unique_reference_id": Unique_Reference_Id,
                "position_id": Position_Id,
                "reference_dimension": reference_dimension,
                "measure_type": "Fair Value",
                "measure_value": np.round(price * Quantity[0], 4),
                "absolute_relative": "Absolute",
                "residual_maturity": TTM_array[-1],
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": "",
                "entity": entity,
            }
            measure_value.append(measure_dict_val)
            measure_value.append(measure_dict_val_position)

            valuation_results.append(valuation_output)

            if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":

                delta_val = np.round(AO.delta(call_type[0]), 4)
                gamma_val = np.round(AO.gamma(), 4)
                rho_val = np.round(AO.rho(call_type[0]), 4)
                phi_val = np.round(AO.phi(call_type[0]), 4)
                vanna_val = np.round(AO.vanna(), 4)
                vega_val = np.round(AO.vega(), 4)

                measure_dict_delta = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Delta",
                    "measure_value": delta_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_gamma = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Gamma",
                    "measure_value": gamma_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_rho = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Rho",
                    "measure_value": rho_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_phi = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Phi",
                    "measure_value": phi_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_vanna = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Vanna",
                    "measure_value": vanna_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_vega = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Vega",
                    "measure_value": vega_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_value.append(measure_dict_delta)
                measure_value.append(measure_dict_gamma)
                measure_value.append(measure_dict_rho)
                measure_value.append(measure_dict_phi)
                measure_value.append(measure_dict_vanna)
                measure_value.append(measure_dict_vega)

                sensitivity_analysis.append(
                    {
                        "Delta": delta_val,
                        "Gamma": gamma_val,
                        "Rho": rho_val,
                        "Phi": phi_val,
                        "Vanna": vanna_val,
                        "Vega": vega_val,
                    }
                )

        else:
            sensitivity_analysis.append(
                {
                    "Delta": "-",
                    "Gamma": "-",
                    "Rho": "-",
                    "Phi": "-",
                    "Vanna": "-",
                    "Vega": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        cashflow_model_results["extract_date"] = cashflow_model_results["extract_date"].astype(str)
        cashflow_model_results["transaction_date"] = cashflow_model_results["transaction_date"].astype(str)
        final_output_dict = {}
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = Unique_Reference_Id[0]
        final_output_dict["Position_Id"] = Position_Id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = pd.to_datetime(Valuation_Date[0]).strftime("%Y-%m-%d")
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Quantity"] = Quantity[0]
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        cashflow_model_results = cashflow_model_results[cashflow_model_results["time_to_maturity"] != "-"]
        measure_value = pd.DataFrame(measure_value)
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] == "M018":
        final_output_dict = {}
        issue_date = np.array(row[column_index_dict["issue_date"]], dtype="datetime64[D]")
        accrual_daycount = row[column_index_dict["accrual_daycount_convention"]]
        discount_daycount = row[column_index_dict["discount_daycount_convention"]]
        accrual_convention_code = valuation_models.daycount_convention_code(accrual_daycount)
        business_day_convention = np.array([row[column_index_dict["business_convention"]]])
        discount_convention_code = valuation_models.daycount_convention_code(discount_daycount)
        discount_curve = row[column_index_dict["discounting_curve"]]
        last_payment_date = row[column_index_dict["last_payment_date"]]
        if str(last_payment_date) not in ["nan", "NaT", "None", "-"]:
            last_payment_date = np.datetime64(row[column_index_dict["last_payment_date"]], "D")
        stub_date = row[column_index_dict["stub_date"]]
        if str(stub_date) not in ["nan", "NaT", "None", "-"]:
            stub_date = np.datetime64(row[column_index_dict["stub_date"]], "D")
        payment_frequency = row[column_index_dict["payment_frequency"]]
        payment_frequency_unit = row[column_index_dict["payment_frequency_units"]]
        base_rate = float(row[column_index_dict["base_rate"]]) / 100
        if str(row[column_index_dict["fixed_spread"]]) not in ["", "nan", "None"]:
            fixed_spread = float(row[column_index_dict["fixed_spread"]]) / 100
        else:
            fixed_spread = 0
        interest_rate = base_rate + fixed_spread
        outstanding_amount = np.array([float(row[column_index_dict["outstanding_amount"]])])
        accrued_interest = row[column_index_dict["accrued_interest"]]
        if str(accrued_interest) not in ["nan", "None", ""]:
            accrued_interest = np.array([float(accrued_interest / Quantity)], dtype="float")
        maturity_date = np.array([pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True)])
        moratorium_flag = row[column_index_dict["moratorium_flag"]]
        interest_moratorium_flag = row[column_index_dict["interest_moratorium_flag"]]
        moratorium_interest_capitalization = row[column_index_dict["moratorium_interest_capitalization"]]
        if str(row[column_index_dict["quantity"]]) not in ["nan", "None", ""]:
            quantity = float(row[column_index_dict["quantity"]])
        else:
            quantity = 1
        credit_spread_rate = row[column_index_dict["credit_spread_rate"]]
        credit_spread_curve = row[column_index_dict["credit_spread_curve"]]
        interest_overdue = row[column_index_dict["interest_overdue_amount"]]
        principal_overdue = row[column_index_dict["principal_overdue_amount"]]
        charges_overdue = row[column_index_dict["charges_overdue_amount"]]
        interest_calculation_methodology = row[column_index_dict["interest_calculation_methodology"]]
        compounding_frequency = row[column_index_dict["compounding_frequency"]]
        compounding_frequency_unit = row[column_index_dict["compounding_frequency_unit"]]
        fixed_float_flag = row[column_index_dict["fixed_or_float_flag"]]
        next_reset_date = row[column_index_dict["next_reset_date"]]
        if str(next_reset_date) not in ["nan", "NaT", "None", "-"]:
            next_reset_date = np.datetime64(row[column_index_dict["next_reset_date"]], "D")

        moratorium_end_date = row[column_index_dict["moratorium_end_date"]]
        if moratorium_flag == "Y":
            if str(moratorium_end_date) in ["nan", "NaT", "None", "-"]:
                moratorium_period = row[column_index_dict["moratorium_period"]]
                moratorium_period_units = row[column_index_dict["moratorium_period_units"]]
                moratorium_period = valuation_models.coupon_Frequency(
                    moratorium_period, moratorium_period_units
                )
                moratorium_end_date = np.datetime64(
                    pd.to_datetime(issue_date[0]).date() + pd.DateOffset(months=int(12 / moratorium_period)),
                    "D",
                )
                if convention_code == "EOM":
                    moratorium_end_date = np.datetime64(conventions.eomonth(moratorium_end_date), "D")
                else:
                    moratorium_end_date = np.datetime64(
                        conventions.business_day(
                            moratorium_end_date,
                            convention_code,
                            holiday_calendar,
                            business_days=business_days,
                        )[0],
                        "D",
                    )
            else:
                moratorium_end_date = np.datetime64(row[column_index_dict["moratorium_end_date"]], "D")
            if interest_moratorium_flag == "Y":
                if moratorium_interest_capitalization == "Yes":
                    moratorium_interest_calculation_methodology = row[
                        column_index_dict["interest_calculation_logic_moratorium"]
                    ]
                    if moratorium_end_date >= Valuation_Date[0]:
                        if str(accrued_interest) not in ["", "nan", "None"]:
                            year_frac = conventions.D_day_count(
                                np.array(Valuation_Date[0], dtype="datetime64[D]"),
                                np.array(moratorium_end_date, dtype="datetime64[D]"),
                                accrual_convention_code,
                                custom_daycount_conventions=custom_daycount_conventions,
                            )
                            if moratorium_interest_calculation_methodology == "Simple":
                                moratorium_interest = (
                                    outstanding_amount * (base_rate + fixed_spread) * year_frac
                                )
                            else:
                                compounding_frequency = row[column_index_dict["compounding_frequency"]]
                                compounding_frequency_unit = row[
                                    column_index_dict["compounding_frequency_unit"]
                                ]

                                moratorium_interest = compound_interest_calculation_formula(
                                    compounding_frequency,
                                    compounding_frequency_unit,
                                    year_frac,
                                    outstanding_amount + accrued_interest,
                                    base_rate + fixed_spread,
                                )
                            total_interest_capitalization = accrued_interest + moratorium_interest
                        else:
                            year_frac = conventions.D_day_count(
                                np.array(issue_date[0], dtype="datetime64[D]"),
                                np.array(moratorium_end_date, dtype="datetime64[D]"),
                                accrual_convention_code,
                                custom_daycount_conventions=custom_daycount_conventions,
                            )
                            if moratorium_interest_calculation_methodology == "Simple":
                                total_interest_capitalization = (
                                    outstanding_amount * (base_rate + fixed_spread) * year_frac
                                )
                            else:
                                compounding_frequency = row[column_index_dict["compounding_frequency"]]
                                compounding_frequency_unit = row[
                                    column_index_dict["compounding_frequency_unit"]
                                ]
                                total_interest_capitalization = compound_interest_calculation_formula(
                                    compounding_frequency,
                                    compounding_frequency_unit,
                                    year_frac,
                                    outstanding_amount,
                                    base_rate + fixed_spread,
                                )

                        outstanding_amount = outstanding_amount + total_interest_capitalization
                        accrued_interest = [0]
                    else:
                        if str(accrued_interest) in ["", "nan", "None"]:
                            if (
                                str(last_payment_date) not in ["nan", "NaT", "None", "-"]
                                and last_payment_date >= moratorium_end_date
                            ):
                                year_frac = conventions.D_day_count(
                                    np.array(last_payment_date, dtype="datetime64[D]"),
                                    np.array(Valuation_Date[0], dtype="datetime64[D]"),
                                    accrual_convention_code,
                                    custom_daycount_conventions=custom_daycount_conventions,
                                )
                                accrued_interest = outstanding_amount * (base_rate + fixed_spread) * year_frac
                            else:
                                year_frac_post_moratorium = conventions.D_day_count(
                                    np.array(moratorium_end_date, dtype="datetime64[D]"),
                                    np.array(Valuation_Date[0], dtype="datetime64[D]"),
                                    accrual_convention_code,
                                    custom_daycount_conventions=custom_daycount_conventions,
                                )
                                accrued_interest = (
                                    outstanding_amount
                                    * (base_rate + fixed_spread)
                                    * year_frac_post_moratorium
                                )

        # # # # # # # # # #
        valuation_results, sensitivity_analysis, pv_principal, measure_value = [], [], [], []
        if cashflow_uploaded_data is not None and len(cashflow_uploaded_data) > 0:
            cashflow_uploaded_data_position = cashflow_uploaded_data.loc[
                cashflow_uploaded_data["position_id"] == Position_Id
            ]
        else:
            cashflow_uploaded_data_position = pd.DataFrame()
        if len(cashflow_uploaded_data_position) > 0:
            cashflow_upload = True
            accrued_interest = cashflow_uploaded_data_position.loc[
                cashflow_uploaded_data_position["cashflow_type"] == "Accrued Interest", "cashflow"
            ]
            if len(accrued_interest) > 0:
                accrued_interest = np.array([accrued_interest.iloc[0]], dtype="float")
                accrued_interest_ttm = cashflow_uploaded_data_position.loc[
                    cashflow_uploaded_data_position["cashflow_type"] == "Accrued Interest", "time_to_maturity"
                ].iloc[0]
            else:
                accrued_interest = None
                accrued_interest_ttm = None
            cashflow_uploaded_data_position = cashflow_uploaded_data_position.loc[
                cashflow_uploaded_data_position["cashflow_type"] != "Accrued Interest"
            ]
            cashflow_model_results = cashflow_uploaded_data_position.copy()
            cashflow_uploaded_data_position["coupons"] = np.where(
                cashflow_uploaded_data_position["cashflow_type"] == "Interest Proceeds",
                cashflow_uploaded_data_position["cashflow"],
                0,
            )
            cashflow_uploaded_data_position["principal"] = np.where(
                cashflow_uploaded_data_position["cashflow_type"] == "Principal Amount",
                cashflow_uploaded_data_position["cashflow"],
                0,
            )
            coupons = cashflow_uploaded_data_position["coupons"].to_numpy()
            principal = cashflow_uploaded_data_position["principal"].to_numpy()
            total_amount = cashflow_uploaded_data_position["cashflow"].to_numpy()
            cashflow_model_results[["cashflow_status", "discount_factor", "present_value"]] = [
                cashflow_status,
                "",
                "",
            ]
            ttm = cashflow_model_results["time_to_maturity"].to_numpy()
            del cashflow_uploaded_data_position
        else:
            cashflow_upload = False

            cashflow_results_output = valuation_models.fixed_coupon_cashflow_generation(
                Unique_Reference_Id,
                issue_date,
                maturity_date,
                outstanding_amount,
                outstanding_amount,
                interest_rate,
                payment_frequency,
                payment_frequency_unit,
                Valuation_Date,
                discount_daycount,
                accrual_daycount,
                discount_curve,
                business_day_convention,
                last_payment_date,
                holiday_calendar,
                custom_daycount_conventions,
                accrued_interest,
                interest_calculation_methodology,
                compounding_frequency,
                compounding_frequency_unit,
                stub_date=stub_date,
                business_days=business_days,
                moratorium_end_date=moratorium_end_date,
                moratorium_flag=moratorium_flag,
                interest_moratorium_flag=interest_moratorium_flag,
            )
            accrued_interest = cashflow_results_output[7]
            total_amount = cashflow_results_output[6]
            cashflow_model_results = {
                "extract_date": Valuation_Date[0],
                "transaction_date": cashflow_results_output[2],
                "unique_reference_id": Unique_Reference_Id,
                "reference_dimension": reference_dimension,
                "cashflow_type": "Interest Proceeds",
                "cashflow_status": cashflow_status,
                "cashflow": cashflow_results_output[4],
                "time_to_maturity": cashflow_results_output[3],
                "discount_factor": None,
                "present_value": None,
                "currency": currency,
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": None,
                "entity": entity,
            }
            cashflow_model_results = pd.DataFrame(cashflow_model_results)
            accrued_interest_ttm = cashflow_model_results["time_to_maturity"].iloc[0]
            cashflow_model_results, dpd_cashflows = overdue_cashflow_calculations(
                Position_Id,
                cashflow_model_results,
                dpd_schedule,
                dpd_ruleset,
                overdue_bucketing_data,
                Valuation_Date,
                Unique_Reference_Id,
                reference_dimension,
                cashflow_status,
                currency,
                asset_liability_type,
                product_variant_name,
                fund,
                portfolio,
                entity,
                interest_overdue,
                principal_overdue,
                charges_overdue,
            )
            if len(dpd_cashflows) > 0:
                total_amount_dpd = dpd_cashflows["cashflow"].to_numpy(dtype="float")
                total_amount = np.append(total_amount, total_amount_dpd)
            coupons = cashflow_model_results["cashflow"].to_numpy()
            ttm = cashflow_model_results["time_to_maturity"].to_numpy()

        cashflow_model_results = cashflow_model_results.astype(
            {"time_to_maturity": "float64", "cashflow": "float64", "transaction_date": "datetime64[ns]"}
        )
        output_msg = output_check_fn(
            cashflow_results=cashflow_model_results[cashflow_model_results["time_to_maturity"] != 0]
        )
        if output_msg["CF_Output"] == "Present":
            if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
                zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == discount_curve), :]
                interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
                extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[0]
                tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                zero_rates = np.empty([0], dtype="float64")
                measure_run_date_time_now = datetime.now()
                for j in range(len(ttm)):
                    if interpolation_algorithm == "Linear":
                        if linearinterp(tenor, rates, ttm[j]) is None:
                            if extrapolation_algorithm == "Linear":
                                extrapolated_value = linearexterp(tenor, rates, ttm[j])
                            else:
                                extrapolated_value = flatexterp(tenor, rates, ttm[j])
                            zero_rates = np.append(zero_rates, extrapolated_value)
                        else:
                            interpolated_value = linearinterp(tenor, rates, ttm[j])
                            zero_rates = np.append(zero_rates, interpolated_value)
                if str(credit_spread_rate) not in ["nan", "None"]:
                    zero_rates = zero_rates + float(credit_spread_rate)
                elif str(credit_spread_curve) not in ["nan", "None"]:
                    credit_spread_curve_data = credit_spread_data.loc[
                        (credit_spread_data["credit_spread_curve_name"] == credit_spread_curve), :
                    ]
                    if len(credit_spread_curve_data) > 0:
                        spread_tenor = np.array(credit_spread_curve_data.tenor.tolist())
                        spread_tenor_unit = np.array(credit_spread_curve_data.tenor_unit.tolist())
                        cs_interpolation_algorithm = credit_spread_curve_data["interpolation_algorithm"].iloc[
                            0
                        ]
                        cs_extrapolation_algorithm = credit_spread_curve_data["extrapolation_algorithm"].iloc[
                            0
                        ]
                        tenor_extrac = np.vectorize(tenor_extraction)
                        spread_tenor = tenor_extrac(spread_tenor, spread_tenor_unit)
                        spread_rates = np.array(credit_spread_curve_data.spread_value.tolist())

                        credit_spread_rates = np.empty([0], dtype="float64")
                        for j in range(len(ttm)):
                            if linearinterp(spread_tenor, spread_rates, ttm[j]) is None:
                                if cs_extrapolation_algorithm == "Linear":
                                    calculated_value = linearexterp(spread_tenor, spread_rates, ttm[j])
                                else:
                                    calculated_value = flatexterp(spread_tenor, spread_rates, ttm[j])
                            else:
                                calculated_value = linearinterp(spread_tenor, spread_rates, ttm[j])
                            credit_spread_rates = np.append(credit_spread_rates, calculated_value)
                        zero_rates = zero_rates + credit_spread_rates

                (
                    pv_output,
                    pv_table,
                    ttm_array,
                    total_amount_array,
                    df,
                    pv_coupons,
                    pv_principal,
                    PV_plus_1bps,
                    PV_minus_1bps,
                ) = fixed_income_valuation(
                    ttm,
                    total_amount,
                    zero_rates,
                    coupons,
                    coupons,
                    curve_compounding_frequency=curve_compounding_frequency,
                )
                cashflow_model_results["discount_factor"] = df
                if not cashflow_upload:
                    cashflow_model_results["present_value"] = pv_coupons
                else:
                    cashflow_model_results["present_value"] = pv_table

                output_msg = output_check_fn(valuation_output=pv_output)

                if output_msg["Val_Output"] == "Present":
                    valuation_output = {
                        "PV": round(pv_output, 4),
                    }
                    measure_dict_val = {
                        "measure_run_date": measure_run_date_time_now,
                        "valuation_date": Valuation_Date[0],
                        "unique_reference_id": Unique_Reference_Id,
                        "position_id": Position_Id,
                        "reference_dimension": reference_dimension,
                        "measure_type": "Fair Value per unit",
                        "measure_value": round(pv_output, 4),
                        "absolute_relative": "Absolute",
                        "residual_maturity": ttm[-1],
                        "asset_liability_type": asset_liability_type,
                        "product_variant_name": product_variant_name,
                        "fund": fund,
                        "portfolio": portfolio,
                        "cohort": "",
                        "entity": entity,
                    }
                    measure_dict_val_position = {
                        "measure_run_date": measure_run_date_time_now,
                        "valuation_date": Valuation_Date[0],
                        "unique_reference_id": Unique_Reference_Id,
                        "position_id": Position_Id,
                        "reference_dimension": reference_dimension,
                        "measure_type": "Fair Value",
                        "measure_value": round(pv_output * Quantity, 4),
                        "absolute_relative": "Absolute",
                        "residual_maturity": ttm_array[-1],
                        "asset_liability_type": asset_liability_type,
                        "product_variant_name": product_variant_name,
                        "fund": fund,
                        "portfolio": portfolio,
                        "cohort": "",
                        "entity": entity,
                    }
                    measure_value.append(measure_dict_val)
                    measure_value.append(measure_dict_val_position)
                    valuation_results.append(valuation_output)
                    total_holding = Quantity * valuation_results[0]["PV"]

                    if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":
                        if fixed_float_flag == "Float":
                            cashflow_model_results["zero_rates"] = zero_rates
                            interest_date_reset_check = cashflow_model_results.loc[
                                (cashflow_model_results["transaction_date"] == next_reset_date)
                                & (cashflow_model_results["cashflow_type"] == "Interest Proceeds")
                            ]
                            principal_date_check = cashflow_model_results.loc[
                                (
                                    cashflow_model_results["cashflow_type"].isin(
                                        ["Principal Amount", "Redemption Proceeds", "Principal Proceeds"]
                                    )
                                )
                            ]
                            reset_filterered_df = cashflow_model_results.loc[
                                (
                                    cashflow_model_results["cashflow_type"].isin(
                                        ["Principal Amount", "Redemption Proceeds", "Principal Proceeds"]
                                    )
                                )
                                | (
                                    (
                                        cashflow_model_results["cashflow_type"].isin(
                                            [
                                                "Interest Proceeds",
                                                "Charges Overdue",
                                                "Interest Overdue",
                                                "Principal Overdue",
                                            ]
                                        )
                                    )
                                    & (cashflow_model_results["transaction_date"] <= next_reset_date)
                                )
                            ]

                            if len(principal_date_check) == 0:
                                reset_df_principal = cashflow_model_results.loc[
                                    (cashflow_model_results["cashflow_type"] == "Interest Proceeds")
                                ].head(1)
                                reset_df_principal["cashflow_type"] = "Principal Amount"
                                reset_df_principal["cashflow"] = outstanding_amount
                                reset_filterered_df = pd.concat(
                                    [reset_filterered_df, reset_df_principal], ignore_index=True
                                )

                            reset_filterered_df.loc[
                                (
                                    reset_filterered_df["cashflow_type"].isin(
                                        ["Principal Amount", "Redemption Proceeds", "Principal Proceeds"]
                                    )
                                ),
                                "transaction_date",
                            ] = next_reset_date
                            reset_maturity = conventions.A_day_count(
                                Valuation_Date[0],
                                next_reset_date,
                                discount_convention_code,
                                custom_daycount_conventions=custom_daycount_conventions,
                            )
                            reset_filterered_df.loc[
                                (
                                    reset_filterered_df["cashflow_type"].isin(
                                        ["Principal Amount", "Redemption Proceeds", "Principal Proceeds"]
                                    )
                                ),
                                "time_to_maturity",
                            ] = reset_maturity

                            if len(interest_date_reset_check) == 0:
                                interest_till_reset_dict = reset_filterered_df.loc[
                                    (
                                        reset_filterered_df["cashflow_type"].isin(
                                            ["Principal Amount", "Redemption Proceeds", "Principal Proceeds"]
                                        )
                                    )
                                ].to_dict("records")
                                previous_payment_date = cashflow_model_results.loc[
                                    (cashflow_model_results["transaction_date"] < next_reset_date)
                                    & (cashflow_model_results["cashflow_type"] == "Interest Proceeds")
                                ]
                                if len(previous_payment_date) > 0:
                                    previous_payment_date_val = np.datetime64(
                                        previous_payment_date["transaction_date"].max()
                                    )
                                else:
                                    previous_payment_date_val = last_payment_date

                                year_frac = conventions.A_day_count(
                                    previous_payment_date_val,
                                    next_reset_date,
                                    accrual_convention_code,
                                    custom_daycount_conventions=custom_daycount_conventions,
                                )
                                interest_cashflow = outstanding_amount * year_frac * interest_rate
                                interest_till_reset_dict[0]["cashflow"] = interest_cashflow
                                reset_filterered_df = pd.concat(
                                    [reset_filterered_df, pd.DataFrame(interest_till_reset_dict)],
                                    ignore_index=True,
                                )

                            reset_zero_rate = linearinterp(tenor, rates, reset_maturity)
                            if reset_zero_rate is None:
                                if extrapolation_algorithm == "Linear":
                                    reset_zero_rate = linearexterp(tenor, rates, reset_maturity)
                                else:
                                    reset_zero_rate = flatexterp(tenor, rates, reset_maturity)
                            if str(credit_spread_rate) not in ["nan", "None"]:
                                reset_zero_rate = reset_zero_rate + float(credit_spread_rate)
                            elif str(credit_spread_curve) not in ["nan", "None"]:
                                if not credit_spread_curve_data.empty:
                                    reset_credit_spread = linearinterp(
                                        spread_tenor, spread_rates, reset_maturity
                                    )
                                    if reset_credit_spread is None:
                                        if cs_extrapolation_algorithm == "Linear":
                                            reset_credit_spread = linearexterp(
                                                spread_tenor, spread_rates, reset_maturity
                                            )
                                        else:
                                            reset_credit_spread = flatexterp(
                                                spread_tenor, spread_rates, reset_maturity
                                            )
                                        credit_spread_rates = np.append(
                                            credit_spread_rates, reset_credit_spread
                                        )
                                    reset_zero_rate = reset_zero_rate + reset_credit_spread

                            reset_filterered_df.loc[
                                reset_filterered_df["transaction_date"] == next_reset_date, "zero_rates"
                            ] = reset_zero_rate

                            (
                                PV_output_sens,
                                PV_table_sens,
                                TTM_array_sens,
                                Total_amount_array_sens,
                                DF_sens,
                                PV_coupons_sens,
                                PV_principal_sens,
                                PV_plus_1bps_sens,
                                PV_minus_1bps_sens,
                            ) = fixed_income_valuation(
                                (reset_filterered_df["time_to_maturity"].to_numpy()).astype("float64"),
                                (reset_filterered_df["cashflow"].to_numpy()).astype("float64"),
                                (reset_filterered_df["zero_rates"].to_numpy()).astype("float64"),
                                (reset_filterered_df["cashflow"].to_numpy()).astype("float64"),
                                (reset_filterered_df["cashflow"].to_numpy()).astype("float64"),
                                curve_compounding_frequency=curve_compounding_frequency,
                            )
                            (
                                pv01,
                                macaulay_duration,
                                modified_duration,
                                effective_duration,
                                ytm,
                            ) = valuation_models.fixed_income_sensitivity_analysis(
                                PV_table_sens,
                                TTM_array_sens,
                                Total_amount_array_sens,
                                payment_frequency,
                                payment_frequency_unit,
                                PV_output_sens,
                                PV_plus_1bps_sens,
                                PV_minus_1bps_sens,
                            )
                        else:
                            (
                                pv01,
                                macaulay_duration,
                                modified_duration,
                                effective_duration,
                                ytm,
                            ) = valuation_models.fixed_income_sensitivity_analysis(
                                pv_table,
                                ttm_array,
                                total_amount_array,
                                payment_frequency,
                                payment_frequency_unit,
                                pv_output,
                                PV_plus_1bps,
                                PV_minus_1bps,
                            )

                        sensitivity_analysis.append(
                            {
                                "Macaulay Duration": macaulay_duration,
                                "Effective Duration": effective_duration,
                                "Modified Duration": modified_duration,
                                "PV01 per unit": pv01,
                            }
                        )
                        if isinstance(ytm, (np.ndarray)):
                            ytm = ytm[0]
                        else:
                            ytm = ytm
                        measure_dict_ytm = {
                            "measure_run_date": measure_run_date_time_now,
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Yield to Maturity",
                            "measure_value": ytm,
                            "absolute_relative": "Absolute",
                            "residual_maturity": ttm_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_ytm)
                        measure_dict_mac_dur = {
                            "measure_run_date": measure_run_date_time_now,
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Macaulay Duration",
                            "measure_value": macaulay_duration,
                            "absolute_relative": "Absolute",
                            "residual_maturity": ttm_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_mac_dur)
                        measure_dict_eff_dur = {
                            "measure_run_date": measure_run_date_time_now,
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Effective Duration",
                            "measure_value": effective_duration,
                            "absolute_relative": "Relative",
                            "residual_maturity": ttm_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_eff_dur)
                        measure_dict_mod_dur = {
                            "measure_run_date": measure_run_date_time_now,
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Modified Duration",
                            "measure_value": modified_duration,
                            "absolute_relative": "Relative",
                            "residual_maturity": ttm_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_mod_dur)
                        measure_dict_pv01 = {
                            "measure_run_date": measure_run_date_time_now,
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "PV01 per unit",
                            "measure_value": pv01,
                            "absolute_relative": "Absolute",
                            "residual_maturity": ttm_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_pv01)
                        measure_dict_pv01_position = {
                            "measure_run_date": measure_run_date_time_now,
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "PV01",
                            "measure_value": pv01 * Quantity,
                            "absolute_relative": "Absolute",
                            "residual_maturity": ttm_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_pv01_position)

                else:
                    valuation_output = {
                        "PV": "None",
                    }
                    total_holding = "None"
                    valuation_results.append(valuation_output)

            else:
                sensitivity_analysis.append(
                    {
                        "Macaulay_Duration": "-",
                        "Effective Duration": "-",
                        "Modified_Duration": "-",
                        "PV01 per unit": "-",
                    }
                )
                valuation_output = {
                    "PV": "None",
                }
                total_holding = "None"
                valuation_results.append(valuation_output)

        else:
            sensitivity_analysis.append(
                {
                    "Macaulay_Duration": "-",
                    "Effective Duration": "-",
                    "Modified_Duration": "-",
                    "PV01 per unit": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)
        cashflow_model_results = cashflow_model_results.sort_values(by=["transaction_date", "cashflow_type"])
        if not cashflow_upload:
            cashflow_model_results = pd.concat(
                [cashflow_model_results, cashflow_model_results.iloc[[-1]]], ignore_index=True
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow")] = (
                outstanding_amount
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow_type")] = (
                "Principal Amount"
            )
            if len(pv_principal) > 0:
                cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("present_value")] = (
                    cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow")]
                    * cashflow_model_results.iloc[
                        -1, cashflow_model_results.columns.get_loc("discount_factor")
                    ]
                )
        cashflow_model_results["unique_reference_id"] = Unique_Reference_Id
        cashflow_model_results["position_id"] = Position_Id

        if str(accrued_interest[0]) not in ["", "0", "0.0", "None", "nan"]:
            cashflow_model_results = pd.concat(
                [cashflow_model_results, cashflow_model_results.iloc[[-1]]], ignore_index=True
            )
            if str(Quantity) in ["", "nan", "None"]:
                Quantity = 1
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow")] = (
                accrued_interest[0] * Quantity
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow_type")] = (
                "Accrued Interest"
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("transaction_date")] = (
                pd.to_datetime(Valuation_Date[0])
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("present_value")] = None
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("time_to_maturity")] = (
                accrued_interest_ttm
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("discount_factor")] = None
            cashflow_model_results = cashflow_model_results.sort_values(
                by=["transaction_date", "cashflow_type"], ascending=True
            )

        if "zero_rates" in cashflow_model_results.columns.tolist():
            cashflow_model_results.drop(columns=["zero_rates"], inplace=True)

        final_output_dict["Unique_Reference_ID"] = Unique_Reference_Id
        final_output_dict["Position_Id"] = Position_Id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = Valuation_Date[0]
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Quantity"] = Quantity
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        measure_value = pd.DataFrame(measure_value)
        measure_value["currency"] = currency
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] in ["M019", "M046"]:
        final_output_dict = {}
        unique_reference_Id = row[column_index_dict["unique_reference_id"]]
        position_id = row[column_index_dict["position_id"]]
        issue_date = np.array(row[column_index_dict["issue_date"]], dtype="datetime64[D]")
        accrual_daycount = row[column_index_dict["accrual_daycount_convention"]]
        discount_daycount = row[column_index_dict["discount_daycount_convention"]]
        business_day_convention = np.array([row[column_index_dict["business_convention"]]])
        last_payment_date = row[column_index_dict["last_payment_date"]]
        if str(last_payment_date) not in ["nan", "NaT", "None", "-"]:
            last_payment_date = np.datetime64(row[column_index_dict["last_payment_date"]], "D")
        stub_date = row[column_index_dict["stub_date"]]
        if str(stub_date) not in ["nan", "NaT", "None", "-"]:
            stub_date = np.datetime64(row[column_index_dict["stub_date"]], "D")
        accrual_convention_code = valuation_models.daycount_convention_code(accrual_daycount)
        discount_curve = row[column_index_dict["discounting_curve"]]
        product_variant_name = row[column_index_dict["product_variant_name"]]
        fund = row[column_index_dict["fund_code"]]
        portfolio = row[column_index_dict["pool_id"]]
        entity = row[column_index_dict["legal_entity"]]
        interest_calculation_methodology = row[column_index_dict["interest_calculation_methodology"]]
        compounding_frequency = row[column_index_dict["compounding_frequency"]]
        compounding_frequency_unit = row[column_index_dict["compounding_frequency_unit"]]
        if str(row[column_index_dict["next_payment_date"]]) not in ["nan", "None", "NaT", ""]:
            next_payment_date = np.array(row[column_index_dict["next_payment_date"]], dtype="datetime64[D]")
        else:
            next_payment_date = ""
        payment_frequency = row[column_index_dict["payment_frequency"]]
        payment_frequency_unit = row[column_index_dict["payment_frequency_units"]]
        base_rate = float(row[column_index_dict["base_rate"]]) / 100
        if str(row[column_index_dict["fixed_spread"]]) not in ["", "nan", "None"]:
            fixed_spread = float(row[column_index_dict["fixed_spread"]]) / 100
        else:
            fixed_spread = 0
        interest_rate = base_rate + fixed_spread
        accrued_interest = row[column_index_dict["accrued_interest"]]
        if str(accrued_interest) not in ["nan", "None", ""]:
            accrued_interest = np.array([float(accrued_interest / Quantity)], dtype="float")
        outstanding_amount = np.array([float(row[column_index_dict["outstanding_amount"]])])
        maturity_date = np.array([pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True)])
        quantity = float(row[column_index_dict["quantity"]])
        credit_spread_rate = row[column_index_dict["credit_spread_rate"]]
        credit_spread_curve = row[column_index_dict["credit_spread_curve"]]
        asset_liability_type = row[column_index_dict["asset_liability_type"]]
        # # # # # # # # # #
        valuation_results, sensitivity_analysis, pv_principal, measure_value = [], [], [], []
        # # # # # # # # # # # # # #
        if cashflow_uploaded_data is not None and len(cashflow_uploaded_data) > 0:
            cashflow_uploaded_data_position = cashflow_uploaded_data.loc[
                cashflow_uploaded_data["position_id"] == Position_Id
            ]
        else:
            cashflow_uploaded_data_position = pd.DataFrame()
        if len(cashflow_uploaded_data_position) > 0:
            cashflow_upload = True
            accrued_interest = cashflow_model_results.loc[
                cashflow_model_results["cashflow_type"] == "Accrued Interest", "cashflow"
            ]
            if len(accrued_interest) > 0:
                accrued_interest = np.array([accrued_interest.iloc[0]], dtype="float")
            else:
                accrued_interest = None
            cashflow_model_results = cashflow_model_results.loc[
                cashflow_model_results["cashflow_type"] != "Accrued Interest"
            ]
            cashflow_model_results = cashflow_uploaded_data_position.copy()
            cashflow_uploaded_data_position["coupons"] = np.where(
                cashflow_uploaded_data_position["cashflow_type"] == "Interest Proceeds",
                cashflow_uploaded_data_position["cashflow"],
                0,
            )
            cashflow_uploaded_data_position["principal"] = np.where(
                cashflow_uploaded_data_position["cashflow_type"] == "Principal Amount",
                cashflow_uploaded_data_position["cashflow"],
                0,
            )
            coupons = cashflow_uploaded_data_position["coupons"].to_numpy()
            principal = cashflow_uploaded_data_position["principal"].to_numpy()
            total_amount = cashflow_uploaded_data_position["cashflow"].to_numpy()
            cashflow_model_results[["cashflow_status", "discount_factor", "present_value"]] = [
                cashflow_status,
                "",
                "",
            ]
            del cashflow_uploaded_data_position
        else:
            cashflow_upload = False
            cashflow_results_output = valuation_models.fixed_coupon_cashflow_generation(
                Unique_Reference_Id,
                issue_date,
                maturity_date,
                outstanding_amount,
                outstanding_amount,
                interest_rate,
                payment_frequency,
                payment_frequency_unit,
                Valuation_Date,
                discount_daycount,
                accrual_daycount,
                discount_curve,
                business_day_convention,
                last_payment_date,
                holiday_calendar,
                custom_daycount_conventions,
                accrued_interest,
                interest_calculation_methodology,
                compounding_frequency,
                compounding_frequency_unit,
                stub_date=stub_date,
                business_days=business_days,
                model_code=row[column_index_dict["model_code"]],
            )
            coupons = cashflow_results_output[4]
            total_amount = cashflow_results_output[6]
            principal = cashflow_results_output[5]
            accrued_interest = cashflow_results_output[7]
            cashflow_model_results = {
                "extract_date": Valuation_Date[0],
                "transaction_date": cashflow_results_output[2],
                "unique_reference_id": Unique_Reference_Id,
                "reference_dimension": reference_dimension,
                "cashflow_type": "Interest Proceeds",
                "cashflow_status": cashflow_status,
                "cashflow": cashflow_results_output[4],
                "time_to_maturity": cashflow_results_output[3],
                "discount_factor": None,
                "present_value": None,
                "currency": currency,
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": None,
                "entity": entity,
            }
            cashflow_model_results = pd.DataFrame(cashflow_model_results)

        cashflow_model_results = cashflow_model_results.astype(
            {"time_to_maturity": "float64", "cashflow": "float64", "transaction_date": "datetime64[ns]"}
        )
        output_msg = output_check_fn(
            cashflow_results=cashflow_model_results[cashflow_model_results["time_to_maturity"] != 0]
        )
        if output_msg["CF_Output"] == "Present":

            if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
                ttm = np.array(cashflow_model_results["time_to_maturity"], dtype="float64")
                cashflow_status = cashflow_model_results["cashflow_status"]
                zero_rate_curve = discount_curve
                zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
                interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
                extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[0]
                tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                zero_rates = np.empty([0], dtype="float64")
                measure_run_date_strftime = datetime.now()
                for j in range(len(ttm)):
                    if interpolation_algorithm == "Linear":
                        if linearinterp(tenor, rates, ttm[j]) is None:
                            if extrapolation_algorithm == "Linear":
                                extrapolated_value = linearexterp(tenor, rates, ttm[j])
                            else:
                                extrapolated_value = flatexterp(tenor, rates, ttm[j])
                            zero_rates = np.append(zero_rates, extrapolated_value)
                        else:
                            interpolated_value = linearinterp(tenor, rates, ttm[j])
                            zero_rates = np.append(zero_rates, interpolated_value)

                if str(credit_spread_rate) not in ["nan", "None"]:
                    zero_rates = zero_rates + float(credit_spread_rate)
                elif str(credit_spread_curve) not in ["nan", "None"]:
                    credit_spread_curve_data = credit_spread_data.loc[
                        (credit_spread_data["credit_spread_curve_name"] == credit_spread_curve), :
                    ]
                    if len(credit_spread_curve_data) > 0:
                        spread_tenor = np.array(credit_spread_curve_data.tenor.tolist())
                        spread_tenor_unit = np.array(credit_spread_curve_data.tenor_unit.tolist())
                        cs_interpolation_algorithm = credit_spread_curve_data["interpolation_algorithm"].iloc[
                            0
                        ]
                        cs_extrapolation_algorithm = credit_spread_curve_data["extrapolation_algorithm"].iloc[
                            0
                        ]
                        tenor_extrac = np.vectorize(tenor_extraction)
                        spread_tenor = tenor_extrac(spread_tenor, spread_tenor_unit)
                        spread_rates = np.array(credit_spread_curve_data.spread_value.tolist())
                        credit_spread_rates = np.empty([0], dtype="float64")
                        for j in range(len(ttm)):
                            if linearinterp(spread_tenor, spread_rates, ttm[j]) is None:
                                if cs_extrapolation_algorithm == "Linear":
                                    calculated_value = linearexterp(spread_tenor, spread_rates, ttm[j])
                                else:
                                    calculated_value = flatexterp(spread_tenor, spread_rates, ttm[j])
                            else:
                                calculated_value = linearinterp(spread_tenor, spread_rates, ttm[j])
                            credit_spread_rates = np.append(credit_spread_rates, calculated_value)
                        zero_rates = zero_rates + credit_spread_rates

                (
                    pv_output,
                    pv_table,
                    ttm_array,
                    total_amount_array,
                    df,
                    pv_coupons,
                    pv_principal,
                    PV_plus_1bps,
                    PV_minus_1bps,
                ) = fixed_income_valuation(
                    ttm,
                    total_amount,
                    zero_rates,
                    coupons,
                    principal,
                    curve_compounding_frequency=curve_compounding_frequency,
                )

                cashflow_model_results["discount_factor"] = df
                if not cashflow_upload:
                    cashflow_model_results["present_value"] = pv_coupons
                else:
                    cashflow_model_results["present_value"] = pv_table
                output_msg = output_check_fn(valuation_output=pv_output)
                if output_msg["Val_Output"] == "Present":
                    valuation_output = {
                        "PV": round(pv_output, 4),
                    }
                    measure_dict_val = {
                        "measure_run_date": measure_run_date_strftime,
                        "valuation_date": Valuation_Date[0],
                        "unique_reference_id": Unique_Reference_Id,
                        "position_id": Position_Id,
                        "reference_dimension": reference_dimension,
                        "measure_type": "Fair Value per unit",
                        "measure_value": round(pv_output, 4),
                        "absolute_relative": "Absolute",
                        "residual_maturity": ttm[-1],
                        "asset_liability_type": asset_liability_type,
                        "product_variant_name": product_variant_name,
                        "fund": fund,
                        "portfolio": portfolio,
                        "cohort": "",
                        "entity": entity,
                    }
                    measure_dict_val_position = {
                        "measure_run_date": measure_run_date_strftime,
                        "valuation_date": Valuation_Date[0],
                        "unique_reference_id": Unique_Reference_Id,
                        "position_id": Position_Id,
                        "reference_dimension": reference_dimension,
                        "measure_type": "Fair Value",
                        "measure_value": round(pv_output * quantity, 4),
                        "absolute_relative": "Absolute",
                        "residual_maturity": ttm_array[-1],
                        "asset_liability_type": asset_liability_type,
                        "product_variant_name": product_variant_name,
                        "fund": fund,
                        "portfolio": portfolio,
                        "cohort": "",
                        "entity": entity,
                    }
                    measure_value.append(measure_dict_val)
                    measure_value.append(measure_dict_val_position)
                    valuation_results.append(valuation_output)
                    total_holding = quantity * valuation_results[0]["PV"]
                    if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":
                        if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                            (
                                pv01,
                                macaulay_duration,
                                modified_duration,
                                effective_duration,
                                ytm,
                            ) = valuation_models.fixed_income_sensitivity_analysis(
                                pv_table,
                                ttm_array,
                                total_amount_array,
                                1,
                                "Y",
                                pv_output,
                                PV_plus_1bps,
                                PV_minus_1bps,
                            )
                            sensitivity_analysis.append(
                                {
                                    "Macaulay Duration": macaulay_duration,
                                    "Effective Duration": effective_duration,
                                    "Modified Duration": modified_duration,
                                    "PV01 per unit": pv01,
                                }
                            )
                            if isinstance(ytm, (np.ndarray)):
                                ytm = ytm[0]
                            else:
                                ytm = ytm
                            measure_dict_ytm = {
                                "measure_run_date": measure_run_date_strftime,
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Yield to Maturity",
                                "measure_value": ytm,
                                "absolute_relative": "Absolute",
                                "residual_maturity": ttm_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_ytm)
                            measure_dict_mac_dur = {
                                "measure_run_date": measure_run_date_strftime,
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Macaulay Duration",
                                "measure_value": macaulay_duration,
                                "absolute_relative": "Absolute",
                                "residual_maturity": ttm_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mac_dur)
                            measure_dict_eff_dur = {
                                "measure_run_date": measure_run_date_strftime,
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Effective Duration",
                                "measure_value": effective_duration,
                                "absolute_relative": "Relative",
                                "residual_maturity": ttm_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_eff_dur)
                            measure_dict_mod_dur = {
                                "measure_run_date": measure_run_date_strftime,
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Modified Duration",
                                "measure_value": modified_duration,
                                "absolute_relative": "Relative",
                                "residual_maturity": ttm_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mod_dur)
                            measure_dict_pv01 = {
                                "measure_run_date": measure_run_date_strftime,
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01 per unit",
                                "measure_value": pv01,
                                "absolute_relative": "Absolute",
                                "residual_maturity": ttm_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01)
                            measure_dict_pv01_position = {
                                "measure_run_date": measure_run_date_strftime,
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01",
                                "measure_value": pv01 * quantity,
                                "absolute_relative": "Absolute",
                                "residual_maturity": ttm_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01_position)

                else:
                    valuation_output = {
                        "PV": "None",
                    }
                    total_holding = "None"
                    valuation_results.append(valuation_output)

            else:
                sensitivity_analysis.append(
                    {
                        "Macaulay_Duration": "-",
                        "Effective Duration": "-",
                        "Modified_Duration": "-",
                        "PV01 per unit": "-",
                    }
                )
                valuation_output = {
                    "PV": "None",
                }
                total_holding = "None"
                valuation_results.append(valuation_output)

        else:
            sensitivity_analysis.append(
                {
                    "Macaulay_Duration": "-",
                    "Effective Duration": "-",
                    "Modified_Duration": "-",
                    "PV01 per unit": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)
        if not cashflow_upload:
            cashflow_model_results = pd.concat(
                [cashflow_model_results, cashflow_model_results.iloc[[-1]]], ignore_index=True
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow")] = (
                outstanding_amount
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow_type")] = (
                "Principal Amount"
            )
            if len(pv_principal) > 0:
                cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("present_value")] = (
                    pv_principal[-1]
                )
        cashflow_model_results["unique_reference_id"] = Unique_Reference_Id
        cashflow_model_results["position_id"] = Position_Id

        if str(accrued_interest[0]) not in ["", "0.0", "None", "nan"]:
            cashflow_model_results = pd.concat(
                [cashflow_model_results, cashflow_model_results.iloc[[-1]]], ignore_index=True
            )
            if str(Quantity) in ["", "None", "nan"]:
                Quantity = 1
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow")] = (
                accrued_interest[0] * Quantity
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow_type")] = (
                "Accrued Interest"
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("transaction_date")] = (
                pd.to_datetime(Valuation_Date[0])
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("present_value")] = None
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("time_to_maturity")] = (
                cashflow_model_results["time_to_maturity"].iloc[0]
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("discount_factor")] = None
            cashflow_model_results = cashflow_model_results.sort_values(
                by=["transaction_date", "cashflow_type"], ascending=True
            )

        final_output_dict["Unique_Reference_ID"] = unique_reference_Id
        final_output_dict["Position_Id"] = position_id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = pd.to_datetime(Valuation_Date[0])
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Quantity"] = quantity
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        measure_value = pd.DataFrame(measure_value)
        measure_value["currency"] = currency
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] == "M020":
        final_output_dict = {}
        unique_reference_Id = row[column_index_dict["unique_reference_id"]]
        issue_date = np.array(row[column_index_dict["issue_date"]], dtype="datetime64[D]")
        position_id = row[column_index_dict["position_id"]]
        valuation_date = np.array(row[column_index_dict["reporting_date"]], dtype="datetime64[D]")
        accrual_daycount = row[column_index_dict["accrual_daycount_convention"]]
        discount_daycount = row[column_index_dict["discount_daycount_convention"]]
        discount_convention_code = valuation_models.daycount_convention_code(discount_daycount)
        business_day_convention = np.array([row[column_index_dict["business_convention"]]])
        discount_curve = row[column_index_dict["discounting_curve"]]
        product_variant_name = row[column_index_dict["product_variant_name"]]
        fund = row[column_index_dict["fund_code"]]
        portfolio = row[column_index_dict["pool_id"]]
        entity = row[column_index_dict["legal_entity"]]
        last_payment_date = row[column_index_dict["last_payment_date"]]
        if str(last_payment_date) not in ["nan", "NaT", "None", "-"]:
            last_payment_date = np.datetime64(row[column_index_dict["last_payment_date"]], "D")
            first_emi_flag = "No"
        else:
            first_emi_flag = "Yes"
        stub_date = row[column_index_dict["stub_date"]]
        if str(stub_date) not in ["nan", "NaT", "None", "-"]:
            stub_date = np.datetime64(row[column_index_dict["stub_date"]], "D")
        payment_frequency = row[column_index_dict["payment_frequency"]]
        payment_frequency_unit = row[column_index_dict["payment_frequency_units"]]
        base_rate = float(row[column_index_dict["base_rate"]]) / 100
        if str(row[column_index_dict["fixed_spread"]]) not in ["", "nan", "None"]:
            fixed_spread = float(row[column_index_dict["fixed_spread"]]) / 100
        else:
            fixed_spread = 0
        interest_rate = base_rate + fixed_spread
        accrued_interest = row[column_index_dict["accrued_interest"]]
        accrual_convention_code = valuation_models.daycount_convention_code(accrual_daycount)
        if str(accrued_interest) not in ["nan", "None", ""]:
            accrued_interest = np.array([float(accrued_interest / Quantity)], dtype="float")
        outstanding_amount = np.array([float(row[column_index_dict["outstanding_amount"]])])
        emi_amount = float(row[column_index_dict["emi_amount"]])
        maturity_date = np.array([pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True)])
        if str(row[column_index_dict["quantity"]]) in ["", "nan", "None"]:
            quantity = 1
        else:
            quantity = int(row[column_index_dict["quantity"]])
        credit_spread_rate = row[column_index_dict["credit_spread_rate"]]
        credit_spread_curve = row[column_index_dict["credit_spread_curve"]]
        asset_liability_type = row[column_index_dict["asset_liability_type"]]
        valuation_results, sensitivity_analysis, measure_value = [], [], []
        interest_overdue = row[column_index_dict["interest_overdue_amount"]]
        principal_overdue = row[column_index_dict["principal_overdue_amount"]]
        charges_overdue = row[column_index_dict["charges_overdue_amount"]]
        moratorium_flag = row[column_index_dict["moratorium_flag"]]
        interest_moratorium_flag = row[column_index_dict["interest_moratorium_flag"]]
        moratorium_interest_capitalization = row[column_index_dict["moratorium_interest_capitalization"]]
        moratorium_end_date = row[column_index_dict["moratorium_end_date"]]
        moratorium_interest_and_accrued_interest = 0

        fixed_float_flag = row[column_index_dict["fixed_or_float_flag"]]
        fixed_payment_day_flag = row[column_index_dict["fixed_payment_day_flag"]]
        fixed_payment_day = row[column_index_dict["fixed_payment_day"]]
        payment_window = row[column_index_dict["payment_window"]]
        repayment_period_month_day_start = row[column_index_dict["repayment_period_month_day_start"]]
        repayment_period_month_day_end = row[column_index_dict["repayment_period_month_day_end"]]
        
        first_emi_amount = row[column_index_dict["first_emi_amount"]]

        next_reset_date = row[column_index_dict["next_reset_date"]]
        if str(next_reset_date) not in ["nan", "NaT", "None", "-"]:
            next_reset_date = np.datetime64(row[column_index_dict["next_reset_date"]], "D")

        if moratorium_flag == "Y":
            if str(moratorium_end_date) in ["nan", "NaT", "None", "-"]:
                moratorium_period = row[column_index_dict["moratorium_period"]]
                moratorium_period_units = row[column_index_dict["moratorium_period_units"]]
                moratorium_period = valuation_models.coupon_Frequency(
                    moratorium_period, moratorium_period_units
                )
                moratorium_end_date = np.datetime64(
                    pd.to_datetime(issue_date[0]).date() + pd.DateOffset(months=int(12 / moratorium_period)),
                    "D",
                )
                if convention_code == "EOM":
                    moratorium_end_date = np.datetime64(conventions.eomonth(moratorium_end_date), "D")
                else:
                    moratorium_end_date = conventions.business_day(
                        moratorium_end_date, convention_code, holiday_calendar, business_days=business_days
                    )
            else:
                moratorium_end_date = np.datetime64(row[column_index_dict["moratorium_end_date"]], "D")

            if interest_moratorium_flag == "Y":
                moratorium_interest_calculation_methodology = row[
                    column_index_dict["interest_calculation_logic_moratorium"]
                ]
                if moratorium_interest_capitalization == "Yes":
                    if moratorium_end_date >= valuation_date:
                        if str(accrued_interest) not in ["", "nan", "None"]:
                            year_frac = conventions.D_day_count(
                                np.array(valuation_date, dtype="datetime64[D]"),
                                np.array(moratorium_end_date, dtype="datetime64[D]"),
                                accrual_convention_code,
                                custom_daycount_conventions=custom_daycount_conventions,
                            )
                            if moratorium_interest_calculation_methodology == "Simple":
                                moratorium_interest = (
                                    outstanding_amount * (base_rate + fixed_spread) * year_frac
                                )
                            else:
                                compounding_frequency = row[column_index_dict["compounding_frequency"]]
                                compounding_frequency_unit = row[
                                    column_index_dict["compounding_frequency_unit"]
                                ]

                                moratorium_interest = compound_interest_calculation_formula(
                                    compounding_frequency,
                                    compounding_frequency_unit,
                                    year_frac,
                                    outstanding_amount + accrued_interest,
                                    base_rate + fixed_spread,
                                )
                            total_interest_capitalization = accrued_interest + moratorium_interest
                        else:
                            year_frac = conventions.D_day_count(
                                np.array(issue_date[0], dtype="datetime64[D]"),
                                np.array(moratorium_end_date, dtype="datetime64[D]"),
                                accrual_convention_code,
                                custom_daycount_conventions=custom_daycount_conventions,
                            )
                            if moratorium_interest_calculation_methodology == "Simple":
                                total_interest_capitalization = (
                                    outstanding_amount * (base_rate + fixed_spread) * year_frac
                                )
                            else:
                                compounding_frequency = row[column_index_dict["compounding_frequency"]]
                                compounding_frequency_unit = row[
                                    column_index_dict["compounding_frequency_unit"]
                                ]
                                total_interest_capitalization = compound_interest_calculation_formula(
                                    compounding_frequency,
                                    compounding_frequency_unit,
                                    year_frac,
                                    outstanding_amount,
                                    base_rate + fixed_spread,
                                )

                        outstanding_amount = outstanding_amount + total_interest_capitalization
                        moratorium_interest_and_accrued_interest = 0
                        accrued_interest = [0]
                    else:
                        if str(accrued_interest) in ["", "nan", "None"]:
                            if (
                                str(last_payment_date) not in ["nan", "NaT", "None", "-"]
                                and last_payment_date >= moratorium_end_date
                            ):
                                year_frac = conventions.D_day_count(
                                    np.array(last_payment_date, dtype="datetime64[D]"),
                                    np.array(valuation_date, dtype="datetime64[D]"),
                                    accrual_convention_code,
                                    custom_daycount_conventions=custom_daycount_conventions,
                                )
                                accrued_interest = outstanding_amount * (base_rate + fixed_spread) * year_frac
                                moratorium_interest_and_accrued_interest = accrued_interest
                            else:
                                year_frac_post_moratorium = conventions.D_day_count(
                                    np.array(moratorium_end_date, dtype="datetime64[D]"),
                                    np.array(valuation_date, dtype="datetime64[D]"),
                                    accrual_convention_code,
                                    custom_daycount_conventions=custom_daycount_conventions,
                                )
                                accrued_interest = (
                                    outstanding_amount
                                    * (base_rate + fixed_spread)
                                    * year_frac_post_moratorium
                                )
                                moratorium_interest_and_accrued_interest = accrued_interest
                else:
                    if str(accrued_interest) not in ["", "nan", "None"]:
                        year_frac = conventions.D_day_count(
                            np.array(valuation_date, dtype="datetime64[D]"),
                            np.array(moratorium_end_date, dtype="datetime64[D]"),
                            accrual_convention_code,
                            custom_daycount_conventions=custom_daycount_conventions,
                        )
                        if moratorium_interest_calculation_methodology == "Simple":
                            moratorium_interest = outstanding_amount * (base_rate + fixed_spread) * year_frac
                        else:
                            compounding_frequency = row[column_index_dict["compounding_frequency"]]
                            compounding_frequency_unit = row[column_index_dict["compounding_frequency_unit"]]
                            moratorium_interest = compound_interest_calculation_formula(
                                compounding_frequency,
                                compounding_frequency_unit,
                                year_frac,
                                outstanding_amount + accrued_interest,
                                base_rate + fixed_spread,
                            )
                        moratorium_interest_and_accrued_interest = accrued_interest + moratorium_interest
                    else:
                        year_frac = conventions.D_day_count(
                            np.array(issue_date[0], dtype="datetime64[D]"),
                            np.array(moratorium_end_date, dtype="datetime64[D]"),
                            accrual_convention_code,
                            custom_daycount_conventions=custom_daycount_conventions,
                        )
                        if moratorium_interest_calculation_methodology == "Simple":
                            total_interest_capitalization = (
                                outstanding_amount * (base_rate + fixed_spread) * year_frac
                            )
                        else:
                            compounding_frequency = row[column_index_dict["compounding_frequency"]]
                            compounding_frequency_unit = row[column_index_dict["compounding_frequency_unit"]]
                            total_interest_capitalization = compound_interest_calculation_formula(
                                compounding_frequency,
                                compounding_frequency_unit,
                                year_frac,
                                outstanding_amount,
                                base_rate + fixed_spread,
                            )
                        moratorium_interest_and_accrued_interest = total_interest_capitalization
            else:
                moratorium_interest_and_accrued_interest = (
                    moratorium_interest_and_accrued_interest + accrued_interest[0]
                )

        result = emi_cashflow_generation(
            fund,
            portfolio,
            issue_date,
            last_payment_date,
            emi_amount,
            maturity_date,
            interest_rate,
            payment_frequency,
            payment_frequency_unit,
            outstanding_amount,
            position_id,
            business_day_convention,
            discount_daycount,
            accrual_daycount,
            product_variant_name,
            currency,
            valuation_date,
            entity,
            asset_liability_type,
            [],
            custom_daycount_conventions,
            accrued_interest,
            stub_date=stub_date,
            business_days=business_days,
            moratorium_end_date=moratorium_end_date,
            moratorium_flag=moratorium_flag,
            interest_moratorium_flag=interest_moratorium_flag,
            moratorium_interest_and_accrued_interest=moratorium_interest_and_accrued_interest,
            fixed_payment_day_flag=fixed_payment_day_flag,
            fixed_payment_day=fixed_payment_day,
            payment_window=payment_window,
            repayment_period_month_day_start=repayment_period_month_day_start,
            repayment_period_month_day_end=repayment_period_month_day_end,
            first_emi_flag = first_emi_flag,
            first_emi_amount = first_emi_amount,
        )
        cashflow_model_results = {
            "extract_date": Valuation_Date[0],
            "transaction_date": result[1],
            "unique_reference_id": Unique_Reference_Id,
            "reference_dimension": reference_dimension,
            "cashflow_type": result[4],
            "cashflow_status": cashflow_status,
            "cashflow": result[6],
            "time_to_maturity": result[7],
            "discount_factor": result[8],
            "present_value": result[9],
            "currency": currency,
            "asset_liability_type": asset_liability_type,
            "product_variant_name": product_variant_name,
            "fund": fund,
            "portfolio": portfolio,
            "cohort": None,
            "entity": entity,
            "interest_paid_array": result[17],
            "principal_paid_array": result[18],
            "principal_outstanding_beginning": result[20],
            "principal_outstanding_ending": result[21],
        }
        cashflow_model_results = pd.DataFrame(cashflow_model_results)
        accrued_interest = result[19]
        accrued_interest_ttm = cashflow_model_results["time_to_maturity"].iloc[0]
        cashflow_model_results, dpd_cashflows = overdue_cashflow_calculations(
            position_id,
            cashflow_model_results,
            dpd_schedule,
            dpd_ruleset,
            overdue_bucketing_data,
            Valuation_Date,
            Unique_Reference_Id,
            reference_dimension,
            cashflow_status,
            currency,
            asset_liability_type,
            product_variant_name,
            fund,
            portfolio,
            entity,
            interest_overdue,
            principal_overdue,
            charges_overdue,
        )
        cashflow_model_results = cashflow_model_results.astype(
            {"time_to_maturity": "float64", "cashflow": "float64", "transaction_date": "datetime64[ns]"}
        )
        cashflow_model_results = cashflow_model_results.sort_values(
            by=["transaction_date", "cashflow_type"], ascending=True
        )
        output_msg = output_check_fn(
            cashflow_results=cashflow_model_results[cashflow_model_results["time_to_maturity"] != 0]
        )

        if output_msg["CF_Output"] == "Present":
            if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
                ttm = np.array(cashflow_model_results["time_to_maturity"], dtype="float64")
                total_amount = np.array(cashflow_model_results["cashflow"], dtype="float64")
                coupons = np.array(cashflow_model_results["interest_paid_array"], dtype="float64")
                principal = np.array(cashflow_model_results["principal_paid_array"], dtype="float64")
                cashflow_model_results = cashflow_model_results.drop(
                    ["interest_paid_array", "principal_paid_array"], axis=1
                )
                cashflow_status = cashflow_model_results["cashflow_status"]
                zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == discount_curve), :]
                interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
                extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[0]
                tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                zero_rates = np.empty([0], dtype="float64")
                measure_run_date_strftime = datetime.now()
                for j in range(len(ttm)):
                    if interpolation_algorithm == "Linear":
                        if linearinterp(tenor, rates, ttm[j]) is None:
                            if extrapolation_algorithm == "Linear":
                                extrapolated_value = linearexterp(tenor, rates, ttm[j])
                            else:
                                extrapolated_value = flatexterp(tenor, rates, ttm[j])
                            zero_rates = np.append(zero_rates, extrapolated_value)
                        else:
                            interpolated_value = linearinterp(tenor, rates, ttm[j])
                            zero_rates = np.append(zero_rates, interpolated_value)

                if str(credit_spread_rate) not in ["nan", "None"]:
                    zero_rates = zero_rates + float(credit_spread_rate)
                elif str(credit_spread_curve) not in ["nan", "None"]:
                    credit_spread_curve_data = credit_spread_data.loc[
                        (credit_spread_data["credit_spread_curve_name"] == credit_spread_curve), :
                    ]
                    if len(credit_spread_curve_data) > 0:
                        spread_tenor = np.array(credit_spread_curve_data.tenor.tolist())
                        spread_tenor_unit = np.array(credit_spread_curve_data.tenor_unit.tolist())
                        cs_interpolation_algorithm = credit_spread_curve_data["interpolation_algorithm"].iloc[
                            0
                        ]
                        cs_extrapolation_algorithm = credit_spread_curve_data["extrapolation_algorithm"].iloc[
                            0
                        ]
                        tenor_extrac = np.vectorize(tenor_extraction)
                        spread_tenor = tenor_extrac(spread_tenor, spread_tenor_unit)
                        spread_rates = np.array(credit_spread_curve_data.spread_value.tolist())
                        credit_spread_rates = np.empty([0], dtype="float64")
                        for j in range(len(ttm)):
                            if linearinterp(spread_tenor, spread_rates, ttm[j]) is None:
                                if cs_extrapolation_algorithm == "Linear":
                                    calculated_value = linearexterp(spread_tenor, spread_rates, ttm[j])
                                else:
                                    calculated_value = flatexterp(spread_tenor, spread_rates, ttm[j])
                            else:
                                calculated_value = linearinterp(spread_tenor, spread_rates, ttm[j])
                            credit_spread_rates = np.append(credit_spread_rates, calculated_value)
                        zero_rates = zero_rates + credit_spread_rates
                (
                    pv_output,
                    pv_table,
                    ttm_array,
                    total_amount_array,
                    df,
                    pv_coupons,
                    pv_principal,
                    PV_plus_1bps,
                    PV_minus_1bps,
                ) = fixed_income_valuation(
                    ttm,
                    total_amount,
                    zero_rates,
                    coupons,
                    principal,
                    curve_compounding_frequency=curve_compounding_frequency,
                )
                cashflow_model_results["discount_factor"] = df
                cashflow_model_results["present_value"] = pv_table
                output_msg = output_check_fn(valuation_output=pv_output)
                if output_msg["Val_Output"] == "Present":
                    valuation_output = {
                        "PV": round(pv_output, 4),
                    }
                    measure_dict_val = {
                        "measure_run_date": measure_run_date_strftime,
                        "valuation_date": Valuation_Date[0],
                        "unique_reference_id": Unique_Reference_Id,
                        "position_id": Position_Id,
                        "reference_dimension": reference_dimension,
                        "measure_type": "Fair Value per unit",
                        "measure_value": round(pv_output, 4),
                        "absolute_relative": "Absolute",
                        "residual_maturity": ttm[-1],
                        "asset_liability_type": asset_liability_type,
                        "product_variant_name": product_variant_name,
                        "fund": fund,
                        "portfolio": portfolio,
                        "cohort": "",
                        "entity": entity,
                    }
                    measure_dict_val_position = {
                        "measure_run_date": measure_run_date_strftime,
                        "valuation_date": Valuation_Date[0],
                        "unique_reference_id": Unique_Reference_Id,
                        "position_id": Position_Id,
                        "reference_dimension": reference_dimension,
                        "measure_type": "Fair Value",
                        "measure_value": round(pv_output * quantity, 4),
                        "absolute_relative": "Absolute",
                        "residual_maturity": ttm_array[-1],
                        "asset_liability_type": asset_liability_type,
                        "product_variant_name": product_variant_name,
                        "fund": fund,
                        "portfolio": portfolio,
                        "cohort": "",
                        "entity": entity,
                    }
                    measure_value.append(measure_dict_val)
                    measure_value.append(measure_dict_val_position)
                    valuation_results.append(valuation_output)
                    total_holding = quantity * valuation_results[0]["PV"]

                    if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":
                        if fixed_float_flag == "Float":
                            cashflow_model_results["zero_rates"] = zero_rates
                            interest_date_reset_check = cashflow_model_results.loc[
                                (cashflow_model_results["transaction_date"] == next_reset_date)
                                & (cashflow_model_results["cashflow_type"] == "Interest Proceeds")
                            ]
                            principal_date_check = cashflow_model_results.loc[
                                (
                                    cashflow_model_results["cashflow_type"].isin(
                                        ["Principal Amount", "Redemption Proceeds", "Principal Proceeds"]
                                    )
                                )
                                & (cashflow_model_results["transaction_date"] < next_reset_date)
                            ]
                            # All interest cashflows before and on next reset date and principal cashflows
                            reset_filterered_df = cashflow_model_results.loc[
                                (
                                    (
                                        cashflow_model_results["cashflow_type"].isin(
                                            ["Principal Amount", "Redemption Proceeds", "Principal Proceeds"]
                                        )
                                    )
                                    & (cashflow_model_results["transaction_date"] < next_reset_date)
                                )
                                | (
                                    (
                                        cashflow_model_results["cashflow_type"].isin(
                                            [
                                                "Interest Proceeds",
                                                "Charges Overdue",
                                                "Interest Overdue",
                                                "Principal Overdue",
                                            ]
                                        )
                                    )
                                    & (cashflow_model_results["transaction_date"] <= next_reset_date)
                                )
                            ]
                            reset_maturity = conventions.A_day_count(
                                Valuation_Date[0],
                                next_reset_date,
                                discount_convention_code,
                                custom_daycount_conventions=custom_daycount_conventions,
                            )

                            # Case 1 - No principal cashflows before reset date
                            if len(principal_date_check) == 0:
                                reset_df_principal = cashflow_model_results.loc[
                                    (cashflow_model_results["cashflow_type"] == "Interest Proceeds")
                                ].head(1)
                                reset_df_principal["cashflow_type"] = "Principal Amount"
                                reset_df_principal["cashflow"] = outstanding_amount
                                reset_df_principal["transaction_date"] = next_reset_date
                                reset_df_principal["time_to_maturity"] = reset_maturity
                                reset_filterered_df = pd.concat(
                                    [reset_filterered_df, reset_df_principal], ignore_index=True
                                )

                            # Case 2 - Principal cashflows on or before reset date
                            else:
                                reset_df_principal = cashflow_model_results.loc[
                                    (cashflow_model_results["cashflow_type"] == "Interest Proceeds")
                                ].head(1)
                                reset_df_principal["cashflow_type"] = "Principal Amount"
                                principal_outstanding = cashflow_model_results.loc[
                                    (
                                        cashflow_model_results["cashflow_type"].isin(
                                            ["Principal Amount", "Redemption Proceeds", "Principal Proceeds"]
                                        )
                                    )
                                    & (cashflow_model_results["transaction_date"] >= next_reset_date)
                                ]["cashflow"].sum()
                                reset_df_principal["cashflow"] = principal_outstanding
                                reset_df_principal["transaction_date"] = next_reset_date
                                reset_df_principal["time_to_maturity"] = reset_maturity
                                reset_filterered_df = pd.concat(
                                    [reset_filterered_df, reset_df_principal], ignore_index=True
                                )

                            if len(interest_date_reset_check) == 0:
                                interest_till_reset_dict = reset_filterered_df.loc[
                                    (
                                        reset_filterered_df["cashflow_type"].isin(
                                            ["Principal Amount", "Redemption Proceeds", "Principal Proceeds"]
                                        )
                                    )
                                    & (reset_filterered_df["transaction_date"] == next_reset_date)
                                ].to_dict("records")
                                previous_payment_date = cashflow_model_results.loc[
                                    (cashflow_model_results["transaction_date"] < next_reset_date)
                                    & (cashflow_model_results["cashflow_type"] == "Interest Proceeds")
                                ]
                                if len(previous_payment_date) > 0:
                                    previous_payment_date_val = np.datetime64(
                                        pd.to_datetime(
                                            previous_payment_date["transaction_date"].max(), dayfirst=True
                                        ).date()
                                    )
                                    interest_cashflow = 0
                                    val_date_check = False
                                else:
                                    previous_payment_date_val = last_payment_date
                                    val_date_check = True
                                    interest_cashflow = accrued_interest

                                principal_payment_dates_between_previous_interest_payment_and_reset = (
                                    cashflow_model_results.loc[
                                        (
                                            cashflow_model_results["cashflow_type"].isin(
                                                [
                                                    "Principal Amount",
                                                    "Redemption Proceeds",
                                                    "Principal Proceeds",
                                                ]
                                            )
                                        )
                                        & (cashflow_model_results["transaction_date"] < next_reset_date)
                                        & (
                                            cashflow_model_results["transaction_date"]
                                            > previous_payment_date_val
                                        ),
                                        "transaction_date",
                                    ].tolist()
                                )
                                interest_rate = base_rate + fixed_spread
                                if (
                                    len(principal_payment_dates_between_previous_interest_payment_and_reset)
                                    != 0
                                ):
                                    for i in range(
                                        0,
                                        len(
                                            principal_payment_dates_between_previous_interest_payment_and_reset
                                        ),
                                    ):
                                        principal_outstanding_beginning = cashflow_model_results.loc[
                                            (
                                                cashflow_model_results["cashflow_type"].isin(
                                                    [
                                                        "Principal Amount",
                                                        "Redemption Proceeds",
                                                        "Principal Proceeds",
                                                    ]
                                                )
                                            )
                                            & (
                                                cashflow_model_results["transaction_date"]
                                                == principal_payment_dates_between_previous_interest_payment_and_reset[
                                                    i
                                                ]
                                            ),
                                            "principal_outstanding_ending",
                                        ]
                                        if (
                                            i
                                            == principal_payment_dates_between_previous_interest_payment_and_reset[
                                                -1
                                            ]
                                        ):
                                            if (
                                                len(
                                                    principal_payment_dates_between_previous_interest_payment_and_reset
                                                )
                                                == 1
                                            ):
                                                if val_date_check:
                                                    year_frac = conventions.A_day_count(
                                                        valuation_date[0],
                                                        next_reset_date,
                                                        accrual_convention_code,
                                                        custom_daycount_conventions=custom_daycount_conventions,
                                                    )
                                                else:
                                                    year_frac = conventions.A_day_count(
                                                        previous_payment_date_val,
                                                        next_reset_date,
                                                        accrual_convention_code,
                                                        custom_daycount_conventions=custom_daycount_conventions,
                                                    )
                                            else:
                                                year_frac = conventions.A_day_count(
                                                    principal_payment_dates_between_previous_interest_payment_and_reset[
                                                        i - 1
                                                    ],
                                                    next_reset_date,
                                                    accrual_convention_code,
                                                    custom_daycount_conventions=custom_daycount_conventions,
                                                )
                                        else:
                                            if (
                                                len(
                                                    principal_payment_dates_between_previous_interest_payment_and_reset
                                                )
                                                == 1
                                            ):
                                                if val_date_check:
                                                    year_frac = conventions.A_day_count(
                                                        valuation_date[0],
                                                        principal_payment_dates_between_previous_interest_payment_and_reset[
                                                            i
                                                        ],
                                                        accrual_convention_code,
                                                        custom_daycount_conventions=custom_daycount_conventions,
                                                    )
                                                else:
                                                    year_frac = conventions.A_day_count(
                                                        previous_payment_date_val,
                                                        principal_payment_dates_between_previous_interest_payment_and_reset[
                                                            i
                                                        ],
                                                        accrual_convention_code,
                                                        custom_daycount_conventions=custom_daycount_conventions,
                                                    )
                                            else:
                                                year_frac = conventions.A_day_count(
                                                    principal_payment_dates_between_previous_interest_payment_and_reset[
                                                        i - 1
                                                    ],
                                                    principal_payment_dates_between_previous_interest_payment_and_reset[
                                                        i
                                                    ],
                                                    accrual_convention_code,
                                                    custom_daycount_conventions=custom_daycount_conventions,
                                                )
                                        interest_cashflow += (
                                            principal_outstanding_beginning * year_frac * interest_rate
                                        )
                                else:
                                    if val_date_check:
                                        year_frac = conventions.A_day_count(
                                            valuation_date[0],
                                            next_reset_date,
                                            accrual_convention_code,
                                            custom_daycount_conventions=custom_daycount_conventions,
                                        )
                                        interest_cashflow += outstanding_amount * year_frac * interest_rate
                                    else:
                                        year_frac = conventions.A_day_count(
                                            previous_payment_date_val,
                                            next_reset_date,
                                            accrual_convention_code,
                                            custom_daycount_conventions=custom_daycount_conventions,
                                        )
                                        previous_principal_payment_date = cashflow_model_results.loc[
                                            (
                                                cashflow_model_results["cashflow_type"].isin(
                                                    [
                                                        "Principal Amount",
                                                        "Redemption Proceeds",
                                                        "Principal Proceeds",
                                                    ]
                                                )
                                            )
                                            & (
                                                cashflow_model_results["transaction_date"]
                                                <= previous_payment_date_val
                                            ),
                                            "transaction_date",
                                        ].max()
                                        outstanding_amount = cashflow_model_results.loc[
                                            (
                                                cashflow_model_results["cashflow_type"].isin(
                                                    [
                                                        "Principal Amount",
                                                        "Redemption Proceeds",
                                                        "Principal Proceeds",
                                                    ]
                                                )
                                            )
                                            & (
                                                cashflow_model_results["transaction_date"]
                                                == previous_principal_payment_date
                                            ),
                                            "principal_outstanding_ending",
                                        ].iloc[0]
                                        interest_cashflow += outstanding_amount * year_frac * interest_rate

                                interest_till_reset_dict[0]["cashflow"] = interest_cashflow
                                interest_till_reset_dict[0]["cashflow_type"] = "Interest Proceeds"
                                reset_filterered_df = pd.concat(
                                    [reset_filterered_df, pd.DataFrame(interest_till_reset_dict)],
                                    ignore_index=True,
                                )

                            reset_zero_rate = linearinterp(tenor, rates, reset_maturity)
                            if reset_zero_rate is None:
                                if extrapolation_algorithm == "Linear":
                                    reset_zero_rate = linearexterp(tenor, rates, reset_maturity)
                                else:
                                    reset_zero_rate = flatexterp(tenor, rates, reset_maturity)

                            if str(credit_spread_rate) not in ["nan", "None"]:
                                reset_zero_rate = reset_zero_rate + float(credit_spread_rate)
                            elif str(credit_spread_curve) not in ["nan", "None"]:
                                if not credit_spread_curve_data.empty:
                                    reset_credit_spread = linearinterp(
                                        spread_tenor, spread_rates, reset_maturity
                                    )
                                    if reset_credit_spread is None:
                                        if cs_extrapolation_algorithm == "Linear":
                                            reset_credit_spread = linearexterp(
                                                spread_tenor, spread_rates, reset_maturity
                                            )
                                        else:
                                            reset_credit_spread = flatexterp(
                                                spread_tenor, spread_rates, reset_maturity
                                            )
                                        credit_spread_rates = np.append(
                                            credit_spread_rates, reset_credit_spread
                                        )
                                    reset_zero_rate = reset_zero_rate + reset_credit_spread

                            reset_filterered_df.loc[
                                reset_filterered_df["transaction_date"] == next_reset_date, "zero_rates"
                            ] = reset_zero_rate

                            (
                                PV_output_sens,
                                PV_table_sens,
                                TTM_array_sens,
                                Total_amount_array_sens,
                                DF_sens,
                                PV_coupons_sens,
                                PV_principal_sens,
                                PV_plus_1bps_sens,
                                PV_minus_1bps_sens,
                            ) = fixed_income_valuation(
                                (reset_filterered_df["time_to_maturity"].to_numpy()).astype("float64"),
                                (reset_filterered_df["cashflow"].to_numpy()).astype("float64"),
                                (reset_filterered_df["zero_rates"].to_numpy()).astype("float64"),
                                (reset_filterered_df["cashflow"].to_numpy()).astype("float64"),
                                (reset_filterered_df["cashflow"].to_numpy()).astype("float64"),
                                curve_compounding_frequency=curve_compounding_frequency,
                            )

                            (
                                pv01,
                                macaulay_duration,
                                modified_duration,
                                effective_duration,
                                ytm,
                            ) = valuation_models.fixed_income_sensitivity_analysis(
                                PV_table_sens,
                                TTM_array_sens,
                                Total_amount_array_sens,
                                payment_frequency,
                                payment_frequency_unit,
                                PV_output_sens,
                                PV_plus_1bps_sens,
                                PV_minus_1bps_sens,
                            )
                        else:
                            (
                                pv01,
                                macaulay_duration,
                                modified_duration,
                                effective_duration,
                                ytm,
                            ) = valuation_models.fixed_income_sensitivity_analysis(
                                pv_table,
                                ttm_array,
                                total_amount_array,
                                payment_frequency,
                                payment_frequency_unit,
                                pv_output,
                                PV_plus_1bps,
                                PV_minus_1bps,
                            )
                        sensitivity_analysis.append(
                            {
                                "Macaulay Duration": macaulay_duration,
                                "Effective Duration": effective_duration,
                                "Modified Duration": modified_duration,
                                "PV01 per unit": pv01,
                            }
                        )
                        if isinstance(ytm, (np.ndarray)):
                            ytm = ytm[0]
                        else:
                            ytm = ytm
                        measure_dict_ytm = {
                            "measure_run_date": measure_run_date_strftime,
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Yield to Maturity",
                            "measure_value": ytm,
                            "absolute_relative": "Absolute",
                            "residual_maturity": ttm_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_ytm)
                        measure_dict_mac_dur = {
                            "measure_run_date": measure_run_date_strftime,
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Macaulay Duration",
                            "measure_value": macaulay_duration,
                            "absolute_relative": "Absolute",
                            "residual_maturity": ttm_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_mac_dur)
                        measure_dict_eff_dur = {
                            "measure_run_date": measure_run_date_strftime,
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Effective Duration",
                            "measure_value": effective_duration,
                            "absolute_relative": "Relative",
                            "residual_maturity": ttm_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_eff_dur)
                        measure_dict_mod_dur = {
                            "measure_run_date": measure_run_date_strftime,
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Modified Duration",
                            "measure_value": modified_duration,
                            "absolute_relative": "Relative",
                            "residual_maturity": ttm_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_mod_dur)
                        measure_dict_pv01 = {
                            "measure_run_date": measure_run_date_strftime,
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "PV01 per unit",
                            "measure_value": pv01,
                            "absolute_relative": "Absolute",
                            "residual_maturity": ttm_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_pv01)
                        measure_dict_pv01_position = {
                            "measure_run_date": measure_run_date_strftime,
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "PV01",
                            "measure_value": pv01 * quantity,
                            "absolute_relative": "Absolute",
                            "residual_maturity": ttm_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_pv01_position)

                else:
                    valuation_output = {
                        "PV": "None",
                    }
                    total_holding = "None"
                    valuation_results.append(valuation_output)

            else:
                cashflow_model_results = cashflow_model_results.drop(
                    ["interest_paid_array", "principal_paid_array"], axis=1
                )
                sensitivity_analysis.append(
                    {
                        "Macaulay_Duration": "-",
                        "Effective Duration": "-",
                        "Modified_Duration": "-",
                        "PV01 per unit": "-",
                    }
                )
                valuation_output = {
                    "PV": "None",
                }
                total_holding = "None"
                valuation_results.append(valuation_output)

        else:
            cashflow_model_results = cashflow_model_results.drop(
                ["interest_paid_array", "principal_paid_array"], axis=1
            )
            sensitivity_analysis.append(
                {
                    "Macaulay_Duration": "-",
                    "Effective Duration": "-",
                    "Modified_Duration": "-",
                    "PV01 per unit": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        if str(accrued_interest[0]) not in ["", "0.0", "None", "nan"]:
            cashflow_model_results = pd.concat(
                [cashflow_model_results, cashflow_model_results.iloc[[-1]]], ignore_index=True
            )
            if str(Quantity) in ["", "nan", "None"]:
                Quantity = 1
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow")] = (
                accrued_interest[0] * Quantity
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow_type")] = (
                "Accrued Interest"
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("transaction_date")] = (
                Valuation_Date[0]
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("present_value")] = 0
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("time_to_maturity")] = (
                accrued_interest_ttm
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("discount_factor")] = 0

            cashflow_model_results = cashflow_model_results.sort_values(
                by=["transaction_date", "cashflow_type"], ascending=True
            )

        if "zero_rates" in cashflow_model_results.columns.tolist():
            cashflow_model_results.drop(
                columns=["principal_outstanding_beginning", "principal_outstanding_ending", "zero_rates"],
                inplace=True,
            )
        else:
            cashflow_model_results.drop(
                columns=["principal_outstanding_beginning", "principal_outstanding_ending"], inplace=True
            )

        cashflow_model_results["unique_reference_id"] = Unique_Reference_Id
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = unique_reference_Id
        final_output_dict["Position_Id"] = position_id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = Valuation_Date[0]
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Quantity"] = quantity
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        measure_value = pd.DataFrame(measure_value)
        measure_value["currency"] = currency
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] == "M021":
        final_output_dict = {}
        unique_reference_id = row[column_index_dict["unique_reference_id"]]
        issue_date = np.array(row[column_index_dict["issue_date"]], dtype="datetime64[D]")
        position_id = row[column_index_dict["position_id"]]
        valuation_date = np.array([row[column_index_dict["reporting_date"]]]).astype("datetime64[D]")
        accrual_daycount = row[column_index_dict["accrual_daycount_convention"]]
        accrual_convention_code = valuation_models.daycount_convention_code(accrual_daycount)
        discount_daycount = row[column_index_dict["discount_daycount_convention"]]
        discount_curve = row[column_index_dict["discounting_curve"]]
        asset_liability_type = row[column_index_dict["asset_liability_type"]]
        product_variant_name = row[column_index_dict["product_variant_name"]]
        fund = row[column_index_dict["fund_code"]]
        portfolio = row[column_index_dict["pool_id"]]
        entity = row[column_index_dict["legal_entity"]]
        last_payment_date = row[column_index_dict["last_payment_date"]]
        if str(last_payment_date) not in ["nan", "NaT", "None", "-"]:
            last_payment_date = np.datetime64(row[column_index_dict["last_payment_date"]], "D")
        stub_date = row[column_index_dict["stub_date"]]
        if str(stub_date) not in ["nan", "NaT", "None", "-"]:
            stub_date = np.datetime64(row[column_index_dict["stub_date"]], "D")
        nmd_cashflow_frequency = row[column_index_dict["nmd_cashflow_frequency"]]
        if str(nmd_cashflow_frequency) in ["nan", "", "None", "NaT"]:
            nmd_cashflow_frequency = "Daily"
        if str(last_payment_date) not in ["nan", "", "None", "NaT"]:
            last_payment_date = np.array(row[column_index_dict["last_payment_date"]], dtype="datetime64[D]")
        accrued_interest = row[column_index_dict["accrued_interest"]]
        if str(accrued_interest) not in ["nan", "", "None"]:
            accrued_interest = float(accrued_interest)
        else:
            accrued_interest = 0
        payment_frequency = row[column_index_dict["payment_frequency"]]
        payment_frequency_unit = row[column_index_dict["payment_frequency_units"]]
        if str(row[column_index_dict["base_rate"]]) not in ["nan", "", "None"]:
            base_rate = float(row[column_index_dict["base_rate"]]) / 100
        else:
            base_rate = 0
        if str(row[column_index_dict["fixed_spread"]]) not in ["", "nan", "None"]:
            fixed_spread = float(row[column_index_dict["fixed_spread"]]) / 100
        else:
            fixed_spread = 0
        interest_rate = base_rate + fixed_spread
        outstanding_amount = float(row[column_index_dict["outstanding_amount"]])
        reference_dimension = "Security"
        quantity = int(row[column_index_dict["quantity"]])
        business_day_convention = np.array([row[column_index_dict["business_convention"]]])
        cashflow_status = "Unrealised"
        valuation_results, sensitivity_analysis, PV_principal, measure_value = [], [], [], []
        NMD_Data = NMD_adjustments[
            [
                "product_variant_name",
                "scenario_analysis_id",
                "reporting_date",
                "start_tenor",
                "start_tenor_unit",
                "end_tenor",
                "end_tenor_unit",
                "percentage",
                "cashflow_frequency",
            ]
        ]
        NMD_Data = NMD_Data[
            (NMD_Data["product_variant_name"] == product_variant_name)
            & (NMD_Data["cashflow_frequency"] == nmd_cashflow_frequency)
        ]
        Percentage_Data = NMD_percentage_calculation(NMD_Data, nmd_cashflow_frequency)
        Allocated_arr = np.array(Percentage_Data)
        Date = Allocated_arr[0].astype("datetime64[D]")
        percentage = Allocated_arr[1].astype("float")

        result = NMD_Cashflow(
            fund,
            portfolio,
            issue_date,
            position_id,
            last_payment_date,
            payment_frequency,
            payment_frequency_unit,
            interest_rate,
            outstanding_amount,
            discount_curve,
            currency,
            Date,
            percentage,
            product_variant_name,
            valuation_date,
            entity,
            asset_liability_type,
            accrued_interest,
            holiday_calendar,
            business_day_convention,
            discount_daycount,
            custom_daycount_conventions,
            nmd_cashflow_frequency,
            accrual_convention_code,
            stub_date=stub_date,
            business_days=business_days,
        )
        cashflow_model_results = {
            "extract_date": Valuation_Date[0],
            "transaction_date": result[0],
            "unique_reference_id": Unique_Reference_Id,
            "reference_dimension": reference_dimension,
            "cashflow_type": result[1],
            "cashflow_status": cashflow_status,
            "cashflow": result[2],
            "time_to_maturity": result[3],
            "discount_factor": None,
            "present_value": None,
            "currency": currency,
            "asset_liability_type": asset_liability_type,
            "product_variant_name": product_variant_name,
            "fund": fund,
            "portfolio": portfolio,
            "cohort": None,
            "entity": entity,
            "Interest_Paid": result[4],
            "Principal_Paid": result[5],
        }
        cashflow_model_results = pd.DataFrame(cashflow_model_results)
        cashflow_model_results = cashflow_model_results.astype(
            {"time_to_maturity": "float64", "cashflow": "float64", "transaction_date": "datetime64[ns]"}
        )
        cashflow_model_results = cashflow_model_results.sort_values(by=["transaction_date", "cashflow_type"])
        output_msg = output_check_fn(cashflow_results=cashflow_model_results)

        if output_msg["CF_Output"] == "Present":
            if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
                TTM = cashflow_model_results["time_to_maturity"].to_numpy(dtype="float64")
                Total_Amount = cashflow_model_results["cashflow"].to_numpy(dtype="float64")
                Coupons = cashflow_model_results["Interest_Paid"].to_numpy(dtype="float64")
                Principal = cashflow_model_results["Principal_Paid"].to_numpy(dtype="float64")
                zero_rate_curve = discount_curve
                zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
                interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
                extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[0]
                tenor = zero_rate_curve_points["tenor"].to_numpy(dtype="float64")
                rates = zero_rate_curve_points["rate"].to_numpy(dtype="float64")
                zero_rates = np.empty([0], dtype="float64")
                for j in range(len(TTM)):
                    if interpolation_algorithm == "Linear":
                        if linearinterp(tenor, rates, TTM[j]) is None:
                            if extrapolation_algorithm == "Linear":
                                extrapolated_value = linearexterp(tenor, rates, TTM[j])
                            else:
                                extrapolated_value = flatexterp(tenor, rates, TTM[j])
                            zero_rates = np.append(zero_rates, extrapolated_value)
                        else:
                            interpolated_value = linearinterp(tenor, rates, TTM[j])
                            zero_rates = np.append(zero_rates, interpolated_value)
                zero_rates = zero_rates.astype("float64")

                (
                    PV_output,
                    PV_table,
                    TTM_array,
                    Total_amount_array,
                    DF,
                    PV_coupons,
                    PV_principal,
                    PV_plus_1bps,
                    PV_minus_1bps,
                ) = fixed_income_valuation(
                    TTM,
                    Total_Amount,
                    zero_rates,
                    Coupons,
                    Principal,
                    curve_compounding_frequency=curve_compounding_frequency,
                )

                cashflow_model_results["discount_factor"] = DF
                cashflow_model_results["present_value"] = PV_table
                
                del zero_rate_curve_points, tenor, rates
                output_msg = output_check_fn(valuation_output=PV_output)
                if output_msg["Val_Output"] == "Present":
                    valuation_output = {
                        "PV": PV_output,
                    }
                    measure_dict_val = {
                        "measure_run_date": datetime.now(),
                        "valuation_date": valuation_date[0],
                        "unique_reference_id": Unique_Reference_Id,
                        "position_id": Position_Id,
                        "reference_dimension": reference_dimension,
                        "measure_type": "Fair Value per unit",
                        "measure_value": round(PV_output, 4),
                        "absolute_relative": "Absolute",
                        "residual_maturity": TTM[-1],
                        "asset_liability_type": asset_liability_type,
                        "product_variant_name": product_variant_name,
                        "fund": fund,
                        "portfolio": portfolio,
                        "cohort": "",
                        "entity": entity,
                    }
                    measure_dict_val_position = {
                        "measure_run_date": datetime.now(),
                        "valuation_date": valuation_date[0],
                        "unique_reference_id": Unique_Reference_Id,
                        "position_id": Position_Id,
                        "reference_dimension": reference_dimension,
                        "measure_type": "Fair Value",
                        "measure_value": PV_output * quantity,
                        "absolute_relative": "Absolute",
                        "residual_maturity": TTM_array[-1],
                        "asset_liability_type": asset_liability_type,
                        "product_variant_name": product_variant_name,
                        "fund": fund,
                        "portfolio": portfolio,
                        "cohort": "",
                        "entity": entity,
                    }
                    measure_value.append(measure_dict_val)
                    measure_value.append(measure_dict_val_position)
                    valuation_results.append(valuation_output)
                    total_holding = quantity * valuation_results[0]["PV"]

                    if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":
                        (
                            PV01,
                            macaulay_duration,
                            modified_duration,
                            effective_duration,
                            ytm,
                        ) = valuation_models.fixed_income_sensitivity_analysis(
                            PV_table,
                            TTM_array,
                            Total_amount_array,
                            1,
                            "D",
                            PV_output,
                            PV_plus_1bps,
                            PV_minus_1bps,
                        )
                        sensitivity_analysis.append(
                            {
                                "Macaulay Duration": macaulay_duration,
                                "Effective Duration": effective_duration,
                                "Modified Duration": modified_duration,
                                "PV01 per unit": PV01,
                            }
                        )
                        if isinstance(ytm, (np.ndarray)):
                            ytm = ytm[0]
                        else:
                            ytm = ytm
                        measure_dict_ytm = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": valuation_date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Yield to Maturity",
                            "measure_value": ytm,
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_ytm)
                        measure_dict_mac_dur = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": valuation_date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Macaulay Duration",
                            "measure_value": macaulay_duration,
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_mac_dur)
                        measure_dict_eff_dur = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": valuation_date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Effective Duration",
                            "measure_value": effective_duration,
                            "absolute_relative": "Relative",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_eff_dur)
                        measure_dict_mod_dur = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": valuation_date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Modified Duration",
                            "measure_value": modified_duration,
                            "absolute_relative": "Relative",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_mod_dur)
                        measure_dict_pv01 = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": valuation_date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "PV01 per unit",
                            "measure_value": PV01,
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_pv01)
                        measure_dict_pv01_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": valuation_date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "PV01",
                            "measure_value": PV01 * quantity,
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_pv01_position)
                else:
                    valuation_output = {
                        "PV": "None",
                    }
                    total_holding = "None"
                    valuation_results.append(valuation_output)

            else:
                sensitivity_analysis.append(
                    {
                        "Macaulay_Duration": "-",
                        "Effective Duration": "-",
                        "Modified_Duration": "-",
                        "PV01 per unit": "-",
                    }
                )
                valuation_output = {
                    "PV": "None",
                }
                total_holding = "None"
                valuation_results.append(valuation_output)

        else:
            sensitivity_analysis.append(
                {
                    "Macaulay_Duration": "-",
                    "Effective Duration": "-",
                    "Modified_Duration": "-",
                    "PV01 per unit": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        cashflow_model_results = cashflow_model_results.drop(["Interest_Paid", "Principal_Paid"], axis=1)
        cashflow_model_results["unique_reference_id"] = Unique_Reference_Id
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = unique_reference_id
        final_output_dict["Position_Id"] = position_id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = valuation_date[0]
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Quantity"] = quantity
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        measure_value = pd.DataFrame(measure_value)
        measure_value["currency"] = currency
        return final_output_dict, cashflow_model_results, measure_value

    # CCOD
    elif row[column_index_dict["model_code"]] == "M022":
        final_output_dict = {}
        unique_reference_id = row[column_index_dict["unique_reference_id"]]
        position_id = row[column_index_dict["position_id"]]
        valuation_date = np.array([row[column_index_dict["reporting_date"]]]).astype("datetime64[D]")
        accrual_daycount = row[column_index_dict["accrual_daycount_convention"]]
        accrual_convention_code = valuation_models.daycount_convention_code(accrual_daycount)
        discount_curve = row[column_index_dict["discounting_curve"]]
        asset_liability_type = row[column_index_dict["asset_liability_type"]]
        product_variant_name = row[column_index_dict["product_variant_name"]]
        fund = row[column_index_dict["fund_code"]]
        portfolio = row[column_index_dict["pool_id"]]
        entity = row[column_index_dict["legal_entity"]]
        next_payment_date = np.array([row[column_index_dict["next_payment_date"]]]).astype("datetime64[D]")
        maturity_date = np.array([row[column_index_dict["maturity_date"]]]).astype("datetime64[D]")

        payment_frequency = int(row[column_index_dict["payment_frequency"]])

        base_rate = float(row[column_index_dict["base_rate"]]) / 100
        margin = float(row[column_index_dict["fixed_spread"]]) / 100
        outstanding_amount = float(row[column_index_dict["unutilized_limit_amount"]])
        utilized_limit_amount = float(row[column_index_dict["outstanding_amount"]])

        reference_dimension = "Security"
        quantity = int(row[column_index_dict["quantity"]])
        cashflow_status = "Unrealised"
        valuation_results, sensitivity_analysis, PV_principal, measure_value = [], [], [], []
        NMD_Data = NMD_adjustments[
            [
                "product_variant_name",
                "scenario_analysis_id",
                "reporting_date",
                "start_tenor",
                "start_tenor_unit",
                "end_tenor",
                "end_tenor_unit",
                "percentage",
            ]
        ]
        arr = np.array(NMD_Data)
        NMD_Data = NMD_Data[NMD_Data["product_variant_name"] == product_variant_name]
        arr = np.array(NMD_Data)
        Percentage_Data = call_NMD(arr[0], NMD_Data).transpose()
        Allocated_arr = np.array(Percentage_Data)

        Date = Allocated_arr[2].astype("datetime64[D]")

        percentage = Allocated_arr[3].astype("float")

        result = CCOD_Cashflow(
            fund,
            portfolio,
            position_id,
            next_payment_date[0],
            payment_frequency,
            base_rate,
            margin,
            outstanding_amount,
            utilized_limit_amount,
            discount_curve,
            currency,
            Date,
            percentage,
            product_variant_name,
            valuation_date,
            entity,
            accrual_convention_code,
            asset_liability_type,
            maturity_date,
            custom_daycount_conventions,
        )
        index_values = [
            "extract_date",
            "transaction_date",
            "unique_reference_id",
            "reference_dimension",
            "cashflow_type",
            "cashflow_status",
            "cashflow",
            "time_to_maturity",
            "discount_factor",
            "present_value",
            "currency",
            "asset_liability_type",
            "product_variant_name",
            "fund",
            "portfolio",
            "cohort",
            "entity",
            "Interest_Paid",
            "Principal_Paid",
        ]
        cashflow_model_results = {
            "extract_date": Valuation_Date[0],
            "transaction_date": result[1],
            "unique_reference_id": Unique_Reference_Id,
            "reference_dimension": reference_dimension,
            "cashflow_type": result[4],
            "cashflow_status": cashflow_status,
            "cashflow": result[6],
            "time_to_maturity": result[7],
            "discount_factor": result[8],
            "present_value": result[9],
            "currency": currency,
            "asset_liability_type": asset_liability_type,
            "product_variant_name": product_variant_name,
            "fund": fund,
            "portfolio": portfolio,
            "cohort": None,
            "entity": entity,
            "Interest_Paid": result[17],
            "Principal_Paid": result[18],
        }
        cashflow_model_results = pd.DataFrame(cashflow_model_results)
        cashflow_model_results = cashflow_model_results.astype(
            {"time_to_maturity": "float64", "cashflow": "float64", "transaction_date": "datetime64[ns]"}
        )

        cashflow_model_results = cashflow_model_results.sort_values(by="transaction_date")
        cashflow_model_results = cashflow_model_results.drop(["Interest_Paid", "Principal_Paid"], axis=1)
        output_msg = output_check_fn(cashflow_results=cashflow_model_results)
        if output_msg["CF_Output"] == "Present":

            if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
                TTM = result[7].astype("float64")
                Total_Amount = np.where(
                    cashflow_model_results["cashflow_type"] == "Withdrawals",
                    cashflow_model_results["cashflow"] * -1,
                    cashflow_model_results["cashflow"],
                )
                Total_Amount = Total_Amount.astype("float64")
                Coupons = result[17].astype("float64")
                Principal = result[18].astype("float64")
                zero_rate_curve = discount_curve
                zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
                interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
                extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[0]
                tenor = np.array([0, *zero_rate_curve_points["tenor"]], dtype="float64")
                rates = np.array([0, *zero_rate_curve_points["rate"]], dtype="float64")
                zero_rates = np.empty([0], dtype="float64")
                for j in range(len(TTM)):
                    if interpolation_algorithm == "Linear":
                        if linearinterp(tenor, rates, TTM[j]) is None:
                            if extrapolation_algorithm == "Linear":
                                extrapolated_value = linearexterp(tenor, rates, TTM[j])
                            else:
                                extrapolated_value = flatexterp(tenor, rates, TTM[j])
                            zero_rates = np.append(zero_rates, extrapolated_value)
                        else:
                            interpolated_value = linearinterp(tenor, rates, TTM[j])
                            zero_rates = np.append(zero_rates, interpolated_value)
                zero_rates = zero_rates.astype("float64")
                (
                    PV_output,
                    PV_table,
                    TTM_array,
                    Total_amount_array,
                    DF,
                    PV_coupons,
                    PV_principal,
                    PV_plus_1bps,
                    PV_minus_1bps,
                ) = fixed_income_valuation(
                    TTM,
                    Total_Amount,
                    zero_rates,
                    Coupons,
                    Principal,
                    curve_compounding_frequency=curve_compounding_frequency,
                )
                cashflow_model_results["discount_factor"] = DF
                cashflow_model_results["present_value"] = PV_table

                del tenor, rates

                output_msg = output_check_fn(valuation_output=PV_output)

                if output_msg["Val_Output"] == "Present":
                    valuation_output = {
                        "PV": round(PV_output, 4),
                    }
                    measure_dict_val = {
                        "measure_run_date": datetime.now(),
                        "valuation_date": valuation_date[0],
                        "unique_reference_id": Unique_Reference_Id,
                        "position_id": Position_Id,
                        "reference_dimension": reference_dimension,
                        "measure_type": "Fair Value per unit",
                        "measure_value": round(PV_output, 4),
                        "absolute_relative": "Absolute",
                        "residual_maturity": TTM[-1],
                        "asset_liability_type": asset_liability_type,
                        "product_variant_name": product_variant_name,
                        "fund": fund,
                        "portfolio": portfolio,
                        "cohort": "",
                        "entity": entity[0],
                    }
                    measure_dict_val_position = {
                        "measure_run_date": datetime.now(),
                        "valuation_date": valuation_date[0],
                        "unique_reference_id": Unique_Reference_Id,
                        "position_id": Position_Id,
                        "reference_dimension": reference_dimension,
                        "measure_type": "Fair Value",
                        "measure_value": round(PV_output * quantity, 4),
                        "absolute_relative": "Absolute",
                        "residual_maturity": TTM_array[-1],
                        "asset_liability_type": asset_liability_type,
                        "product_variant_name": product_variant_name,
                        "fund": fund,
                        "portfolio": portfolio,
                        "cohort": "",
                        "entity": entity[0],
                    }
                    measure_value.append(measure_dict_val)
                    measure_value.append(measure_dict_val_position)
                    valuation_results.append(valuation_output)
                    total_holding = quantity * valuation_results[0]["PV"]

                    if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":
                        product_variant_list = [
                            "Current Account Deposits",
                            "Current Account Deposit - Bank",
                            "Letter of Credit",
                            "Bank Guarantees",
                        ]
                        exist_count = product_variant_list.count(product_variant_name)
                        if exist_count > 0:
                            sensitivity_analysis.append(
                                {
                                    "Macaulay_Duration": "-",
                                    "Effective Duration": "-",
                                    "Modified_Duration": "-",
                                    "PV01 per unit": "-",
                                }
                            )
                        else:

                            (
                                PV01,
                                macaulay_duration,
                                modified_duration,
                                effective_duration,
                                ytm,
                            ) = valuation_models.fixed_income_sensitivity_analysis(
                                PV_table,
                                TTM_array,
                                Total_amount_array,
                                1,
                                "D",
                                PV_output,
                                PV_plus_1bps,
                                PV_minus_1bps,
                            )
                            sensitivity_analysis.append(
                                {
                                    "Macaulay Duration": macaulay_duration,
                                    "Effective Duration": effective_duration,
                                    "Modified Duration": modified_duration,
                                    "PV01 per unit": PV01,
                                }
                            )
                            if isinstance(ytm, (np.ndarray)):
                                ytm = ytm[0]
                            else:
                                ytm = ytm
                            measure_dict_ytm = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": valuation_date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Yield to Maturity",
                                "measure_value": ytm,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity[0],
                            }
                            measure_value.append(measure_dict_ytm)
                            measure_dict_mac_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": valuation_date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Macaulay Duration",
                                "measure_value": macaulay_duration,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity[0],
                            }
                            measure_value.append(measure_dict_mac_dur)
                            measure_dict_eff_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": valuation_date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Effective Duration",
                                "measure_value": effective_duration,
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity[0],
                            }
                            measure_value.append(measure_dict_eff_dur)
                            measure_dict_mod_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": valuation_date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Modified Duration",
                                "measure_value": modified_duration,
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity[0],
                            }
                            measure_value.append(measure_dict_mod_dur)
                            measure_dict_pv01 = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": valuation_date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01 per unit",
                                "measure_value": PV01,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity[0],
                            }
                            measure_value.append(measure_dict_pv01)
                            measure_dict_pv01_position = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": valuation_date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01",
                                "measure_value": PV01 * quantity,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity[0],
                            }
                            measure_value.append(measure_dict_pv01_position)

                else:
                    valuation_output = {
                        "PV": "None",
                    }
                    total_holding = "None"
                    valuation_results.append(valuation_output)

            else:
                sensitivity_analysis.append(
                    {
                        "Macaulay_Duration": "-",
                        "Effective Duration": "-",
                        "Modified_Duration": "-",
                        "PV01 per unit": "-",
                    }
                )
                valuation_output = {
                    "PV": "None",
                }
                total_holding = "None"
                valuation_results.append(valuation_output)

        else:
            sensitivity_analysis.append(
                {
                    "Macaulay_Duration": "-",
                    "Effective Duration": "-",
                    "Modified_Duration": "-",
                    "PV01 per unit": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        cashflow_model_results["unique_reference_id"] = Unique_Reference_Id
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = unique_reference_id
        final_output_dict["Position_Id"] = position_id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = Valuation_Date[0]
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Quantity"] = quantity
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        measure_value = pd.DataFrame(measure_value)
        measure_value["currency"] = currency
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] == "M023":
        final_output_dict = {}
        position_id = row[column_index_dict["position_id"]]
        unique_reference_id = row[column_index_dict["unique_reference_id"]]
        custom_schedule_id = row[column_index_dict["custom_schedule_id"]]
        principal_payment_frequency = row[column_index_dict["principal_payment_frequency"]]
        principal_payment_frequency_unit = row[column_index_dict["principal_payment_frequency_unit"]]
        principal_payment_amount = row[column_index_dict["principal_payment_amount"]]
        issue_date = np.array([row[column_index_dict["issue_date"]]]).astype("datetime64[D]")
        valuation_date = np.array([row[column_index_dict["reporting_date"]]]).astype("datetime64[D]")
        convention_code = row[column_index_dict["business_convention"]]
        accrual_daycount = row[column_index_dict["accrual_daycount_convention"]]
        discount_daycount = row[column_index_dict["discount_daycount_convention"]]
        discount_convention_code = valuation_models.daycount_convention_code(discount_daycount)
        accrual_convention_code = valuation_models.daycount_convention_code(accrual_daycount)
        discount_daycount_convention_code = valuation_models.daycount_convention_code(accrual_daycount)
        discount_curve = row[column_index_dict["discounting_curve"]]
        asset_liability_type = row[column_index_dict["asset_liability_type"]]
        product_variant_name = row[column_index_dict["product_variant_name"]]
        moratorium_flag = row[column_index_dict["moratorium_flag"]]
        interest_moratorium_flag = row[column_index_dict["interest_moratorium_flag"]]
        moratorium_interest_capitalization = row[column_index_dict["moratorium_interest_capitalization"]]
        fund = row[column_index_dict["fund_code"]]
        portfolio = row[column_index_dict["pool_id"]]
        entity = row[column_index_dict["legal_entity"]]
        last_principal_payment_date = row[column_index_dict["last_principal_payment_date"]]
        if str(last_principal_payment_date) not in ["nan", "NaT", "None", "-"]:
            last_principal_payment_date = np.array(
                row[column_index_dict["last_principal_payment_date"]], dtype="datetime64[D]"
            )
        last_payment_date = row[column_index_dict["last_payment_date"]]
        if str(last_payment_date) not in ["nan", "NaT", "None", "-"]:
            last_payment_date = np.datetime64(row[column_index_dict["last_payment_date"]], "D")
        stub_date = row[column_index_dict["stub_date"]]
        if str(stub_date) not in ["nan", "NaT", "None", "-"]:
            stub_date = np.datetime64(row[column_index_dict["stub_date"]], "D")
        principal_stub_date = row[column_index_dict["principal_stub_date"]]
        if str(principal_stub_date) not in ["nan", "NaT", "None", "-"]:
            principal_stub_date = np.datetime64(row[column_index_dict["principal_stub_date"]], "D")
        payment_frequency = row[column_index_dict["payment_frequency"]]
        payment_frequency_unit = row[column_index_dict["payment_frequency_units"]]
        base_rate = float(row[column_index_dict["base_rate"]]) / 100
        if str(row[column_index_dict["fixed_spread"]]) not in ["", "nan", "None"]:
            fixed_spread = float(row[column_index_dict["fixed_spread"]]) / 100
        else:
            fixed_spread = 0
        accrued_interest = row[column_index_dict["accrued_interest"]]
        if str(accrued_interest) not in ["nan", "", "None"]:
            accrued_interest = float(accrued_interest)
        else:
            accrued_interest = 0
        outstanding_amount = float(row[column_index_dict["outstanding_amount"]])
        maturity_date = np.array([pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True)])
        reference_dimension = "Security"
        cashflow_status = "Unrealised"
        Credit_Spread_Rate = row[column_index_dict["credit_spread_rate"]]
        Credit_Spread_Curve = row[column_index_dict["credit_spread_curve"]]
        if str(row[column_index_dict["quantity"]]) in ["", "nan", "None"]:
            quantity = 1
        else:
            quantity = int(row[column_index_dict["quantity"]])
        if custom_schedule_id == "Y":
            repayment_schedule_position = repayment_schedule.loc[
                repayment_schedule["position_id"] == position_id
            ]
        else:
            repayment_schedule_position = None

        moratorium_end_date = row[column_index_dict["moratorium_end_date"]]
        fixed_float_flag = row[column_index_dict["fixed_or_float_flag"]]
        next_reset_date = row[column_index_dict["next_reset_date"]]
        if str(next_reset_date) not in ["nan", "NaT", "None", "-"]:
            next_reset_date = np.datetime64(row[column_index_dict["next_reset_date"]], "D")

        if moratorium_flag == "Y":
            if str(moratorium_end_date) in ["nan", "NaT", "None", "-"]:
                moratorium_period = row[column_index_dict["moratorium_period"]]
                moratorium_period_units = row[column_index_dict["moratorium_period_units"]]
                moratorium_period = valuation_models.coupon_Frequency(
                    moratorium_period, moratorium_period_units
                )
                moratorium_end_date = np.datetime64(
                    pd.to_datetime(issue_date[0]).date() + pd.DateOffset(months=int(12 / moratorium_period)),
                    "D",
                )
                if convention_code == "EOM":
                    moratorium_end_date = np.datetime64(conventions.eomonth(moratorium_end_date), "D")
                else:
                    moratorium_end_date = conventions.business_day(
                        moratorium_end_date, convention_code, holiday_calendar, business_days=business_days
                    )
            else:
                moratorium_end_date = np.datetime64(row[column_index_dict["moratorium_end_date"]], "D")
            if interest_moratorium_flag == "Y":
                if moratorium_interest_capitalization == "Yes":
                    moratorium_interest_calculation_methodology = row[
                        column_index_dict["interest_calculation_logic_moratorium"]
                    ]
                    if moratorium_end_date >= valuation_date[0]:
                        if str(accrued_interest) not in ["", "nan", "None"]:
                            year_frac = conventions.D_day_count(
                                np.array(valuation_date[0], dtype="datetime64[D]"),
                                np.array(moratorium_end_date, dtype="datetime64[D]"),
                                accrual_convention_code,
                                custom_daycount_conventions=custom_daycount_conventions,
                            )
                            if moratorium_interest_calculation_methodology == "Simple":
                                moratorium_interest = (
                                    outstanding_amount * (base_rate + fixed_spread) * year_frac
                                )
                            else:
                                compounding_frequency = row[column_index_dict["compounding_frequency"]]
                                compounding_frequency_unit = row[
                                    column_index_dict["compounding_frequency_unit"]
                                ]

                                moratorium_interest = compound_interest_calculation_formula(
                                    compounding_frequency,
                                    compounding_frequency_unit,
                                    year_frac,
                                    outstanding_amount + accrued_interest,
                                    base_rate + fixed_spread,
                                )
                            total_interest_capitalization = accrued_interest + moratorium_interest
                        else:
                            year_frac = conventions.D_day_count(
                                np.array(issue_date[0], dtype="datetime64[D]"),
                                np.array(moratorium_end_date, dtype="datetime64[D]"),
                                accrual_convention_code,
                                custom_daycount_conventions=custom_daycount_conventions,
                            )
                            if moratorium_interest_calculation_methodology == "Simple":
                                total_interest_capitalization = (
                                    outstanding_amount * (base_rate + fixed_spread) * year_frac
                                )
                            else:
                                compounding_frequency = row[column_index_dict["compounding_frequency"]]
                                compounding_frequency_unit = row[
                                    column_index_dict["compounding_frequency_unit"]
                                ]
                                total_interest_capitalization = compound_interest_calculation_formula(
                                    compounding_frequency,
                                    compounding_frequency_unit,
                                    year_frac,
                                    outstanding_amount,
                                    base_rate + fixed_spread,
                                )

                        outstanding_amount = outstanding_amount + total_interest_capitalization
                        accrued_interest = 0
                    else:
                        if str(accrued_interest) in ["", "nan", "None"]:
                            if (
                                str(last_payment_date) not in ["nan", "NaT", "None", "-"]
                                and last_payment_date >= moratorium_end_date
                            ):
                                year_frac = conventions.D_day_count(
                                    np.array(last_payment_date, dtype="datetime64[D]"),
                                    np.array(valuation_date[0], dtype="datetime64[D]"),
                                    accrual_convention_code,
                                    custom_daycount_conventions=custom_daycount_conventions,
                                )
                                accrued_interest = outstanding_amount * (base_rate + fixed_spread) * year_frac
                            else:
                                year_frac_post_moratorium = conventions.D_day_count(
                                    np.array(moratorium_end_date, dtype="datetime64[D]"),
                                    np.array(valuation_date[0], dtype="datetime64[D]"),
                                    accrual_convention_code,
                                    custom_daycount_conventions=custom_daycount_conventions,
                                )
                                accrued_interest = (
                                    outstanding_amount
                                    * (base_rate + fixed_spread)
                                    * year_frac_post_moratorium
                                )

        interest_overdue = row[column_index_dict["interest_overdue_amount"]]
        principal_overdue = row[column_index_dict["principal_overdue_amount"]]
        charges_overdue = row[column_index_dict["charges_overdue_amount"]]
        # # # # # # # # # #
        valuation_results = []
        sensitivity_analysis = []
        PV_principal = []
        measure_value = []

        # Cashflow # Model_Id, GL_Code
        cashflow_results_output = repayment_loans(
            unique_reference_id,
            issue_date,
            last_payment_date,
            last_principal_payment_date,
            maturity_date,
            base_rate,
            fixed_spread,
            payment_frequency,
            payment_frequency_unit,
            principal_payment_frequency,
            principal_payment_frequency_unit,
            outstanding_amount,
            convention_code,
            valuation_date,
            principal_payment_amount,
            custom_schedule_id,
            repayment_schedule_position,
            holiday_calendar,
            accrual_convention_code,
            discount_daycount_convention_code,
            accrued_interest,
            custom_daycount_conventions,
            stub_date=stub_date,
            principal_stub_date=principal_stub_date,
            business_days=business_days,
            moratorium_end_date=moratorium_end_date,
            moratorium_flag=moratorium_flag,
            interest_moratorium_flag=interest_moratorium_flag,
        )
        cashflow_model_results = {
            "extract_date": valuation_date[0],
            "transaction_date": cashflow_results_output[0],
            "unique_reference_id": Unique_Reference_Id,
            "reference_dimension": reference_dimension,
            "cashflow_type": cashflow_results_output[3],
            "cashflow_status": cashflow_status,
            "cashflow": cashflow_results_output[2],
            "time_to_maturity": cashflow_results_output[1],
            "discount_factor": None,
            "present_value": None,
            "currency": currency,
            "asset_liability_type": asset_liability_type,
            "product_variant_name": product_variant_name,
            "fund": fund,
            "portfolio": portfolio,
            "cohort": "",
            "entity": entity,
            "principal_outstanding_beginning": cashflow_results_output[4],
            "principal_outstanding_ending": cashflow_results_output[5],
        }
        cashflow_model_results = pd.DataFrame(cashflow_model_results)
        accrued_interest_ttm = cashflow_model_results["time_to_maturity"].iloc[0]
        cashflow_model_results, dpd_cashflows = overdue_cashflow_calculations(
            position_id,
            cashflow_model_results,
            dpd_schedule,
            dpd_ruleset,
            overdue_bucketing_data,
            valuation_date,
            Unique_Reference_Id,
            reference_dimension,
            cashflow_status,
            currency,
            asset_liability_type,
            product_variant_name,
            fund,
            portfolio,
            entity,
            interest_overdue,
            principal_overdue,
            charges_overdue,
        )
        cashflow_model_results = cashflow_model_results.astype(
            {"time_to_maturity": "float64", "cashflow": "float64", "transaction_date": "datetime64[ns]"}
        )
        cashflow_model_results = cashflow_model_results.sort_values(by=["transaction_date", "cashflow_type"])
        measure_value = []
        output_msg = output_check_fn(cashflow_results=cashflow_model_results)

        if output_msg["CF_Output"] == "Present":
            if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
                TTM = cashflow_model_results["time_to_maturity"].to_numpy(dtype="float64")
                Total_Amount = cashflow_model_results["cashflow"].to_numpy(dtype="float64")
                zero_rate_curve = discount_curve
                zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
                interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
                extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[0]
                tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                zero_rates = np.empty([0], dtype="float64")
                for j in range(len(TTM)):
                    if interpolation_algorithm == "Linear":
                        if linearinterp(tenor, rates, TTM[j]) is None:
                            if extrapolation_algorithm == "Linear":
                                extrapolated_value = linearexterp(tenor, rates, TTM[j])
                            else:
                                extrapolated_value = flatexterp(tenor, rates, TTM[j])
                            zero_rates = np.append(zero_rates, extrapolated_value)
                        else:
                            interpolated_value = linearinterp(tenor, rates, TTM[j])
                            zero_rates = np.append(zero_rates, interpolated_value)

                # Add Credit Spread Rate to zero_rates
                if str(Credit_Spread_Rate) not in ["nan", "None"]:
                    zero_rates = zero_rates + float(Credit_Spread_Rate)
                elif str(Credit_Spread_Curve) not in ["nan", "None"]:
                    credit_spread_curve_data = credit_spread_data.loc[
                        (credit_spread_data["credit_spread_curve_name"] == Credit_Spread_Curve), :
                    ]
                    cs_interpolation_algorithm = credit_spread_curve_data["interpolation_algorithm"].iloc[0]
                    cs_extrapolation_algorithm = credit_spread_curve_data["extrapolation_algorithm"].iloc[0]

                    if not credit_spread_curve_data.empty:
                        spread_tenor = credit_spread_curve_data.tenor.to_numpy()
                        spread_tenor_unit = credit_spread_curve_data.tenor_unit.to_numpy()
                        tenor_extrac = np.vectorize(tenor_extraction)
                        spread_tenor = tenor_extrac(spread_tenor, spread_tenor_unit)
                        spread_rates = credit_spread_curve_data.spread_value.to_numpy()
                        credit_spread_rates = np.empty([0], dtype="float64")

                        for j in TTM:
                            interp_val = linearinterp(spread_tenor, spread_rates, j)
                            if interp_val is None:
                                if cs_extrapolation_algorithm == "Linear":
                                    extrapolated_value = linearexterp(spread_tenor, spread_rates, j)
                                else:
                                    extrapolated_value = flatexterp(spread_tenor, spread_rates, j)
                                credit_spread_rates = np.append(credit_spread_rates, extrapolated_value)
                            else:
                                interpolated_value = interp_val
                                credit_spread_rates = np.append(credit_spread_rates, interpolated_value)
                        zero_rates = zero_rates + credit_spread_rates

                zero_rates = zero_rates.astype("float64")
                (
                    PV_output,
                    PV_table,
                    TTM_array,
                    Total_amount_array,
                    DF,
                    PV_coupons,
                    PV_principal,
                    PV_plus_1bps,
                    PV_minus_1bps,
                ) = fixed_income_valuation(
                    TTM,
                    Total_Amount,
                    zero_rates,
                    Total_Amount,
                    Total_Amount,
                    curve_compounding_frequency=curve_compounding_frequency,
                )

                cashflow_model_results["discount_factor"] = DF
                cashflow_model_results["present_value"] = PV_table
                output_msg = output_check_fn(valuation_output=PV_output)

                if output_msg["Val_Output"] == "Present":
                    valuation_output = {
                        "PV": round(PV_output, 4),
                    }
                    measure_dict_val = {
                        "measure_run_date": datetime.now(),
                        "valuation_date": valuation_date[0],
                        "unique_reference_id": Unique_Reference_Id,
                        "position_id": Position_Id,
                        "reference_dimension": reference_dimension,
                        "measure_type": "Fair Value per unit",
                        "measure_value": round(PV_output, 4),
                        "absolute_relative": "Absolute",
                        "residual_maturity": TTM[-1],
                        "asset_liability_type": asset_liability_type,
                        "product_variant_name": product_variant_name,
                        "fund": fund,
                        "portfolio": portfolio,
                        "cohort": "",
                        "entity": entity,
                    }
                    measure_dict_val_position = {
                        "measure_run_date": datetime.now(),
                        "valuation_date": valuation_date[0],
                        "unique_reference_id": Unique_Reference_Id,
                        "position_id": Position_Id,
                        "reference_dimension": reference_dimension,
                        "measure_type": "Fair Value",
                        "measure_value": round(PV_output * quantity, 4),
                        "absolute_relative": "Absolute",
                        "residual_maturity": TTM_array[-1],
                        "asset_liability_type": asset_liability_type,
                        "product_variant_name": product_variant_name,
                        "fund": fund,
                        "portfolio": portfolio,
                        "cohort": "",
                        "entity": entity,
                    }
                    measure_value.append(measure_dict_val)
                    measure_value.append(measure_dict_val_position)
                    valuation_results.append(valuation_output)
                    total_holding = quantity * valuation_results[0]["PV"]

                    if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":
                        if fixed_float_flag == "Float":
                            cashflow_model_results["zero_rates"] = zero_rates
                            interest_date_reset_check = cashflow_model_results.loc[
                                (cashflow_model_results["transaction_date"] == next_reset_date)
                                & (cashflow_model_results["cashflow_type"] == "Interest Proceeds")
                            ]
                            principal_date_check = cashflow_model_results.loc[
                                (
                                    cashflow_model_results["cashflow_type"].isin(
                                        ["Principal Amount", "Redemption Proceeds", "Principal Proceeds"]
                                    )
                                )
                                & (cashflow_model_results["transaction_date"] < next_reset_date)
                            ]
                            # All interest cashflows before and on next reset date and principal cashflows
                            reset_filterered_df = cashflow_model_results.loc[
                                (
                                    (
                                        cashflow_model_results["cashflow_type"].isin(
                                            ["Principal Amount", "Redemption Proceeds", "Principal Proceeds"]
                                        )
                                    )
                                    & (cashflow_model_results["transaction_date"] < next_reset_date)
                                )
                                | (
                                    (
                                        cashflow_model_results["cashflow_type"].isin(
                                            [
                                                "Interest Proceeds",
                                                "Charges Overdue",
                                                "Interest Overdue",
                                                "Principal Overdue",
                                            ]
                                        )
                                    )
                                    & (cashflow_model_results["transaction_date"] <= next_reset_date)
                                )
                            ]
                            reset_maturity = conventions.A_day_count(
                                Valuation_Date[0],
                                next_reset_date,
                                discount_convention_code,
                                custom_daycount_conventions=custom_daycount_conventions,
                            )

                            # Case 1 - No principal cashflows before reset date
                            if len(principal_date_check) == 0:
                                reset_df_principal = cashflow_model_results.loc[
                                    (cashflow_model_results["cashflow_type"] == "Interest Proceeds")
                                ].head(1)
                                reset_df_principal["cashflow_type"] = "Principal Amount"
                                reset_df_principal["cashflow"] = outstanding_amount
                                reset_df_principal["transaction_date"] = next_reset_date
                                reset_df_principal["time_to_maturity"] = reset_maturity
                                reset_filterered_df = pd.concat(
                                    [reset_filterered_df, reset_df_principal], ignore_index=True
                                )

                            # Case 2 - Principal cashflows on or before reset date
                            else:
                                reset_df_principal = cashflow_model_results.loc[
                                    (cashflow_model_results["cashflow_type"] == "Interest Proceeds")
                                ].head(1)
                                reset_df_principal["cashflow_type"] = "Principal Amount"
                                principal_outstanding = cashflow_model_results.loc[
                                    (
                                        cashflow_model_results["cashflow_type"].isin(
                                            ["Principal Amount", "Redemption Proceeds", "Principal Proceeds"]
                                        )
                                    )
                                    & (cashflow_model_results["transaction_date"] >= next_reset_date)
                                ]["cashflow"].sum()
                                reset_df_principal["cashflow"] = principal_outstanding
                                reset_df_principal["transaction_date"] = next_reset_date
                                reset_df_principal["time_to_maturity"] = reset_maturity
                                reset_filterered_df = pd.concat(
                                    [reset_filterered_df, reset_df_principal], ignore_index=True
                                )

                            if len(interest_date_reset_check) == 0:
                                interest_till_reset_dict = reset_filterered_df.loc[
                                    (
                                        reset_filterered_df["cashflow_type"].isin(
                                            ["Principal Amount", "Redemption Proceeds", "Principal Proceeds"]
                                        )
                                    )
                                    & (reset_filterered_df["transaction_date"] == next_reset_date)
                                ].to_dict("records")
                                previous_payment_date = cashflow_model_results.loc[
                                    (cashflow_model_results["transaction_date"] < next_reset_date)
                                    & (cashflow_model_results["cashflow_type"] == "Interest Proceeds")
                                ]
                                if len(previous_payment_date) > 0:
                                    previous_payment_date_val = np.datetime64(
                                        pd.to_datetime(
                                            previous_payment_date["transaction_date"].max(), dayfirst=True
                                        ).date()
                                    )
                                    interest_cashflow = 0
                                    val_date_check = False
                                else:
                                    previous_payment_date_val = last_payment_date
                                    val_date_check = True
                                    interest_cashflow = accrued_interest

                                principal_payment_dates_between_previous_interest_payment_and_reset = (
                                    cashflow_model_results.loc[
                                        (
                                            cashflow_model_results["cashflow_type"].isin(
                                                [
                                                    "Principal Amount",
                                                    "Redemption Proceeds",
                                                    "Principal Proceeds",
                                                ]
                                            )
                                        )
                                        & (cashflow_model_results["transaction_date"] < next_reset_date)
                                        & (
                                            cashflow_model_results["transaction_date"]
                                            > previous_payment_date_val
                                        ),
                                        "transaction_date",
                                    ].tolist()
                                )
                                interest_rate = base_rate + fixed_spread

                                if (
                                    len(principal_payment_dates_between_previous_interest_payment_and_reset)
                                    != 0
                                ):
                                    for i in range(
                                        0,
                                        len(
                                            principal_payment_dates_between_previous_interest_payment_and_reset
                                        ),
                                    ):
                                        principal_outstanding_beginning = cashflow_model_results.loc[
                                            (
                                                cashflow_model_results["cashflow_type"].isin(
                                                    [
                                                        "Principal Amount",
                                                        "Redemption Proceeds",
                                                        "Principal Proceeds",
                                                    ]
                                                )
                                            )
                                            & (
                                                cashflow_model_results["transaction_date"]
                                                == principal_payment_dates_between_previous_interest_payment_and_reset[
                                                    i
                                                ]
                                            ),
                                            "principal_outstanding_ending",
                                        ]
                                        if (
                                            i
                                            == principal_payment_dates_between_previous_interest_payment_and_reset[
                                                -1
                                            ]
                                        ):
                                            if (
                                                len(
                                                    principal_payment_dates_between_previous_interest_payment_and_reset
                                                )
                                                == 1
                                            ):
                                                if val_date_check:
                                                    year_frac = conventions.A_day_count(
                                                        valuation_date[0],
                                                        next_reset_date,
                                                        accrual_convention_code,
                                                        custom_daycount_conventions=custom_daycount_conventions,
                                                    )
                                                else:
                                                    year_frac = conventions.A_day_count(
                                                        previous_payment_date_val,
                                                        next_reset_date,
                                                        accrual_convention_code,
                                                        custom_daycount_conventions=custom_daycount_conventions,
                                                    )
                                            else:
                                                year_frac = conventions.A_day_count(
                                                    principal_payment_dates_between_previous_interest_payment_and_reset[
                                                        i - 1
                                                    ],
                                                    next_reset_date,
                                                    accrual_convention_code,
                                                    custom_daycount_conventions=custom_daycount_conventions,
                                                )
                                        else:
                                            if (
                                                len(
                                                    principal_payment_dates_between_previous_interest_payment_and_reset
                                                )
                                                == 1
                                            ):
                                                if val_date_check:
                                                    year_frac = conventions.A_day_count(
                                                        valuation_date[0],
                                                        principal_payment_dates_between_previous_interest_payment_and_reset[
                                                            i
                                                        ],
                                                        accrual_convention_code,
                                                        custom_daycount_conventions=custom_daycount_conventions,
                                                    )
                                                else:
                                                    year_frac = conventions.A_day_count(
                                                        previous_payment_date_val,
                                                        principal_payment_dates_between_previous_interest_payment_and_reset[
                                                            i
                                                        ],
                                                        accrual_convention_code,
                                                        custom_daycount_conventions=custom_daycount_conventions,
                                                    )
                                            else:
                                                year_frac = conventions.A_day_count(
                                                    principal_payment_dates_between_previous_interest_payment_and_reset[
                                                        i - 1
                                                    ],
                                                    principal_payment_dates_between_previous_interest_payment_and_reset[
                                                        i
                                                    ],
                                                    accrual_convention_code,
                                                    custom_daycount_conventions=custom_daycount_conventions,
                                                )
                                        interest_cashflow += (
                                            principal_outstanding_beginning * year_frac * interest_rate
                                        )
                                else:
                                    if val_date_check:
                                        year_frac = conventions.A_day_count(
                                            valuation_date[0],
                                            next_reset_date,
                                            accrual_convention_code,
                                            custom_daycount_conventions=custom_daycount_conventions,
                                        )
                                        interest_cashflow += outstanding_amount * year_frac * interest_rate
                                    else:
                                        year_frac = conventions.A_day_count(
                                            previous_payment_date_val,
                                            next_reset_date,
                                            accrual_convention_code,
                                            custom_daycount_conventions=custom_daycount_conventions,
                                        )
                                        previous_principal_payment_date = cashflow_model_results.loc[
                                            (
                                                cashflow_model_results["cashflow_type"].isin(
                                                    [
                                                        "Principal Amount",
                                                        "Redemption Proceeds",
                                                        "Principal Proceeds",
                                                    ]
                                                )
                                            )
                                            & (
                                                cashflow_model_results["transaction_date"]
                                                <= previous_payment_date_val
                                            ),
                                            "transaction_date",
                                        ].max()
                                        outstanding_amount = cashflow_model_results.loc[
                                            (
                                                cashflow_model_results["cashflow_type"].isin(
                                                    [
                                                        "Principal Amount",
                                                        "Redemption Proceeds",
                                                        "Principal Proceeds",
                                                    ]
                                                )
                                            )
                                            & (
                                                cashflow_model_results["transaction_date"]
                                                == previous_principal_payment_date
                                            ),
                                            "principal_outstanding_ending",
                                        ].iloc[0]
                                        interest_cashflow += outstanding_amount * year_frac * interest_rate

                                interest_till_reset_dict[0]["cashflow"] = interest_cashflow
                                interest_till_reset_dict[0]["cashflow_type"] = "Interest Proceeds"
                                reset_filterered_df = pd.concat(
                                    [reset_filterered_df, pd.DataFrame(interest_till_reset_dict)],
                                    ignore_index=True,
                                )

                            reset_zero_rate = linearinterp(tenor, rates, reset_maturity)
                            if reset_zero_rate is None:
                                if extrapolation_algorithm == "Linear":
                                    reset_zero_rate = linearexterp(tenor, rates, reset_maturity)
                                else:
                                    reset_zero_rate = flatexterp(tenor, rates, reset_maturity)

                            if str(Credit_Spread_Rate) not in ["nan", "None"]:
                                reset_zero_rate = reset_zero_rate + float(Credit_Spread_Rate)
                            elif str(Credit_Spread_Curve) not in ["nan", "None"]:
                                if not credit_spread_curve_data.empty:
                                    reset_credit_spread = linearinterp(
                                        spread_tenor, spread_rates, reset_maturity
                                    )
                                    if reset_credit_spread is None:
                                        if cs_extrapolation_algorithm == "Linear":
                                            reset_credit_spread = linearexterp(
                                                spread_tenor, spread_rates, reset_maturity
                                            )
                                        else:
                                            reset_credit_spread = flatexterp(
                                                spread_tenor, spread_rates, reset_maturity
                                            )
                                        credit_spread_rates = np.append(
                                            credit_spread_rates, reset_credit_spread
                                        )
                                    reset_zero_rate = reset_zero_rate + reset_credit_spread

                            reset_filterered_df.loc[
                                reset_filterered_df["transaction_date"] == next_reset_date, "zero_rates"
                            ] = reset_zero_rate

                            (
                                PV_output_sens,
                                PV_table_sens,
                                TTM_array_sens,
                                Total_amount_array_sens,
                                DF_sens,
                                PV_coupons_sens,
                                PV_principal_sens,
                                PV_plus_1bps_sens,
                                PV_minus_1bps_sens,
                            ) = fixed_income_valuation(
                                (reset_filterered_df["time_to_maturity"].to_numpy()).astype("float64"),
                                (reset_filterered_df["cashflow"].to_numpy()).astype("float64"),
                                (reset_filterered_df["zero_rates"].to_numpy()).astype("float64"),
                                (reset_filterered_df["cashflow"].to_numpy()).astype("float64"),
                                (reset_filterered_df["cashflow"].to_numpy()).astype("float64"),
                                curve_compounding_frequency=curve_compounding_frequency,
                            )

                            (
                                PV01,
                                macaulay_duration,
                                modified_duration,
                                effective_duration,
                                ytm,
                            ) = valuation_models.fixed_income_sensitivity_analysis(
                                PV_table_sens,
                                TTM_array_sens,
                                Total_amount_array_sens,
                                payment_frequency,
                                payment_frequency_unit,
                                PV_output_sens,
                                PV_plus_1bps_sens,
                                PV_minus_1bps_sens,
                            )
                        else:
                            (
                                PV01,
                                macaulay_duration,
                                modified_duration,
                                effective_duration,
                                ytm,
                            ) = valuation_models.fixed_income_sensitivity_analysis(
                                PV_table,
                                TTM_array,
                                Total_amount_array,
                                payment_frequency,
                                payment_frequency_unit,
                                PV_output,
                                PV_plus_1bps,
                                PV_minus_1bps,
                            )

                        sensitivity_analysis.append(
                            {
                                "Macaulay Duration": macaulay_duration,
                                "Effective Duration": effective_duration,
                                "Modified Duration": modified_duration,
                                "PV01 per unit": PV01,
                            }
                        )
                        if isinstance(ytm, (np.ndarray)):
                            ytm = ytm[0]
                        else:
                            ytm = ytm
                        measure_dict_ytm = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": valuation_date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Yield to Maturity",
                            "measure_value": ytm,
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_ytm)
                        measure_dict_mac_dur = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": valuation_date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Macaulay Duration",
                            "measure_value": macaulay_duration,
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_mac_dur)
                        measure_dict_eff_dur = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": valuation_date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Effective Duration",
                            "measure_value": effective_duration,
                            "absolute_relative": "Relative",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_eff_dur)
                        measure_dict_mod_dur = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": valuation_date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Modified Duration",
                            "measure_value": modified_duration,
                            "absolute_relative": "Relative",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_mod_dur)
                        measure_dict_pv01 = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": valuation_date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "PV01 per unit",
                            "measure_value": PV01,
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_pv01)
                        measure_dict_pv01_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": valuation_date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "PV01",
                            "measure_value": PV01 * quantity,
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_pv01_position)

                else:
                    valuation_output = {
                        "PV": "None",
                    }
                    total_holding = "None"
                    valuation_results.append(valuation_output)

            else:
                sensitivity_analysis.append(
                    {
                        "Macaulay_Duration": "-",
                        "Effective Duration": "-",
                        "Modified_Duration": "-",
                        "PV01 per unit": "-",
                    }
                )
                valuation_output = {
                    "PV": "None",
                }
                total_holding = "None"
                valuation_results.append(valuation_output)

        else:
            sensitivity_analysis.append(
                {
                    "Macaulay_Duration": "-",
                    "Effective Duration": "-",
                    "Modified_Duration": "-",
                    "PV01 per unit": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        if accrued_interest != 0:
            cashflow_model_results = pd.concat(
                [cashflow_model_results, cashflow_model_results.iloc[[-1]]], ignore_index=True
            )
            if str(Quantity) in ["", "nan", "None"]:
                Quantity = 1
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow")] = (
                accrued_interest * Quantity
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow_type")] = (
                "Accrued Interest"
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("transaction_date")] = (
                pd.to_datetime(valuation_date[0])
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("present_value")] = None
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("time_to_maturity")] = (
                accrued_interest_ttm
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("discount_factor")] = None
            cashflow_model_results = cashflow_model_results.sort_values(
                by=["transaction_date", "cashflow_type"], ascending=True
            )
        cashflow_model_results["unique_reference_id"] = Unique_Reference_Id

        if "zero_rates" in cashflow_model_results.columns.tolist():
            cashflow_model_results.drop(
                columns=["principal_outstanding_beginning", "principal_outstanding_ending", "zero_rates"],
                inplace=True,
            )
        else:
            cashflow_model_results.drop(
                columns=["principal_outstanding_beginning", "principal_outstanding_ending"], inplace=True
            )

        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = unique_reference_id
        final_output_dict["Position_Id"] = position_id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = valuation_date[0]
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Quantity"] = quantity
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        measure_value = pd.DataFrame(measure_value)
        measure_value["currency"] = currency
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] == "M024":  # for chooser option
        Underlying_pos_id = np.array([row[column_index_dict["underlying_position_id"]]])
        Discount_Daycount = np.array([row[column_index_dict["discount_daycount_convention"]]])
        Maturity_Date = np.array([np.datetime64(row[column_index_dict["maturity_date"]], "D")])

        if "choosing_date" in column_index_dict.keys():  # checks if column choosing_date is present
            Chooser_Date = np.array(np.datetime64(row[column_index_dict["choosing_date"]], "D"))
        else:
            Chooser_Date = Maturity_Date
        spot_price = mtm_data[
            (mtm_data["security_identifier"] == Underlying_pos_id[0])
            & (mtm_data["extract_date"] == Valuation_Date[0])
        ]["quoted_price"].iloc[0]
        strike_price = np.array([row[column_index_dict["strike_price"]]])

        discount_convention_code = valuation_models.daycount_convention_code(Discount_Daycount)
        TTM_array = conventions.D_day_count(
            Valuation_Date,
            Maturity_Date,
            discount_convention_code,
            custom_daycount_conventions=custom_daycount_conventions,
        )
        Chooser_Date_array = conventions.D_day_count(
            Valuation_Date,
            Chooser_Date,
            discount_convention_code,
            custom_daycount_conventions=custom_daycount_conventions,
        )  # change

        vix = vix_data[(vix_data["extract_date"] == Valuation_Date[0])]["vix"].iloc[0]

        sigma = np.sqrt(vix) / 100

        Discount_Curve = np.array([row[column_index_dict["discounting_curve"]]])

        cashflow_results = [
            Valuation_Date[0],
            "-",
            Position_Id,
            reference_dimension,
            "-",
            "-",
            "-",
            "-",
            "-",
            "-",
            currency,
            asset_liability_type,
            product_variant_name,
            fund,
            portfolio,
            "",
            entity,
        ]
        index_values = [
            "extract_date",
            "transaction_date",
            "unique_reference_id",
            "reference_dimension",
            "cashflow_type",
            "cashflow_status",
            "cashflow",
            "time_to_maturity",
            "discount_factor",
            "present_value",
            "currency",
            "asset_liability_type",
            "product_variant_name",
            "fund",
            "portfolio",
            "cohort",
            "entity",
        ]
        measure_value = []
        cashflow_model_results = pd.DataFrame(data=cashflow_results, index=index_values).transpose()
        valuation_results = []
        sensitivity_analysis = []

        if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
            zero_rate_curve = Discount_Curve[0]
            zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
            interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
            extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
            tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
            rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
            if interpolation_algorithm == "Linear":
                if linearinterp(tenor, rates, TTM_array[0]) is None:
                    if extrapolation_algorithm == "Linear":
                        zero_rate = linearexterp(tenor, rates, TTM_array[0])
                    else:
                        zero_rate = flatexterp(tenor, rates, TTM_array[0])
                else:
                    zero_rate = linearinterp(tenor, rates, TTM_array[0])

            CO = Options_Pricing.Chooser_Option(
                S=spot_price,
                K=strike_price[0].astype(float),
                T=TTM_array[0].astype(float),
                r=zero_rate,
                sigma=sigma,
                tao=Chooser_Date_array[0].astype(
                    float
                ),  # change. Tao indicates time to choose. However, in the positional data available for portfolio val, chooser date is not available.
            )

            if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                price_df = CO.price()  # estimates price of chooser option
            else:
                price_df = mtm_data[
                    (mtm_data["security_identifier"] == Unique_Reference_Id)
                    & (mtm_data["extract_date"] == Valuation_Date[0])
                ]["quoted_price"]
                price_df = price_df.iloc[0]

            price = price_df
            total_holding = np.round(Quantity * price, 4)
            valuation_output = {
                "PV": np.round(price, 4),
            }
            measure_dict_val = {
                "measure_run_date": datetime.now(),
                "valuation_date": Valuation_Date[0],
                "unique_reference_id": Unique_Reference_Id,
                "position_id": Position_Id,
                "reference_dimension": reference_dimension,
                "measure_type": "Fair Value per unit",
                "measure_value": np.round(price, 4),
                "absolute_relative": "Absolute",
                "residual_maturity": TTM_array[-1],
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": "",
                "entity": entity,
            }
            measure_dict_val_position = {
                "measure_run_date": datetime.now(),
                "valuation_date": Valuation_Date[0],
                "unique_reference_id": Unique_Reference_Id,
                "position_id": Position_Id,
                "reference_dimension": reference_dimension,
                "measure_type": "Fair Value",
                "measure_value": np.round(price * Quantity, 4),
                "absolute_relative": "Absolute",
                "residual_maturity": TTM_array[-1],
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": "",
                "entity": entity,
            }
            measure_value.append(measure_dict_val)
            measure_value.append(measure_dict_val_position)

            valuation_results.append(valuation_output)

            if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":

                delta_val = np.round(CO.delta(), 4)
                gamma_val = np.round(CO.gamma(), 4)
                rho_val = np.round(CO.rho(), 4)
                vega_val = np.round(CO.vega(), 4)

                measure_dict_delta = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Delta",
                    "measure_value": delta_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_gamma = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Gamma",
                    "measure_value": gamma_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_rho = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Rho",
                    "measure_value": rho_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_vega = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Vega",
                    "measure_value": vega_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_value.append(measure_dict_delta)
                measure_value.append(measure_dict_gamma)
                measure_value.append(measure_dict_rho)
                measure_value.append(measure_dict_vega)

                sensitivity_analysis.append(
                    {
                        "Delta": delta_val,
                        "Gamma": gamma_val,
                        "Rho": rho_val,
                        "Vega": vega_val,
                    }
                )

        else:
            sensitivity_analysis.append(
                {
                    "Delta": "-",
                    "Gamma": "-",
                    "Rho": "-",
                    "Vega": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        final_output_dict = {}
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = Unique_Reference_Id
        final_output_dict["Position_Id"] = Position_Id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = pd.to_datetime(Valuation_Date[0]).strftime("%Y-%m-%d")
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Quantity"] = Quantity
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        cashflow_model_results = cashflow_model_results[cashflow_model_results["time_to_maturity"] != "-"]
        measure_value = pd.DataFrame(measure_value)
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] in ["M025", "M042"]:  # For Barrier Options
        Underlying_pos_id = np.array([row[column_index_dict["underlying_position_id"]]])
        Discount_Daycount = np.array([row[column_index_dict["discount_daycount_convention"]]])
        Maturity_Date = np.array(
            [pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True).strftime("%Y-%m-%d")]
        )
        MaturityDate = Maturity_Date.astype("datetime64[D]")
        position_direction = row[column_index_dict["position_direction"]]
        strike_price = np.array([row[column_index_dict["strike_price"]]])
        volatility_surface = row[column_index_dict["volatility_surface_id"]]
        if str(volatility_surface) not in ["nan", "NaT", "None", "-"]:
            vol_data_filtered = vol_data.loc[vol_data["surface_name"] == volatility_surface]
        else:
            vol_data_filtered = []
        discount_convention_code = valuation_models.daycount_convention_code(Discount_Daycount)
        TTM_array = conventions.D_day_count(
            Valuation_Date,
            MaturityDate,
            discount_convention_code,
            custom_daycount_conventions=discount_convention_code,
        )
        barrier_price = np.array([row[column_index_dict["barrier_price"]]])
        barrier_hit_status = row[column_index_dict["barrier_hit_status"]]
        rebate = np.array([row[column_index_dict["rebate"]]])
        option_type = np.array([row[column_index_dict["option_style"]]])

        if row[column_index_dict["model_code"]] == "M042":
            primary_currency = row[column_index_dict["primary_currency"]]
            secondary_currency = row[column_index_dict["secondary_currency"]]
            currency_pair = secondary_currency + primary_currency
            spot_price = mtm_data.loc[
                (mtm_data["extract_date"] == Valuation_Date[0])
                & (mtm_data["security_identifier"] == currency_pair)
            ]["quoted_price"].values[0]
            if len(vol_data_filtered) <= 0:
                sigma = mtm_data.loc[
                    (mtm_data["extract_date"] == Valuation_Date[0])
                    & (mtm_data["security_identifier"] == currency_pair)
                ]["volatility"].values[0]
            else:
                sigma = None
            discount_curve_secondary_currency = row[column_index_dict["discounting_curve_secondary_currency"]]
            zero_rate_curve_points = curve_data.loc[
                (curve_data["curve_name"] == discount_curve_secondary_currency), :
            ]
            interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
            extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
            tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
            rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
            if interpolation_algorithm == "Linear":
                if linearinterp(tenor, rates, TTM_array[0]) is None:
                    if extrapolation_algorithm == "Linear":
                        extrapolated_value = linearexterp(tenor, rates, TTM_array[0])
                    else:
                        extrapolated_value = flatexterp(tenor, rates, TTM_array[0])
                    rf = extrapolated_value
                else:
                    interpolated_value = linearinterp(tenor, rates, TTM_array[0])
                    rf = interpolated_value
            div = rf
            del tenor
            del rates
            del zero_rate_curve_points
        else:
            spot_price = mtm_data[
                (mtm_data["security_identifier"] == Underlying_pos_id[0])
                & (
                    mtm_data["extract_date"]
                    == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True)
                )
            ]["quoted_price"].iloc[0]
            if len(vol_data_filtered) <= 0:
                vix = vix_data.iloc[0]
                sigma = np.sqrt(vix) / 100
            else:
                sigma = None
            div = 0

        call_type = np.array([row[column_index_dict["put_call_type"]]])
        Discount_Curve = np.array([row[column_index_dict["discounting_curve"]]])

        cashflow_model_results = {
            "extract_date": Valuation_Date[0],
            "transaction_date": MaturityDate[0],
            "unique_reference_id": Unique_Reference_Id,
            "reference_dimension": reference_dimension,
            "cashflow_type": "-",
            "cashflow_status": "-",
            "cashflow": None,
            "time_to_maturity": TTM_array[0],
            "discount_factor": None,
            "present_value": None,
            "currency": currency,
            "asset_liability_type": asset_liability_type,
            "product_variant_name": product_variant_name,
            "fund": fund,
            "portfolio": portfolio,
            "cohort": "",
            "entity": entity,
        }
        cashflow_model_results = pd.DataFrame([cashflow_model_results])
        measure_value = []
        valuation_results = []
        sensitivity_analysis = []

        if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
            zero_rate_curve = Discount_Curve[0]
            zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
            interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
            extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
            tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
            rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
            if interpolation_algorithm == "Linear":
                if linearinterp(tenor, rates, TTM_array[0]) is None:
                    if extrapolation_algorithm == "Linear":
                        zero_rate = linearexterp(tenor, rates, TTM_array[0])
                    else:
                        zero_rate = flatexterp(tenor, rates, TTM_array[0])
                else:
                    zero_rate = linearinterp(tenor, rates, TTM_array[0])
            quantity = float(row[column_index_dict["quantity"]])

            if sigma is None:
                sigma = volatility_calculation_from_surface(
                    vol_data_filtered,
                    spot_price=spot_price,
                    strike_price=strike_price[0].astype(float),
                    T=TTM_array[0].astype(float),
                    r=zero_rate,
                    q=div,
                )

            BO = Options_Pricing.Barrier_Option(
                S=spot_price,
                K=strike_price[0].astype(float),
                T=TTM_array[0].astype(float),
                r=zero_rate,
                sigma=sigma,
                barrier=barrier_price[0].astype(float),
                div=div,
                barrier_hit_status=barrier_hit_status,
                rebate=rebate,
            )

            if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                if call_type[0] == "call" and option_type[0] == "down and out":
                    price_df = BO.down_out_call()
                if call_type[0] == "call" and option_type[0] == "up and out":
                    price_df = BO.up_out_call()
                if call_type[0] == "call" and option_type[0] == "down and in":
                    price_df = BO.down_in_call()
                if call_type[0] == "call" and option_type[0] == "up and in":
                    price_df = BO.up_in_call()
                if call_type[0] == "put" and option_type[0] == "down and out":
                    price_df = BO.down_out_put()
                if call_type[0] == "put" and option_type[0] == "up and out":
                    price_df = BO.up_out_put()
                if call_type[0] == "put" and option_type[0] == "down and in":
                    price_df = BO.down_in_put()
                if call_type[0] == "put" and option_type[0] == "up and in":
                    price_df = BO.up_in_put()
            else:
                price_df = mtm_data[
                    (mtm_data["security_identifier"] == Unique_Reference_Id[0])
                    & (
                        mtm_data["extract_date"]
                        == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True)
                    )
                ]["quoted_price"]
                price_df = price_df.iloc[0]

            price_df = float(price_df)
            price = price_df
            if position_direction == "Sell":
                price = price * -1
            cashflow_model_results["present_value"] = price
            total_holding = np.round(quantity * price, 4)
            valuation_output = {
                "PV": np.round(price, 4),
            }
            measure_dict_val = {
                "measure_run_date": datetime.now(),
                "valuation_date": Valuation_Date[0],
                "unique_reference_id": Unique_Reference_Id,
                "position_id": Position_Id,
                "reference_dimension": reference_dimension,
                "measure_type": "Fair Value per unit",
                "measure_value": np.round(price, 4),
                "absolute_relative": "Absolute",
                "residual_maturity": TTM_array[-1],
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": "",
                "entity": entity,
            }
            measure_dict_val_position = {
                "measure_run_date": datetime.now(),
                "valuation_date": Valuation_Date[0],
                "unique_reference_id": Unique_Reference_Id,
                "position_id": Position_Id,
                "reference_dimension": reference_dimension,
                "measure_type": "Fair Value",
                "measure_value": np.round(price * Quantity, 4),
                "absolute_relative": "Absolute",
                "residual_maturity": TTM_array[-1],
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": "",
                "entity": entity,
            }
            measure_value.append(measure_dict_val)
            measure_value.append(measure_dict_val_position)

            valuation_results.append(valuation_output)

            if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":

                # Delta
                BO_up = Options_Pricing.Barrier_Option(
                    S=spot_price + 0.0001 * spot_price,
                    K=strike_price[0].astype(float),
                    T=TTM_array[0].astype(float),
                    r=zero_rate,
                    sigma=sigma,
                    barrier=barrier_price[0].astype(float),
                    div=div,
                    barrier_hit_status=barrier_hit_status,
                    rebate=rebate,
                )
                BO_down = Options_Pricing.Barrier_Option(
                    S=spot_price - 0.0001 * spot_price,
                    K=strike_price[0].astype(float),
                    T=TTM_array[0].astype(float),
                    r=zero_rate,
                    sigma=sigma,
                    barrier=barrier_price[0].astype(float),
                    div=div,
                    barrier_hit_status=barrier_hit_status,
                    rebate=rebate,
                )
                spot_change_up = barrier_fx_greeks_computation(BO_up, call_type, option_type)
                spot_change_down = barrier_fx_greeks_computation(BO_down, call_type, option_type)
                delta_val = (
                    (abs(spot_change_up - price_df) + abs(spot_change_down - price_df)) / 2
                ) * Quantity

                # Vega
                BO_up = Options_Pricing.Barrier_Option(
                    S=spot_price,
                    K=strike_price[0].astype(float),
                    T=TTM_array[0].astype(float),
                    r=zero_rate,
                    sigma=sigma + 0.0001,
                    barrier=barrier_price[0].astype(float),
                    div=div,
                    barrier_hit_status=barrier_hit_status,
                    rebate=rebate,
                )
                BO_down = Options_Pricing.Barrier_Option(
                    S=spot_price,
                    K=strike_price[0].astype(float),
                    T=TTM_array[0].astype(float),
                    r=zero_rate,
                    sigma=sigma - 0.0001,
                    barrier=barrier_price[0].astype(float),
                    div=div,
                    barrier_hit_status=barrier_hit_status,
                    rebate=rebate,
                )
                vol_change_up = barrier_fx_greeks_computation(BO_up, call_type, option_type)
                vol_change_down = barrier_fx_greeks_computation(BO_down, call_type, option_type)
                vega_val = ((abs(vol_change_up - price_df) + abs(vol_change_down - price_df)) / 2) * Quantity

                # Theta
                ttm_up = TTM_array[0].astype(float) + 0.00273972602739726
                ttm_down = TTM_array[0].astype(float) - 0.00273972602739726

                zero_rate_curve_points = curve_data.loc[
                    (curve_data["curve_name"] == discount_curve_secondary_currency), :
                ]
                interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
                extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                if interpolation_algorithm == "Linear":
                    if linearinterp(tenor, rates, ttm_up) is None:
                        if extrapolation_algorithm == "Linear":
                            extrapolated_value = linearexterp(tenor, rates, ttm_up)
                        else:
                            extrapolated_value = flatexterp(tenor, rates, ttm_up)
                        rf_up = extrapolated_value
                    else:
                        interpolated_value = linearinterp(tenor, rates, ttm_up)
                        rf_up = interpolated_value
                if interpolation_algorithm == "Linear":
                    if linearinterp(tenor, rates, ttm_down) is None:
                        if extrapolation_algorithm == "Linear":
                            extrapolated_value = linearexterp(tenor, rates, ttm_down)
                        else:
                            extrapolated_value = flatexterp(tenor, rates, ttm_down)
                        rf_down = extrapolated_value
                    else:
                        interpolated_value = linearinterp(tenor, rates, ttm_down)
                        rf_down = interpolated_value

                zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
                interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
                extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                if interpolation_algorithm == "Linear":
                    if linearinterp(tenor, rates, ttm_up) is None:
                        if extrapolation_algorithm == "Linear":
                            rd_up = linearexterp(tenor, rates, ttm_up)
                        else:
                            rd_up = flatexterp(tenor, rates, ttm_up)
                    else:
                        rd_up = linearinterp(tenor, rates, ttm_up)
                if interpolation_algorithm == "Linear":
                    if linearinterp(tenor, rates, ttm_down) is None:
                        if extrapolation_algorithm == "Linear":
                            rd_down = linearexterp(tenor, rates, ttm_down)
                        else:
                            rd_down = flatexterp(tenor, rates, ttm_down)
                    else:
                        rd_down = linearinterp(tenor, rates, ttm_down)

                BO_up = Options_Pricing.Barrier_Option(
                    S=spot_price,
                    K=strike_price[0].astype(float),
                    T=ttm_up,
                    r=rd_up,
                    sigma=sigma,
                    barrier=barrier_price[0].astype(float),
                    div=rf_up,
                    barrier_hit_status=barrier_hit_status,
                    rebate=rebate,
                )
                BO_down = Options_Pricing.Barrier_Option(
                    S=spot_price,
                    K=strike_price[0].astype(float),
                    T=ttm_down,
                    r=rd_down,
                    sigma=sigma,
                    barrier=barrier_price[0].astype(float),
                    div=rf_down,
                    barrier_hit_status=barrier_hit_status,
                    rebate=rebate,
                )
                ttm_change_up = barrier_fx_greeks_computation(BO_up, call_type, option_type)
                ttm_change_down = barrier_fx_greeks_computation(BO_down, call_type, option_type)
                theta_val = ((abs(ttm_change_up - price_df) + abs(ttm_change_down - price_df)) / 2) * Quantity

                # Rho
                BO_up = Options_Pricing.Barrier_Option(
                    S=spot_price,
                    K=strike_price[0].astype(float),
                    T=TTM_array[0].astype(float),
                    r=zero_rate + 0.0001,
                    sigma=sigma,
                    barrier=barrier_price[0].astype(float),
                    div=div,
                    barrier_hit_status=barrier_hit_status,
                    rebate=rebate,
                )
                BO_down = Options_Pricing.Barrier_Option(
                    S=spot_price,
                    K=strike_price[0].astype(float),
                    T=TTM_array[0].astype(float),
                    r=zero_rate - 0.0001,
                    sigma=sigma,
                    barrier=barrier_price[0].astype(float),
                    div=div,
                    barrier_hit_status=barrier_hit_status,
                    rebate=rebate,
                )
                rd_change_up = barrier_fx_greeks_computation(BO_up, call_type, option_type)
                rd_change_down = barrier_fx_greeks_computation(BO_down, call_type, option_type)
                rho_val = ((abs(rd_change_up - price_df) + abs(rd_change_down - price_df)) / 2) * Quantity

                # Phi
                BO_up = Options_Pricing.Barrier_Option(
                    S=spot_price,
                    K=strike_price[0].astype(float),
                    T=TTM_array[0].astype(float),
                    r=zero_rate,
                    sigma=sigma,
                    barrier=barrier_price[0].astype(float),
                    div=div + 0.0001,
                    barrier_hit_status=barrier_hit_status,
                    rebate=rebate,
                )
                BO_down = Options_Pricing.Barrier_Option(
                    S=spot_price,
                    K=strike_price[0].astype(float),
                    T=TTM_array[0].astype(float),
                    r=zero_rate,
                    sigma=sigma,
                    barrier=barrier_price[0].astype(float),
                    div=div - 0.0001,
                    barrier_hit_status=barrier_hit_status,
                    rebate=rebate,
                )
                rf_change_up = barrier_fx_greeks_computation(BO_up, call_type, option_type)
                rf_change_down = barrier_fx_greeks_computation(BO_down, call_type, option_type)
                phi_val = ((abs(rf_change_up - price_df) + abs(rf_change_down - price_df)) / 2) * Quantity

                measure_dict_delta = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Delta",
                    "measure_value": delta_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_vega = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Vega",
                    "measure_value": vega_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_theta = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Theta",
                    "measure_value": theta_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_rho = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Rho",
                    "measure_value": rho_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_phi = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Phi",
                    "measure_value": phi_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_value.append(measure_dict_delta)
                measure_value.append(measure_dict_vega)
                measure_value.append(measure_dict_theta)
                measure_value.append(measure_dict_rho)
                measure_value.append(measure_dict_phi)

                sensitivity_analysis.append(
                    {
                        "Delta": round(delta_val, 6),
                        "Vega": round(vega_val, 6),
                        "Theta": round(theta_val, 6),
                        "Rho": round(rho_val, 6),
                        "Phi": round(phi_val, 6),
                    }
                )

        else:
            sensitivity_analysis.append(
                {
                    "Delta": "-",
                    "Gamma": "-",
                    "Rho": "-",
                    "Phi": "-",
                    "Vanna": "-",
                    "Vega": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        cashflow_model_results["extract_date"] = cashflow_model_results["extract_date"].astype(str)
        cashflow_model_results["transaction_date"] = cashflow_model_results["transaction_date"].astype(str)
        cashflow_model_results["present_value"] = present_value_check_function(
            cashflow_model_results["present_value"], Quantity
        )
        final_output_dict = {}
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = Unique_Reference_Id
        final_output_dict["Position_Id"] = Position_Id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = pd.to_datetime(Valuation_Date[0]).strftime("%Y-%m-%d")
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Quantity"] = Quantity
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Quantity"] = Quantity
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        cashflow_model_results = cashflow_model_results[cashflow_model_results["time_to_maturity"] != "-"]
        measure_value = pd.DataFrame(measure_value)
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] in ["M026"]:  # For Basket Options
        Unique_Reference_Id = np.array([row[column_index_dict["unique_reference_id"]]])
        Underlying_pos_id = np.array([row[column_index_dict["underlying_position_id"]]])
        temp_uid = Underlying_pos_id.tolist()[0]
        uid_list = temp_uid.split(",")
        Position_Id = np.array([row[column_index_dict["position_id"]]])
        Quantity = np.array([row[column_index_dict["quantity"]]])
        reference_dimension = np.array(["Security"])
        cashflow_status = np.array(["Unrealised"])
        currency = np.array([row[column_index_dict["primary_currency"]]])
        asset_liability_type = np.array(["Asset"])
        product_variant_name = np.array([row[column_index_dict["product_variant_name"]]])
        fund = np.array([row[column_index_dict["fund_code"]]])
        portfolio = np.array([row[column_index_dict["pool_id"]]])
        entity = np.array([row[column_index_dict["legal_entity"]]])
        Valuation_Date = np.array(
            [pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True).strftime("%Y-%m-%d")]
        )
        ValuationDate = Valuation_Date.astype("datetime64[D]")
        Discount_Daycount = np.array([row[column_index_dict["discount_daycount_convention"]]])
        Maturity_Date = np.array(
            [pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True).strftime("%Y-%m-%d")]
        )
        MaturityDate = Maturity_Date.astype("datetime64[D]")
        spot_price = []
        for i in uid_list:
            sprice = mtm_data[
                (mtm_data["security_identifier"] == i) & (mtm_data["extract_date"] == ValuationDate[0])
            ]["quoted_price"].iloc[0]
            spot_price.append(sprice)
        strike_price = np.array([row[column_index_dict["strike_price"]]])
        discount_convention_code = valuation_models.daycount_convention_code(Discount_Daycount)
        TTM_array = conventions.D_day_count(
            ValuationDate,
            MaturityDate,
            discount_convention_code,
            custom_daycount_conventions=custom_daycount_conventions,
        )
        vix = vix_data["vix"].iloc[0]
        sigma = np.sqrt(vix) / 100
        call_type = np.array([row[column_index_dict["put_call_type"]]])
        Discount_Curve = np.array([row[column_index_dict["discounting_curve"]]])
        time_intervals = []
        if discount_convention_code == "Actual/365":
            time_intervals.append(TTM_array[0] * 365)
        else:
            time_intervals.append(TTM_array[0] * 252)
        if call_type[0] == "call":
            put_call_type = 1
        else:
            put_call_type = -1

        hist_data_df = mtm_data[mtm_data["security_identifier"].isin(uid_list)]
        hist_data_df = hist_data_df[hist_data_df["extract_date"] <= ValuationDate[0]]
        hist_data_df = hist_data_df.reset_index().pivot(index="extract_date", columns="security_identifier")[
            "quoted_price"
        ]
        hist_data_df = hist_data_df.reset_index()
        hist_data_df["extract_date"] = pd.to_datetime(hist_data_df.extract_date, format="%d/%m/%Y")
        hist_data_df = hist_data_df.sort_values(by="extract_date")

        # correlation calculations
        hist_data_temp = hist_data_df.drop(["extract_date"], axis=1)
        corr_df = hist_data_temp.corr(method="pearson")
        corr_df = corr_df.rename_axis(index=lambda x: None)
        corr_df = corr_df.stack().reset_index()
        corr_df.columns = ["entity", "other_entity", "rho"]
        mask_dups = (corr_df[["entity", "other_entity"]].apply(frozenset, axis=1).duplicated()) | (
            corr_df["entity"] == corr_df["other_entity"]
        )
        corr_df = corr_df[~mask_dups].reset_index(drop=True)

        # volatility or sigma calculations
        cols_hist_data = len(hist_data_df.columns)
        split_dfs = []

        for i in range(1, cols_hist_data, 1):
            split_dfs.append(hist_data_df.iloc[:, [0, i]])

        sig_list = []
        col_sig_list = []
        for i in range(0, len(split_dfs)):
            temp_df = pd.DataFrame(split_dfs[i])
            temp_df["Log_Ret"] = np.log(temp_df.iloc[:, -1:] / temp_df.iloc[:, -1:].shift(-1))
            temp_df["sigma"] = (np.std(temp_df["Log_Ret"])) * 252**0.5
            col_name = temp_df.columns[-3]
            col_sig_list.append(col_name)
            sig_val = temp_df["sigma"].iloc[0]
            sig_list.append(sig_val)
        sigma_df = pd.DataFrame()
        sigma_df["entity"] = col_sig_list
        sigma_df["sigma"] = sig_list

        # covariance calculation
        sigma_df = sigma_df.set_index("entity")
        corr_df["cov"] = (
            corr_df.entity.map(sigma_df.sigma) * corr_df.other_entity.map(sigma_df.sigma) * corr_df["rho"]
        )

        cov_list = corr_df["cov"]
        sigma_list = sigma_df["sigma"]
        n_assets_length = len(sigma_df)

        cashflow_results = [
            Valuation_Date,
            "-",
            Position_Id,
            reference_dimension,
            "-",
            "-",
            "-",
            "-",
            "-",
            "-",
            currency,
            asset_liability_type,
            product_variant_name,
            fund,
            portfolio,
            "",
            entity,
        ]
        index_values = [
            "extract_date",
            "transaction_date",
            "unique_reference_id",
            "reference_dimension",
            "cashflow_type",
            "cashflow_status",
            "cashflow",
            "time_to_maturity",
            "discount_factor",
            "present_value",
            "currency",
            "asset_liability_type",
            "product_variant_name",
            "fund",
            "portfolio",
            "cohort",
            "entity",
        ]
        measure_value = []
        cashflow_model_results = pd.DataFrame(data=cashflow_results, index=index_values).transpose()
        valuation_results = []
        sensitivity_analysis = []

        if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
            zero_rate_curve = Discount_Curve[0]
            zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
            interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
            extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
            tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
            rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
            if interpolation_algorithm == "Linear":
                if linearinterp(tenor, rates, TTM_array[0]) is None:
                    if extrapolation_algorithm == "Linear":
                        zero_rate = linearexterp(tenor, rates, TTM_array[0])
                    else:
                        zero_rate = flatexterp(tenor, rates, TTM_array[0])
                else:
                    zero_rate = linearinterp(tenor, rates, TTM_array[0])
            quantity = float(row[column_index_dict["quantity"]])

            BASO = Options_Pricing.Basket_Option(
                S=spot_price,
                K=strike_price[0].astype(float),
                T=TTM_array[0].astype(float),
                r=zero_rate,
                put_call_type=put_call_type,
                cov=cov_list,
                n_asset=n_assets_length,
                sigma=sigma_list,
            )

            if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                price_df = BASO.price()
            else:
                price_df = mtm_data[
                    (mtm_data["security_identifier"] == Unique_Reference_Id[0])
                    & (
                        mtm_data["extract_date"]
                        == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True)
                    )
                ]["quoted_price"]
                price_df = price_df.iloc[0]

            price = price_df
            total_holding = np.round(quantity * price, 4)
            valuation_output = {
                "PV": np.round(price, 4),
            }
            measure_dict_val = {
                "measure_run_date": datetime.now(),
                "valuation_date": Valuation_Date[0],
                "unique_reference_id": Unique_Reference_Id,
                "position_id": Position_Id,
                "reference_dimension": reference_dimension,
                "measure_type": "Fair Value per unit",
                "measure_value": np.round(price, 4),
                "absolute_relative": "Absolute",
                "residual_maturity": TTM_array[-1],
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": "",
                "entity": entity,
            }
            measure_dict_val_position = {
                "measure_run_date": datetime.now(),
                "valuation_date": Valuation_Date[0],
                "unique_reference_id": Unique_Reference_Id,
                "position_id": Position_Id,
                "reference_dimension": reference_dimension,
                "measure_type": "Fair Value",
                "measure_value": np.round(price * Quantity[0], 4),
                "absolute_relative": "Absolute",
                "residual_maturity": TTM_array[-1],
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": "",
                "entity": entity,
            }
            measure_value.append(measure_dict_val)
            measure_value.append(measure_dict_val_position)

            valuation_results.append(valuation_output)

            if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":

                delta_val = np.round(BASO.delta(call_type[0]), 4)
                gamma_val = np.round(BASO.gamma(), 4)
                rho_val = np.round(BASO.rho(call_type[0]), 4)
                phi_val = np.round(BASO.phi(call_type[0]), 4)
                vanna_val = np.round(BASO.vanna(), 4)
                vega_val = np.round(BASO.vega(), 4)

                measure_dict_delta = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Delta",
                    "measure_value": delta_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_gamma = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Gamma",
                    "measure_value": gamma_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_rho = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Rho",
                    "measure_value": rho_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_phi = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Phi",
                    "measure_value": phi_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_vanna = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Vanna",
                    "measure_value": vanna_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_vega = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Vega",
                    "measure_value": vega_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_value.append(measure_dict_delta)
                measure_value.append(measure_dict_gamma)
                measure_value.append(measure_dict_rho)
                measure_value.append(measure_dict_phi)
                measure_value.append(measure_dict_vanna)
                measure_value.append(measure_dict_vega)

                sensitivity_analysis.append(
                    {
                        "Delta": delta_val,
                        "Gamma": gamma_val,
                        "Rho": rho_val,
                        "Phi": phi_val,
                        "Vanna": vanna_val,
                        "Vega": vega_val,
                    }
                )

                result = pd.DataFrame(sensitivity_analysis)
                result_final = Options_Pricing.unnesting(
                    result, ["Delta", "Gamma", "Rho", "Phi", "Vanna", "Vega"]
                ).reset_index()
                result_final["Basket_id"] = uid_list
                result_final.drop(["index"], axis="columns", inplace=True)

                col_reorder = result_final.columns.tolist()
                col_reorder = col_reorder[-1:] + col_reorder[:-1]
                result_final = result_final[col_reorder]

                sensitivity_analysis = result_final.to_dict("records")

        else:
            sensitivity_analysis.append(
                {
                    "Delta": "-",
                    "Gamma": "-",
                    "Rho": "-",
                    "Phi": "-",
                    "Vanna": "-",
                    "Vega": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        cashflow_model_results["extract_date"] = cashflow_model_results["extract_date"].astype(str)
        cashflow_model_results["transaction_date"] = cashflow_model_results["transaction_date"].astype(str)
        final_output_dict = {}
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = Unique_Reference_Id[0]
        final_output_dict["Position_Id"] = Position_Id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = pd.to_datetime(Valuation_Date[0]).strftime("%Y-%m-%d")
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Quantity"] = Quantity[0]
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        cashflow_model_results = cashflow_model_results[cashflow_model_results["time_to_maturity"] != "-"]
        measure_value = pd.DataFrame(measure_value)
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] in ["M029"]:  # For Cliquet Options
        Unique_Reference_Id = np.array([row[column_index_dict["unique_reference_id"]]])
        Underlying_pos_id = np.array([row[column_index_dict["underlying_position_id"]]])
        Position_Id = np.array([row[column_index_dict["position_id"]]])
        Quantity = np.array([row[column_index_dict["quantity"]]])
        reference_dimension = np.array(["Security"])
        cashflow_status = np.array(["Unrealised"])
        currency = np.array([row[column_index_dict["primary_currency"]]])
        asset_liability_type = np.array(["Asset"])
        product_variant_name = np.array([row[column_index_dict["product_variant_name"]]])
        fund = np.array([row[column_index_dict["fund_code"]]])
        portfolio = np.array([row[column_index_dict["pool_id"]]])
        entity = np.array([row[column_index_dict["legal_entity"]]])
        Valuation_Date = np.array(
            [pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True).strftime("%Y-%m-%d")]
        )
        ValuationDate = Valuation_Date.astype("datetime64[D]")
        Discount_Daycount = np.array([row[column_index_dict["discount_daycount_convention"]]])
        Maturity_Date = np.array(
            [pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True).strftime("%Y-%m-%d")]
        )
        MaturityDate = Maturity_Date.astype("datetime64[D]")
        spot_price = mtm_data[
            (mtm_data["security_identifier"] == Underlying_pos_id[0])
            & (
                mtm_data["extract_date"]
                == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True)
            )
        ]["quoted_price"].iloc[0]
        strike_price = np.array([row[column_index_dict["strike_price"]]])
        discount_convention_code = valuation_models.daycount_convention_code(Discount_Daycount)
        TTM_array = conventions.D_day_count(
            ValuationDate,
            MaturityDate,
            discount_convention_code,
            custom_daycount_conventions=custom_daycount_conventions,
        )
        vix = vix_data["vix"].iloc[0]
        sigma = np.sqrt(vix) / 100
        call_type = np.array([row[column_index_dict["put_call_type"]]])
        Discount_Curve = np.array([row[column_index_dict["discounting_curve"]]])
        freq_type = np.array([row[column_index_dict["reset_frequency_unit"]]])
        n_periods = np.array([row[column_index_dict["reset_frequency"]]])

        # Depending on frequency and number of periods in input dataset, set up reset dates
        def month_range(start, periods=12):

            rng = pd.date_range(pd.Timestamp(start) - pd.offsets.MonthBegin(), periods=periods, freq="MS")
            ret = (rng + pd.offsets.Day(pd.Timestamp(start).day - 1)).to_series()
            x = pd.DatetimeIndex(ret)
            y = x.strftime("%d/%m/%Y")
            result = []
            for i in range(0, len(y)):
                result.append(datetime.strptime(y[i], "%d/%m/%Y"))
            return result

        def quarter_range(start, periods=3):
            rng = pd.date_range(pd.Timestamp(start) - pd.offsets.QuarterBegin(), periods=periods, freq="QS")
            ret = (rng + pd.offsets.Day(pd.Timestamp(start).day - 1)).to_series()
            x = pd.DatetimeIndex(ret)
            y = x.strftime("%d/%m/%Y").tolist()
            result = []
            for i in range(0, len(y)):
                result.append(datetime.strptime(y[i], "%d/%m/%Y"))
            return result

        def year_range(start, periods=3):
            rng = pd.date_range(pd.Timestamp(start), periods=periods, freq="365d")
            x = pd.DatetimeIndex(rng)
            y = x.strftime("%d/%m/%Y").tolist()
            result = []
            for i in range(0, len(y)):
                result.append(datetime.strptime(y[i], "%d/%m/%Y"))
            return result

        def week_range(start, periods=12):
            rng = pd.date_range(pd.Timestamp(start), periods=periods, freq="7d")
            x = pd.DatetimeIndex(rng)
            y = x.strftime("%d/%m/%Y").tolist()
            result = []
            for i in range(0, len(y)):
                result.append(datetime.strptime(y[i], "%d/%m/%Y"))
            return result

        reset_date_1 = []
        date_list = []

        temp_list = []
        if freq_type[0] == "M":
            a1 = []
            temp_list.append(month_range(ValuationDate[0], n_periods[0] + 1))
            a1 = abs(np.array(temp_list[0][1:]) - np.array(temp_list[0][:-1]))
            reset_date_1.append(a1)
        elif freq_type[0] == "W":
            temp_list.append(week_range(ValuationDate[0], n_periods[0] + 1))
        elif freq_type[0] == "Q":
            temp_list.append(quarter_range(ValuationDate[0], n_periods[0] + 1))
        elif freq_type[0] == "Y":
            temp_list.append(year_range(ValuationDate[0], n_periods[0] + 1))
        date_list.append(temp_list)
        some_list = list(reset_date_1)

        tau_list = []

        for row_index, row1 in enumerate(some_list):
            tau = []
            for col_index, item in enumerate(row1):
                i = some_list[row_index][col_index]
                tau.append(i.days)
            tau_list.append(tau)

        tau_try = []
        for row_index, row1 in enumerate(tau_list):
            some_temp = []
            tau_try1 = list(reversed(tau_list[row_index]))
            for col_index, item in enumerate(row1):
                temp_1 = list(accumulate(tau_try1))
                some_temp = list(reversed(temp_1))
            tau_try.append(some_temp)
        final_tau = []
        final_tau2 = []
        for row_index, row1 in enumerate(tau_try):
            another_temp = []
            some_other_temp = []
            for col_index, item in enumerate(row1):
                i = tau_try[row_index][col_index]
                another_temp.append(i / 365)
            final_tau.append(another_temp)  # T2 - array of time to maturity of the forward starting option
        for row_index, row1 in enumerate(final_tau):
            some_other_temp = []
            for col_index, item in enumerate(row1):
                if col_index > 0:
                    i = final_tau[row_index][col_index]
                    j = final_tau[row_index][col_index - 1]
                    some_other_temp.append(j - (j - i))
                if col_index == len(row1) - 1:
                    some_other_temp.append(0)
            final_tau2.append(some_other_temp)  # T1 - array of time to the forward start or strike fixing

        alpha_list = []
        val = strike_price[0].astype("float") / spot_price
        alpha_list.append(val)  # strike is set equal to a positive constant  (alpha) times the asset price S

        cashflow_results = [
            Valuation_Date,
            "-",
            Position_Id,
            reference_dimension,
            "-",
            "-",
            "-",
            "-",
            "-",
            "-",
            currency,
            asset_liability_type,
            product_variant_name,
            fund,
            portfolio,
            "",
            entity,
        ]
        index_values = [
            "extract_date",
            "transaction_date",
            "unique_reference_id",
            "reference_dimension",
            "cashflow_type",
            "cashflow_status",
            "cashflow",
            "time_to_maturity",
            "discount_factor",
            "present_value",
            "currency",
            "asset_liability_type",
            "product_variant_name",
            "fund",
            "portfolio",
            "cohort",
            "entity",
        ]
        measure_value = []
        cashflow_model_results = pd.DataFrame(data=cashflow_results, index=index_values).transpose()
        valuation_results = []
        sensitivity_analysis = []

        if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
            zero_rate_curve = Discount_Curve[0]
            zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
            interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
            extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
            tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
            rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
            if interpolation_algorithm == "Linear":
                if linearinterp(tenor, rates, TTM_array[0]) is None:
                    if extrapolation_algorithm == "Linear":
                        zero_rate = linearexterp(tenor, rates, TTM_array[0])
                    else:
                        zero_rate = flatexterp(tenor, rates, TTM_array[0])
                else:
                    zero_rate = linearinterp(tenor, rates, TTM_array[0])
            quantity = float(row[column_index_dict["quantity"]])

            CLI_OPT = Options_Pricing.Cliquet_Option(
                S=spot_price,
                t1=final_tau2[0],
                t2=final_tau[0],
                r=zero_rate,
                sigma=sigma,
                alpha=alpha_list[0],
                div=0,
            )

            if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                price_df = CLI_OPT.price(call_type[0])
            else:
                price_df = mtm_data[
                    (mtm_data["security_identifier"] == Unique_Reference_Id[0])
                    & (
                        mtm_data["extract_date"]
                        == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True)
                    )
                ]["quoted_price"]
                price_df = price_df.iloc[0]

            price = price_df
            total_holding = np.round(quantity * price, 4)
            valuation_output = {
                "PV": np.round(price, 4),
            }
            measure_dict_val = {
                "measure_run_date": datetime.now(),
                "valuation_date": Valuation_Date[0],
                "unique_reference_id": Unique_Reference_Id,
                "position_id": Position_Id,
                "reference_dimension": reference_dimension,
                "measure_type": "Fair Value per unit",
                "measure_value": np.round(price, 4),
                "absolute_relative": "Absolute",
                "residual_maturity": TTM_array[-1],
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": "",
                "entity": entity,
            }
            measure_dict_val_position = {
                "measure_run_date": datetime.now(),
                "valuation_date": Valuation_Date[0],
                "unique_reference_id": Unique_Reference_Id,
                "position_id": Position_Id,
                "reference_dimension": reference_dimension,
                "measure_type": "Fair Value",
                "measure_value": np.round(price * Quantity[0], 4),
                "absolute_relative": "Absolute",
                "residual_maturity": TTM_array[-1],
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": "",
                "entity": entity,
            }
            measure_value.append(measure_dict_val)
            measure_value.append(measure_dict_val_position)

            valuation_results.append(valuation_output)

            if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":

                delta_val = "-"
                gamma_val = "-"
                rho_val = "-"
                phi_val = "-"
                vanna_val = "-"
                vega_val = "-"

                measure_dict_delta = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Delta",
                    "measure_value": delta_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_gamma = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Gamma",
                    "measure_value": gamma_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_rho = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Rho",
                    "measure_value": rho_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_phi = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Phi",
                    "measure_value": phi_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_vanna = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Vanna",
                    "measure_value": vanna_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_vega = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Vega",
                    "measure_value": vega_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_value.append(measure_dict_delta)
                measure_value.append(measure_dict_gamma)
                measure_value.append(measure_dict_rho)
                measure_value.append(measure_dict_phi)
                measure_value.append(measure_dict_vanna)
                measure_value.append(measure_dict_vega)

                sensitivity_analysis.append(
                    {
                        "Delta": delta_val,
                        "Gamma": gamma_val,
                        "Rho": rho_val,
                        "Phi": phi_val,
                        "Vanna": vanna_val,
                        "Vega": vega_val,
                    }
                )

        else:
            sensitivity_analysis.append(
                {
                    "Delta": "-",
                    "Gamma": "-",
                    "Rho": "-",
                    "Phi": "-",
                    "Vanna": "-",
                    "Vega": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        cashflow_model_results["extract_date"] = cashflow_model_results["extract_date"].astype(str)
        cashflow_model_results["transaction_date"] = cashflow_model_results["transaction_date"].astype(str)
        final_output_dict = {}
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = Unique_Reference_Id[0]
        final_output_dict["Position_Id"] = Position_Id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = pd.to_datetime(Valuation_Date[0]).strftime("%Y-%m-%d")
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Quantity"] = Quantity[0]
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        cashflow_model_results = cashflow_model_results[cashflow_model_results["time_to_maturity"] != "-"]
        measure_value = pd.DataFrame(measure_value)
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] in ["M028"]:  # For Compound Options
        Unique_Reference_Id = np.array([row[column_index_dict["unique_reference_id"]]])
        Underlying_pos_id = np.array([row[column_index_dict["underlying_position_id"]]])
        Position_Id = np.array([row[column_index_dict["position_id"]]])
        Quantity = np.array([row[column_index_dict["quantity"]]])
        reference_dimension = np.array(["Security"])
        cashflow_status = np.array(["Unrealised"])
        currency = np.array([row[column_index_dict["primary_currency"]]])
        asset_liability_type = np.array(["Asset"])
        product_variant_name = np.array([row[column_index_dict["product_variant_name"]]])
        entity = np.array([row[column_index_dict["legal_entity"]]])
        fund = np.array([row[column_index_dict["fund_code"]]])
        portfolio = np.array([row[column_index_dict["pool_id"]]])
        Valuation_Date = np.array(
            [pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True).strftime("%Y-%m-%d")]
        )
        ValuationDate = Valuation_Date.astype("datetime64[D]")
        Discount_Daycount = np.array([row[column_index_dict["discount_daycount_convention"]]])
        Maturity_Date = np.array(
            [pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True).strftime("%Y-%m-%d")]
        )
        MaturityDate = Maturity_Date.astype("datetime64[D]")
        underlying_position_data2 = underlying_position_data.copy()
        Actual_underlying_id = underlying_position_data2[
            (underlying_position_data2["unique_reference_id"] == Underlying_pos_id[0])
            & (
                underlying_position_data2["reporting_date"]
                == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True)
            )
        ]["underlying_position_id"].iloc[0]
        spot_price = mtm_data[
            (mtm_data["security_identifier"] == Actual_underlying_id)
            & (
                mtm_data["extract_date"]
                == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True)
            )
        ]["quoted_price"].iloc[0]
        strike_price = np.array([row[column_index_dict["strike_price"]]])
        Maturity_Date2 = underlying_position_data[
            (underlying_position_data["unique_reference_id"] == Underlying_pos_id[0])
            & (
                underlying_position_data["reporting_date"]
                == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True)
            )
        ]["maturity_date"].iloc[0]
        Maturity_Date3 = pd.to_datetime(Maturity_Date2, dayfirst=True)
        Valuation_Date2 = pd.to_datetime(Valuation_Date[0], dayfirst=True)
        underlying_time = abs((Maturity_Date3 - Valuation_Date2).days)

        Maturity_Date3 = np.array(pd.to_datetime(Maturity_Date2, dayfirst=True).strftime("%Y-%m-%d"))
        Valuation_Date2 = np.array(pd.to_datetime(Valuation_Date[0], dayfirst=True).strftime("%Y-%m-%d"))
        MaturityDate3 = Maturity_Date3.astype("datetime64[D]")
        Valuation_Date2 = Valuation_Date2.astype("datetime64[D]")

        strike_price2 = underlying_position_data[
            (underlying_position_data["unique_reference_id"] == Underlying_pos_id[0])
            & (
                underlying_position_data["reporting_date"]
                == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True)
            )
        ]["strike_price"].iloc[0]
        call_type2 = underlying_position_data[
            (underlying_position_data["unique_reference_id"] == Underlying_pos_id[0])
            & (
                underlying_position_data["reporting_date"]
                == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True)
            )
        ]["put_call_type"].iloc[0]
        discount_convention_code = valuation_models.daycount_convention_code(Discount_Daycount)
        TTM_array = conventions.D_day_count(
            ValuationDate,
            MaturityDate,
            discount_convention_code,
            custom_daycount_conventions=custom_daycount_conventions,
        )
        TTM_array_underlying = conventions.D_day_count(
            Valuation_Date2,
            MaturityDate3,
            discount_convention_code,
            custom_daycount_conventions=custom_daycount_conventions,
        )
        vix = vix_data["vix"].iloc[0]
        sigma = np.sqrt(vix) / 100
        call_type = np.array([row[column_index_dict["put_call_type"]]])
        Discount_Curve = np.array([row[column_index_dict["discounting_curve"]]])

        cashflow_results = [
            Valuation_Date,
            "-",
            Position_Id,
            reference_dimension,
            "-",
            "-",
            "-",
            "-",
            "-",
            "-",
            currency,
            asset_liability_type,
            product_variant_name,
            fund,
            portfolio,
            "",
            entity,
        ]
        index_values = [
            "extract_date",
            "transaction_date",
            "unique_reference_id",
            "reference_dimension",
            "cashflow_type",
            "cashflow_status",
            "cashflow",
            "time_to_maturity",
            "discount_factor",
            "present_value",
            "currency",
            "asset_liability_type",
            "product_variant_name",
            "fund",
            "portfolio",
            "cohort",
            "entity",
        ]
        measure_value = []
        cashflow_model_results = pd.DataFrame(data=cashflow_results, index=index_values).transpose()
        valuation_results = []
        sensitivity_analysis = []

        if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
            zero_rate_curve = Discount_Curve[0]
            zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
            interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
            extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
            tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
            rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
            if interpolation_algorithm == "Linear":
                if linearinterp(tenor, rates, TTM_array[0]) is None:
                    if extrapolation_algorithm == "Linear":
                        zero_rate = linearexterp(tenor, rates, TTM_array[0])
                    else:
                        zero_rate = flatexterp(tenor, rates, TTM_array[0])
                else:
                    zero_rate = linearinterp(tenor, rates, TTM_array[0])
            quantity = float(row[column_index_dict["quantity"]])

            COMP = Options_Pricing.Compound_Option(
                time=underlying_time,
                S=spot_price,
                K1=np.float64(strike_price2),
                K2=strike_price[0].astype(float),
                T1=TTM_array_underlying.astype(float),
                T2=TTM_array[0].astype(float),
                r=zero_rate,
                sigma=sigma,
                div=0,
            )
            if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                if call_type2 == "call" and call_type[0] == "call":
                    price_df = COMP.price(call_type[0], call_type2)
                if call_type2 == "call" and call_type[0] == "put":
                    price_df = COMP.price(call_type[0], call_type2)
                if call_type2 == "put" and call_type[0] == "call":
                    price_df = COMP.price(call_type[0], call_type2)
                if call_type2 == "put" and call_type[0] == "put":
                    price_df = COMP.price(call_type[0], call_type2)
            else:
                price_df = mtm_data[
                    (mtm_data["security_identifier"] == Unique_Reference_Id[0])
                    & (
                        mtm_data["extract_date"]
                        == pd.to_datetime(row[column_index_dict["reporting_date"]], dayfirst=True)
                    )
                ]["quoted_price"]
                price_df = price_df.iloc[0]

            price = price_df
            total_holding = np.round(quantity * price, 4)
            valuation_output = {
                "PV": np.round(price, 4),
            }
            measure_dict_val = {
                "measure_run_date": datetime.now(),
                "valuation_date": Valuation_Date[0],
                "unique_reference_id": Unique_Reference_Id,
                "position_id": Position_Id,
                "reference_dimension": reference_dimension,
                "measure_type": "Fair Value per unit",
                "measure_value": np.round(price, 4),
                "absolute_relative": "Absolute",
                "residual_maturity": TTM_array[-1],
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": "",
                "entity": entity,
            }
            measure_dict_val_position = {
                "measure_run_date": datetime.now(),
                "valuation_date": Valuation_Date[0],
                "unique_reference_id": Unique_Reference_Id,
                "position_id": Position_Id,
                "reference_dimension": reference_dimension,
                "measure_type": "Fair Value",
                "measure_value": np.round(price * Quantity[0], 4),
                "absolute_relative": "Absolute",
                "residual_maturity": TTM_array[-1],
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": "",
                "entity": entity,
            }
            measure_value.append(measure_dict_val)
            measure_value.append(measure_dict_val_position)

            valuation_results.append(valuation_output)

            if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":

                delta_val = np.round(COMP.delta(call_type[0], call_type2), 4)
                gamma_val = np.round(COMP.gamma(call_type[0], call_type2), 4)
                rho_val = np.round(COMP.rho_greek(call_type[0], call_type2), 4)
                vega_val = np.round(COMP.vega(call_type[0], call_type2), 4)

                measure_dict_delta = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Delta",
                    "measure_value": delta_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_gamma = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Gamma",
                    "measure_value": gamma_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_rho = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Rho",
                    "measure_value": rho_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_dict_vega = {
                    "measure_run_date": datetime.now(),
                    "valuation_date": Valuation_Date[0],
                    "unique_reference_id": Unique_Reference_Id,
                    "position_id": Position_Id,
                    "reference_dimension": reference_dimension,
                    "measure_type": "Vega",
                    "measure_value": vega_val,
                    "absolute_relative": "Absolute",
                    "residual_maturity": TTM_array[-1],
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }

                measure_value.append(measure_dict_delta)
                measure_value.append(measure_dict_gamma)
                measure_value.append(measure_dict_rho)
                measure_value.append(measure_dict_vega)

                sensitivity_analysis.append(
                    {
                        "Delta": delta_val,
                        "Gamma": gamma_val,
                        "Rho": rho_val,
                        "Vega": vega_val,
                    }
                )

        else:
            sensitivity_analysis.append(
                {
                    "Delta": "-",
                    "Gamma": "-",
                    "Rho": "-",
                    "Vega": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        cashflow_model_results["extract_date"] = cashflow_model_results["extract_date"].astype(str)
        cashflow_model_results["transaction_date"] = cashflow_model_results["transaction_date"].astype(str)
        final_output_dict = {}
        cashflow_model_results["position_id"] = Position_Id[0]
        final_output_dict["Unique_Reference_ID"] = Unique_Reference_Id[0]
        final_output_dict["Position_Id"] = Position_Id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = pd.to_datetime(Valuation_Date[0]).strftime("%Y-%m-%d")
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Quantity"] = Quantity[0]
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        cashflow_model_results = cashflow_model_results[cashflow_model_results["time_to_maturity"] != "-"]
        measure_value = pd.DataFrame(measure_value)
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] == "M032":
        final_output_dict = {}
        unique_reference_Id = row[column_index_dict["unique_reference_id"]]
        position_id = row[column_index_dict["position_id"]]
        valuation_date = np.array(row[column_index_dict["reporting_date"]], dtype="datetime64[D]")
        issue_date = np.array(row[column_index_dict["issue_date"]], dtype="datetime64[D]")
        accrual_daycount = row[column_index_dict["accrual_daycount_convention"]]
        discount_daycount = row[column_index_dict["discount_daycount_convention"]]
        business_day_convention = np.array([row[column_index_dict["business_convention"]]])
        discount_curve = row[column_index_dict["discounting_curve"]]
        product_variant_name = row[column_index_dict["product_variant_name"]]
        fund = row[column_index_dict["fund_code"]]
        portfolio = row[column_index_dict["pool_id"]]
        entity = row[column_index_dict["legal_entity"]]
        last_payment_date = row[column_index_dict["last_payment_date"]]
        if str(last_payment_date) not in ["nan", "NaT", "None", "-"]:
            last_payment_date = np.datetime64(row[column_index_dict["last_payment_date"]], "D")
        stub_date = row[column_index_dict["stub_date"]]
        if str(stub_date) not in ["nan", "NaT", "None", "-"]:
            stub_date = np.datetime64(row[column_index_dict["stub_date"]], "D")
        payment_frequency = row[column_index_dict["payment_frequency"]]
        payment_frequency_unit = row[column_index_dict["payment_frequency_units"]]
        base_rate = float(row[column_index_dict["base_rate"]]) / 100
        if str(row[column_index_dict["fixed_spread"]]) not in ["", "nan", "None"]:
            fixed_spread = float(row[column_index_dict["fixed_spread"]]) / 100
        else:
            fixed_spread = 0
        interest_rate = base_rate + fixed_spread
        interest_overdue = row[column_index_dict["interest_overdue_amount"]]
        principal_overdue = row[column_index_dict["principal_overdue_amount"]]
        charges_overdue = row[column_index_dict["charges_overdue_amount"]]
        outstanding_amount = np.array([float(row[column_index_dict["outstanding_amount"]])])
        coupon_frequency = valuation_models.coupon_Frequency(payment_frequency, payment_frequency_unit)
        emi_start_date = np.array([pd.to_datetime(row[column_index_dict["emi_start_date"]], dayfirst=True)])
        emi_end_date = np.array([pd.to_datetime(row[column_index_dict["emi_end_date"]], dayfirst=True)])
        emi_amount = row[column_index_dict["emi_amount"]]
        interest_moratorium_flag = row[column_index_dict["interest_moratorium_flag"]]
        interest_calculation_methodology = row[column_index_dict["interest_calculation_methodology"]]
        accrued_interest = row[column_index_dict["accrued_interest"]]
        if str(accrued_interest) not in ["nan", "None", ""]:
            accrued_interest = np.array([float(accrued_interest / Quantity)], dtype="float")
        if interest_moratorium_flag == "N":
            if str(last_payment_date) not in ["nan", "", "None", "NaT"]:
                time_period = (
                    emi_start_date[0] - pd.to_datetime(last_payment_date, dayfirst=True)
                ).days / 365
            else:
                time_period = (emi_start_date[0] - pd.to_datetime(valuation_date, dayfirst=True)).days / 365
            if interest_calculation_methodology == "Compound":
                compounding_frequency = row[column_index_dict["compounding_frequency"]]
                compounding_frequency_unit = row[column_index_dict["compounding_frequency_unit"]]
                compounding_frequency_periods = valuation_models.coupon_Frequency(
                    compounding_frequency, payment_frequency_unit
                )
                outstanding_amount = np.array(
                    [
                        float(
                            outstanding_amount[0]
                            * (1 + interest_rate / compounding_frequency_periods)
                            ** (time_period * compounding_frequency_periods)
                        )
                    ]
                )
            else:
                outstanding_amount = np.array(
                    [float(outstanding_amount[0] * (1 + (interest_rate * time_period)))]
                )

        if str(emi_amount) not in ["None", "nan", ""]:
            emi_amount = float(emi_amount)
        else:
            nper = emi_end_date[0] - emi_start_date[0]
            nper = round((nper.days / (30.412 * int(12 / coupon_frequency))), 0) + 1
            interest = interest_rate / coupon_frequency
            emi_amount = npf.pmt(interest, nper, -outstanding_amount[0], fv=0, when="end")

        quantity = float(row[column_index_dict["quantity"]])
        credit_spread_rate = row[column_index_dict["credit_spread_rate"]]
        credit_spread_curve = row[column_index_dict["credit_spread_curve"]]
        asset_liability_type = row[column_index_dict["asset_liability_type"]]
        valuation_results, sensitivity_analysis, measure_value = [], [], []
        result = pre_emi_cashflow_generation(
            issue_date,
            fund,
            portfolio,
            last_payment_date,
            emi_amount,
            emi_end_date,
            interest_rate,
            payment_frequency,
            payment_frequency_unit,
            outstanding_amount,
            position_id,
            business_day_convention,
            discount_daycount,
            accrual_daycount,
            product_variant_name,
            currency,
            valuation_date,
            entity,
            asset_liability_type,
            [],
            emi_start_date,
            emi_end_date,
            custom_daycount_conventions,
            interest_moratorium_flag,
            accrued_interest,
            stub_date=stub_date,
            business_days=business_days,
        )
        cashflow_model_results = {
            "extract_date": Valuation_Date[0],
            "transaction_date": result[1],
            "unique_reference_id": Unique_Reference_Id,
            "reference_dimension": reference_dimension,
            "cashflow_type": result[4],
            "cashflow_status": cashflow_status,
            "cashflow": result[6],
            "time_to_maturity": result[7],
            "discount_factor": result[8],
            "present_value": result[9],
            "currency": currency,
            "asset_liability_type": asset_liability_type,
            "product_variant_name": product_variant_name,
            "fund": fund,
            "portfolio": portfolio,
            "cohort": None,
            "entity": entity,
            "interest_paid_array": result[17],
            "principal_paid_array": result[18],
        }
        accrued_interest = result[19]
        cashflow_model_results = pd.DataFrame(cashflow_model_results)
        accrued_interest_ttm = cashflow_model_results["time_to_maturity"].iloc[0]
        cashflow_model_results, dpd_cashflows = overdue_cashflow_calculations(
            position_id,
            cashflow_model_results,
            dpd_schedule,
            dpd_ruleset,
            overdue_bucketing_data,
            Valuation_Date,
            Unique_Reference_Id,
            reference_dimension,
            cashflow_status,
            currency,
            asset_liability_type,
            product_variant_name,
            fund,
            portfolio,
            entity,
            interest_overdue,
            principal_overdue,
            charges_overdue,
        )
        cashflow_model_results = cashflow_model_results.astype(
            {"time_to_maturity": "float64", "cashflow": "float64", "transaction_date": "datetime64[ns]"}
        )
        cashflow_model_results = cashflow_model_results.sort_values(
            by=["transaction_date", "cashflow_type"], ascending=True
        )
        output_msg = output_check_fn(
            cashflow_results=cashflow_model_results[cashflow_model_results["time_to_maturity"] != 0]
        )

        if output_msg["CF_Output"] == "Present":
            if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
                ttm = np.array(cashflow_model_results["time_to_maturity"], dtype="float64")
                total_amount = np.array(cashflow_model_results["cashflow"], dtype="float64")
                coupons = np.array(cashflow_model_results["interest_paid_array"], dtype="float64")
                principal = np.array(cashflow_model_results["principal_paid_array"], dtype="float64")
                cashflow_model_results = cashflow_model_results.drop(
                    ["interest_paid_array", "principal_paid_array"], axis=1
                )
                cashflow_status = cashflow_model_results["cashflow_status"]
                zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == discount_curve), :]
                interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
                extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[0]
                tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                zero_rates = np.empty([0], dtype="float64")
                measure_run_date_strftime = datetime.now()
                for j in range(len(ttm)):
                    if interpolation_algorithm == "Linear":
                        if linearinterp(tenor, rates, ttm[j]) is None:
                            if extrapolation_algorithm == "Linear":
                                extrapolated_value = linearexterp(tenor, rates, ttm[j])
                            else:
                                extrapolated_value = flatexterp(tenor, rates, ttm[j])
                            zero_rates = np.append(zero_rates, extrapolated_value)
                        else:
                            interpolated_value = linearinterp(tenor, rates, ttm[j])
                            zero_rates = np.append(zero_rates, interpolated_value)

                if str(credit_spread_rate) not in ["nan", "None"]:
                    zero_rates = zero_rates + float(credit_spread_rate)
                elif str(credit_spread_curve) not in ["nan", "None"]:
                    credit_spread_curve_data = credit_spread_data.loc[
                        (credit_spread_data["credit_spread_curve_name"] == credit_spread_curve), :
                    ]
                    if len(credit_spread_curve_data) > 0:
                        spread_tenor = np.array(credit_spread_curve_data.tenor.tolist())
                        spread_tenor_unit = np.array(credit_spread_curve_data.tenor_unit.tolist())
                        cs_interpolation_algorithm = credit_spread_curve_data["interpolation_algorithm"].iloc[
                            0
                        ]
                        cs_extrapolation_algorithm = credit_spread_curve_data["extrapolation_algorithm"].iloc[
                            0
                        ]
                        tenor_extrac = np.vectorize(tenor_extraction)
                        spread_tenor = tenor_extrac(spread_tenor, spread_tenor_unit)
                        spread_rates = np.array(credit_spread_curve_data.spread_value.tolist())
                        credit_spread_rates = np.empty([0], dtype="float64")
                        for j in range(len(ttm)):
                            if linearinterp(spread_tenor, spread_rates, ttm[j]) is None:
                                if cs_extrapolation_algorithm == "Linear":
                                    calculated_value = linearexterp(spread_tenor, spread_rates, ttm[j])
                                else:
                                    calculated_value = flatexterp(spread_tenor, spread_rates, ttm[j])
                            else:
                                calculated_value = linearinterp(spread_tenor, spread_rates, ttm[j])
                            credit_spread_rates = np.append(credit_spread_rates, calculated_value)
                        zero_rates = zero_rates + credit_spread_rates
                (
                    pv_output,
                    pv_table,
                    ttm_array,
                    total_amount_array,
                    df,
                    pv_coupons,
                    pv_principal,
                    PV_plus_1bps,
                    PV_minus_1bps,
                ) = fixed_income_valuation(
                    ttm,
                    total_amount,
                    zero_rates,
                    coupons,
                    principal,
                    curve_compounding_frequency=curve_compounding_frequency,
                )
                cashflow_model_results["discount_factor"] = df
                cashflow_model_results["present_value"] = pv_table
                del tenor, rates
                output_msg = output_check_fn(valuation_output=pv_output)
                if output_msg["Val_Output"] == "Present":
                    valuation_output = {
                        "PV": round(pv_output, 4),
                    }
                    measure_dict_val = {
                        "measure_run_date": measure_run_date_strftime,
                        "valuation_date": Valuation_Date[0],
                        "unique_reference_id": Unique_Reference_Id,
                        "position_id": Position_Id,
                        "reference_dimension": reference_dimension,
                        "measure_type": "Fair Value per unit",
                        "measure_value": round(pv_output, 4),
                        "absolute_relative": "Absolute",
                        "residual_maturity": ttm[-1],
                        "asset_liability_type": asset_liability_type,
                        "product_variant_name": product_variant_name,
                        "fund": fund,
                        "portfolio": portfolio,
                        "cohort": "",
                        "entity": entity,
                    }
                    measure_dict_val_position = {
                        "measure_run_date": measure_run_date_strftime,
                        "valuation_date": Valuation_Date[0],
                        "unique_reference_id": Unique_Reference_Id,
                        "position_id": Position_Id,
                        "reference_dimension": reference_dimension,
                        "measure_type": "Fair Value",
                        "measure_value": round(pv_output * quantity, 4),
                        "absolute_relative": "Absolute",
                        "residual_maturity": ttm_array[-1],
                        "asset_liability_type": asset_liability_type,
                        "product_variant_name": product_variant_name,
                        "fund": fund,
                        "portfolio": portfolio,
                        "cohort": "",
                        "entity": entity,
                    }
                    measure_value.append(measure_dict_val)
                    measure_value.append(measure_dict_val_position)
                    valuation_results.append(valuation_output)
                    total_holding = quantity * valuation_results[0]["PV"]
                    if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":
                        (
                            pv01,
                            macaulay_duration,
                            modified_duration,
                            effective_duration,
                            ytm,
                        ) = valuation_models.fixed_income_sensitivity_analysis(
                            pv_table,
                            ttm_array,
                            total_amount_array,
                            1,
                            "Y",
                            pv_output,
                            PV_plus_1bps,
                            PV_minus_1bps,
                        )
                        sensitivity_analysis.append(
                            {
                                "Macaulay Duration": macaulay_duration,
                                "Effective Duration": effective_duration,
                                "Modified Duration": modified_duration,
                                "PV01 per unit": pv01,
                            }
                        )
                        if isinstance(ytm, (np.ndarray)):
                            ytm = ytm[0]
                        else:
                            ytm = ytm
                        measure_dict_ytm = {
                            "measure_run_date": measure_run_date_strftime,
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Yield to Maturity",
                            "measure_value": ytm,
                            "absolute_relative": "Absolute",
                            "residual_maturity": ttm_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_ytm)
                        measure_dict_mac_dur = {
                            "measure_run_date": measure_run_date_strftime,
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Macaulay Duration",
                            "measure_value": macaulay_duration,
                            "absolute_relative": "Absolute",
                            "residual_maturity": ttm_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_mac_dur)
                        measure_dict_eff_dur = {
                            "measure_run_date": measure_run_date_strftime,
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Effective Duration",
                            "measure_value": effective_duration,
                            "absolute_relative": "Relative",
                            "residual_maturity": ttm_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_eff_dur)
                        measure_dict_mod_dur = {
                            "measure_run_date": measure_run_date_strftime,
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Modified Duration",
                            "measure_value": modified_duration,
                            "absolute_relative": "Relative",
                            "residual_maturity": ttm_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_mod_dur)
                        measure_dict_pv01 = {
                            "measure_run_date": measure_run_date_strftime,
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "PV01 per unit",
                            "measure_value": pv01,
                            "absolute_relative": "Absolute",
                            "residual_maturity": ttm_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_pv01)
                        measure_dict_pv01_position = {
                            "measure_run_date": measure_run_date_strftime,
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "PV01",
                            "measure_value": pv01 * quantity,
                            "absolute_relative": "Absolute",
                            "residual_maturity": ttm_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_pv01_position)

                else:
                    valuation_output = {
                        "PV": "None",
                    }
                    total_holding = "None"
                    valuation_results.append(valuation_output)

            else:
                cashflow_model_results = cashflow_model_results.drop(
                    ["interest_paid_array", "principal_paid_array"], axis=1
                )
                sensitivity_analysis.append(
                    {
                        "Macaulay_Duration": "-",
                        "Effective Duration": "-",
                        "Modified_Duration": "-",
                        "PV01 per unit": "-",
                    }
                )
                valuation_output = {
                    "PV": "None",
                }
                total_holding = "None"
                valuation_results.append(valuation_output)

        else:
            cashflow_model_results = cashflow_model_results.drop(
                ["interest_paid_array", "principal_paid_array"], axis=1
            )
            sensitivity_analysis.append(
                {
                    "Macaulay_Duration": "-",
                    "Effective Duration": "-",
                    "Modified_Duration": "-",
                    "PV01 per unit": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        if str(accrued_interest[0]) not in ["", "0.0", "None", "nan"]:
            cashflow_model_results = pd.concat(
                [cashflow_model_results, cashflow_model_results.iloc[[-1]]], ignore_index=True
            )
            if str(Quantity) in ["", "nan", "None"]:
                Quantity = 1
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow")] = (
                accrued_interest[0] * Quantity
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow_type")] = (
                "Accrued Interest"
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("transaction_date")] = (
                pd.to_datetime(Valuation_Date[0])
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("present_value")] = None
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("time_to_maturity")] = (
                accrued_interest_ttm
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("discount_factor")] = None
            cashflow_model_results = cashflow_model_results.sort_values(
                by=["transaction_date", "cashflow_type"], ascending=True
            )
        cashflow_model_results["unique_reference_id"] = Unique_Reference_Id
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = unique_reference_Id
        final_output_dict["Position_Id"] = position_id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = Valuation_Date[0]
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Quantity"] = quantity
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        measure_value = pd.DataFrame(measure_value)
        measure_value["currency"] = currency
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] == "M038":
        final_output_dict = {}
        unique_reference_id = row[column_index_dict["unique_reference_id"]]
        position_id = row[column_index_dict["position_id"]]
        valuation_date = np.array(row[column_index_dict["reporting_date"]], dtype="datetime64[D]")
        issue_date = np.array(row[column_index_dict["issue_date"]], dtype="datetime64[D]")
        accrual_daycount = row[column_index_dict["accrual_daycount_convention"]]
        discount_daycount = row[column_index_dict["discount_daycount_convention"]]
        business_day_convention = np.array([row[column_index_dict["business_convention"]]])
        discount_curve = row[column_index_dict["discounting_curve"]]
        product_variant_name = row[column_index_dict["product_variant_name"]]
        fund = row[column_index_dict["fund_code"]]
        portfolio = row[column_index_dict["pool_id"]]
        entity = row[column_index_dict["legal_entity"]]
        last_payment_date = row[column_index_dict["last_payment_date"]]
        if str(last_payment_date) not in ["nan", "NaT", "None", "-"]:
            last_payment_date = np.datetime64(row[column_index_dict["last_payment_date"]], "D")
        payment_frequency = row[column_index_dict["payment_frequency"]]
        payment_frequency_unit = row[column_index_dict["payment_frequency_units"]]
        base_rate = float(row[column_index_dict["base_rate"]]) / 100
        if str(row[column_index_dict["fixed_spread"]]) not in ["", "nan", "None"]:
            fixed_spread = float(row[column_index_dict["fixed_spread"]]) / 100
        else:
            fixed_spread = 0
        interest_rate = base_rate + fixed_spread
        outstanding_amount = np.array([float(row[column_index_dict["outstanding_amount"]])])
        coupon_frequency = valuation_models.coupon_Frequency(payment_frequency, payment_frequency_unit)
        accrued_interest = row[column_index_dict["accrued_interest"]]
        if str(accrued_interest) not in ["nan", "None", ""]:
            accrued_interest = np.array([float(accrued_interest / Quantity)], dtype="float")
        else:
            accrued_interest = 0
        deposit_frequency = row[column_index_dict["deposit_frequency"]]
        deposit_frequency_unit = row[column_index_dict["deposit_frequency_unit"]]
        deposit_amount = float(row[column_index_dict["deposit_amount"]])
        last_deposit_date = row[column_index_dict["last_deposit_date"]]
        if str(last_deposit_date) not in ["nan", "NaT", "None", "-"]:
            last_deposit_date = np.datetime64(row[column_index_dict["last_deposit_date"]], "D")
        maturity_date = np.array([pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True)])
        convention_code = row[column_index_dict["business_convention"]]
        accrual_convention_code = valuation_models.daycount_convention_code(accrual_daycount)
        discount_daycount_convention_code = valuation_models.daycount_convention_code(discount_daycount)
        if str(last_payment_date) not in ["nan", "NaT", "None", "-"]:
            last_payment_date = np.datetime64(row[column_index_dict["last_payment_date"]], "D")
        stub_date = row[column_index_dict["stub_date"]]
        if str(stub_date) not in ["nan", "NaT", "None", "-"]:
            stub_date = np.datetime64(row[column_index_dict["stub_date"]], "D")
        principal_stub_date = row[column_index_dict["principal_stub_date"]]
        if str(principal_stub_date) not in ["nan", "NaT", "None", "-"]:
            principal_stub_date = np.datetime64(row[column_index_dict["principal_stub_date"]], "D")
        quantity = row[column_index_dict["quantity"]]
        if str(quantity) not in ["nan", "None", ""]:
            quantity = int(row[column_index_dict["quantity"]])
        else:
            quantity = 1
        cashflow_results_output = recurring_deposits(
            unique_reference_id,
            issue_date,
            last_payment_date,
            last_deposit_date,
            maturity_date,
            base_rate,
            fixed_spread,
            payment_frequency,
            payment_frequency_unit,
            deposit_frequency,
            deposit_frequency_unit,
            outstanding_amount,
            convention_code,
            valuation_date,
            deposit_amount,
            holiday_calendar,
            accrual_convention_code,
            discount_daycount_convention_code,
            accrued_interest,
            custom_daycount_conventions,
            stub_date=stub_date,
            principal_stub_date=principal_stub_date,
            business_days=business_days,
        )
        cashflow_model_results = {
            "extract_date": Valuation_Date[0],
            "transaction_date": cashflow_results_output[0],
            "unique_reference_id": Unique_Reference_Id,
            "reference_dimension": reference_dimension,
            "cashflow_type": cashflow_results_output[3],
            "cashflow_status": cashflow_status,
            "cashflow": cashflow_results_output[2],
            "time_to_maturity": cashflow_results_output[1],
            "discount_factor": None,
            "present_value": None,
            "currency": currency,
            "asset_liability_type": asset_liability_type,
            "product_variant_name": product_variant_name,
            "fund": fund,
            "portfolio": portfolio,
            "cohort": "",
            "entity": entity,
        }
        cashflow_model_results = pd.DataFrame(cashflow_model_results)
        accrued_interest_ttm = cashflow_model_results["time_to_maturity"].iloc[0]
        cashflow_model_results = cashflow_model_results.astype(
            {"time_to_maturity": "float64", "cashflow": "float64", "transaction_date": "datetime64[ns]"}
        )
        cashflow_model_results = cashflow_model_results.sort_values(by=["transaction_date", "cashflow_type"])
        valuation_results = []
        sensitivity_analysis = []
        PV_principal = []
        measure_value = []
        output_msg = output_check_fn(cashflow_results=cashflow_model_results)
        if output_msg["CF_Output"] == "Present":
            if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
                TTM = cashflow_model_results["time_to_maturity"].to_numpy(dtype="float64")
                Total_Amount = cashflow_model_results["cashflow"].to_numpy(dtype="float64")
                zero_rate_curve = discount_curve
                zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
                interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
                extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[0]
                tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                zero_rates = np.empty([0], dtype="float64")
                for j in range(len(TTM)):
                    if interpolation_algorithm == "Linear":
                        if linearinterp(tenor, rates, TTM[j]) is None:
                            if extrapolation_algorithm == "Linear":
                                extrapolated_value = linearexterp(tenor, rates, TTM[j])
                            else:
                                extrapolated_value = flatexterp(tenor, rates, TTM[j])
                            zero_rates = np.append(zero_rates, extrapolated_value)
                        else:
                            interpolated_value = linearinterp(tenor, rates, TTM[j])
                            zero_rates = np.append(zero_rates, interpolated_value)
                (
                    PV_output,
                    PV_table,
                    TTM_array,
                    Total_amount_array,
                    DF,
                    PV_coupons,
                    PV_principal,
                    PV_plus_1bps,
                    PV_minus_1bps,
                ) = fixed_income_valuation(
                    TTM,
                    Total_Amount,
                    zero_rates,
                    Total_Amount,
                    Total_Amount,
                    curve_compounding_frequency=curve_compounding_frequency,
                )

                cashflow_model_results["discount_factor"] = DF
                cashflow_model_results["present_value"] = PV_table
                del tenor, rates
                output_msg = output_check_fn(valuation_output=PV_output)

                if output_msg["Val_Output"] == "Present":
                    valuation_output = {
                        "PV": round(PV_output * -1, 4),
                    }
                    measure_dict_val = {
                        "measure_run_date": datetime.now(),
                        "valuation_date": Valuation_Date[0],
                        "unique_reference_id": Unique_Reference_Id,
                        "position_id": Position_Id,
                        "reference_dimension": reference_dimension,
                        "measure_type": "Fair Value per unit",
                        "measure_value": round(PV_output * -1, 4),
                        "absolute_relative": "Absolute",
                        "residual_maturity": TTM[-1],
                        "asset_liability_type": asset_liability_type,
                        "product_variant_name": product_variant_name,
                        "fund": fund,
                        "portfolio": portfolio,
                        "cohort": "",
                        "entity": entity,
                    }
                    measure_dict_val_position = {
                        "measure_run_date": datetime.now(),
                        "valuation_date": Valuation_Date[0],
                        "unique_reference_id": Unique_Reference_Id,
                        "position_id": Position_Id,
                        "reference_dimension": reference_dimension,
                        "measure_type": "Fair Value",
                        "measure_value": round(PV_output * -1 * quantity, 4),
                        "absolute_relative": "Absolute",
                        "residual_maturity": TTM_array[-1],
                        "asset_liability_type": asset_liability_type,
                        "product_variant_name": product_variant_name,
                        "fund": fund,
                        "portfolio": portfolio,
                        "cohort": "",
                        "entity": entity,
                    }
                    measure_value.append(measure_dict_val)
                    measure_value.append(measure_dict_val_position)
                    valuation_results.append(valuation_output)
                    total_holding = quantity * valuation_results[0]["PV"]

                    if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":

                        (
                            PV01,
                            macaulay_duration,
                            modified_duration,
                            effective_duration,
                            ytm,
                        ) = valuation_models.fixed_income_sensitivity_analysis(
                            PV_table,
                            TTM_array,
                            Total_amount_array,
                            1,
                            "Y",
                            PV_output,
                            PV_plus_1bps,
                            PV_minus_1bps,
                        )
                        sensitivity_analysis.append(
                            {
                                "Macaulay Duration": macaulay_duration,
                                "Effective Duration": effective_duration,
                                "Modified Duration": modified_duration * -1,
                                "PV01 per unit": PV01,
                            }
                        )
                        if isinstance(ytm, (np.ndarray)):
                            ytm = ytm[0]
                        else:
                            ytm = ytm
                        measure_dict_ytm = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Yield to Maturity",
                            "measure_value": ytm,
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_ytm)
                        measure_dict_mac_dur = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Macaulay Duration",
                            "measure_value": macaulay_duration,
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_mac_dur)
                        measure_dict_eff_dur = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Effective Duration",
                            "measure_value": effective_duration,
                            "absolute_relative": "Relative",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_eff_dur)
                        measure_dict_mod_dur = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Modified Duration",
                            "measure_value": modified_duration * -1,
                            "absolute_relative": "Relative",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_mod_dur)
                        measure_dict_pv01 = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "PV01 per unit",
                            "measure_value": PV01,
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_pv01)
                        measure_dict_pv01_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "PV01",
                            "measure_value": PV01 * quantity,
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_pv01_position)

                else:
                    valuation_output = {
                        "PV": "None",
                    }
                    total_holding = "None"
                    valuation_results.append(valuation_output)

            else:
                sensitivity_analysis.append(
                    {
                        "Macaulay_Duration": "-",
                        "Effective Duration": "-",
                        "Modified_Duration": "-",
                        "PV01 per unit": "-",
                    }
                )
                valuation_output = {
                    "PV": "None",
                }
                total_holding = "None"
                valuation_results.append(valuation_output)

        else:
            sensitivity_analysis.append(
                {
                    "Macaulay_Duration": "-",
                    "Effective Duration": "-",
                    "Modified_Duration": "-",
                    "PV01 per unit": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        if accrued_interest != 0:
            cashflow_model_results = pd.concat(
                [cashflow_model_results, cashflow_model_results.iloc[[-1]]], ignore_index=True
            )
            if str(Quantity) in ["", "nan", "None"]:
                Quantity = 1
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow")] = (
                accrued_interest * Quantity
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow_type")] = (
                "Accrued Interest"
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("transaction_date")] = (
                pd.to_datetime(Valuation_Date[0])
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("present_value")] = None
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("time_to_maturity")] = (
                accrued_interest_ttm
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("discount_factor")] = None
            cashflow_model_results = cashflow_model_results.sort_values(
                by=["transaction_date", "cashflow_type"], ascending=True
            )
        cashflow_model_results["unique_reference_id"] = Unique_Reference_Id
        cashflow_model_results["cashflow"] = np.where(
            cashflow_model_results["cashflow"] < 0,
            cashflow_model_results["cashflow"] * -1,
            cashflow_model_results["cashflow"],
        )
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = unique_reference_id
        final_output_dict["Position_Id"] = position_id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = Valuation_Date[0]
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Quantity"] = quantity
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        measure_value = pd.DataFrame(measure_value)
        measure_value["currency"] = currency
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] == "M039":
        strike = float(row[column_index_dict["strike_price"]])
        business_day_convention = np.array([row[column_index_dict["business_convention"]]])
        convention_code = valuation_models.busday_convention_code(business_day_convention)
        maturity_date = np.array([pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True)])
        maturity_date = np.array(
            [business_day_val(maturity_date[0].date(), convention_code, [])], dtype="datetime64[D]"
        )
        discount_daycount = row[column_index_dict["discount_daycount_convention"]]
        discount_convention_code = valuation_models.daycount_convention_code(discount_daycount)
        TTM = conventions.D_day_count(
            Valuation_Date,
            maturity_date,
            discount_convention_code,
            custom_daycount_conventions=custom_daycount_conventions,
        )
        primary_currency = row[column_index_dict["primary_currency"]]
        secondary_currency = row[column_index_dict["secondary_currency"]]
        currency_pair = secondary_currency + primary_currency
        spot = mtm_data.loc[
            (mtm_data["extract_date"] == Valuation_Date[0])
            & (mtm_data["security_identifier"] == currency_pair)
        ]["quoted_price"].values[0]
        discount_curve_primary_currency = row[column_index_dict["discounting_curve"]]
        zero_rate_curve_points = curve_data.loc[
            (curve_data["curve_name"] == discount_curve_primary_currency), :
        ]
        interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
        extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
        tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
        rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
        if interpolation_algorithm == "Linear":
            if linearinterp(tenor, rates, TTM[0]) is None:
                if extrapolation_algorithm == "Linear":
                    extrapolated_value = linearexterp(tenor, rates, TTM[0])
                else:
                    extrapolated_value = flatexterp(tenor, rates, TTM[0])
                rd = extrapolated_value
            else:
                interpolated_value = linearinterp(tenor, rates, TTM[0])
                rd = interpolated_value
        discount_curve_secondary_currency = row[column_index_dict["discounting_curve_secondary_currency"]]
        zero_rate_curve_points = curve_data.loc[
            (curve_data["curve_name"] == discount_curve_secondary_currency), :
        ]
        interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
        extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
        tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
        rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
        if interpolation_algorithm == "Linear":
            if linearinterp(tenor, rates, TTM[0]) is None:
                if extrapolation_algorithm == "Linear":
                    extrapolated_value = linearexterp(tenor, rates, TTM[0])
                else:
                    extrapolated_value = flatexterp(tenor, rates, TTM[0])
                rf = extrapolated_value
            else:
                interpolated_value = linearinterp(tenor, rates, TTM[0])
                rf = interpolated_value

        forward_price = spot * np.exp((rd - rf) * TTM[0])
        payoff = forward_price - strike
        cashflow_model_results = []
        cashflow = {
            "extract_date": Valuation_Date[0],
            "transaction_date": maturity_date[0],
            "unique_reference_id": Unique_Reference_Id,
            "reference_dimension": reference_dimension,
            "cashflow_type": "Payoff",
            "cashflow_status": cashflow_status,
            "cashflow": payoff,
            "time_to_maturity": TTM[0],
            "discount_factor": None,
            "present_value": None,
            "currency": currency,
            "asset_liability_type": asset_liability_type,
            "product_variant_name": product_variant_name,
            "fund": fund,
            "portfolio": portfolio,
            "cohort": "",
            "entity": entity,
        }
        cashflow_model_results.append(cashflow)
        cashflow_model_results = pd.DataFrame(cashflow_model_results)
        cashflow_model_results = cashflow_model_results.astype(
            {"time_to_maturity": "float64", "cashflow": "float64", "transaction_date": "datetime64[ns]"}
        )
        cashflow_model_results = cashflow_model_results.sort_values(by=["transaction_date", "cashflow_type"])
        output_msg = output_check_fn(cashflow_results=cashflow_model_results)
        valuation_results = []
        sensitivity_analysis = []
        measure_value = []
        if output_msg["CF_Output"] == "Present":
            if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
                discount_factor = np.exp(-rd * TTM[0])
                PV_output = payoff * discount_factor
                output_msg = output_check_fn(valuation_output=PV_output)
                if output_msg["Val_Output"] == "Present":
                    valuation_output = {
                        "PV": round(PV_output, 4),
                    }
                    measure_dict_val = {
                        "measure_run_date": datetime.now(),
                        "valuation_date": Valuation_Date[0],
                        "unique_reference_id": Unique_Reference_Id,
                        "position_id": Position_Id,
                        "reference_dimension": reference_dimension,
                        "measure_type": "Fair Value per unit",
                        "measure_value": round(PV_output, 4),
                        "absolute_relative": "Absolute",
                        "residual_maturity": TTM[0],
                        "asset_liability_type": asset_liability_type,
                        "product_variant_name": product_variant_name,
                        "fund": fund,
                        "portfolio": portfolio,
                        "cohort": "",
                        "entity": entity,
                    }
                    measure_dict_val_position = {
                        "measure_run_date": datetime.now(),
                        "valuation_date": Valuation_Date[0],
                        "unique_reference_id": Unique_Reference_Id,
                        "position_id": Position_Id,
                        "reference_dimension": reference_dimension,
                        "measure_type": "Fair Value",
                        "measure_value": round(PV_output * Quantity, 4),
                        "absolute_relative": "Absolute",
                        "residual_maturity": TTM[0],
                        "asset_liability_type": asset_liability_type,
                        "product_variant_name": product_variant_name,
                        "fund": fund,
                        "portfolio": portfolio,
                        "cohort": "",
                        "entity": entity,
                    }
                    measure_value.append(measure_dict_val)
                    measure_value.append(measure_dict_val_position)
                    valuation_results.append(valuation_output)
                    total_holding = Quantity * valuation_results[0]["PV"]
                    cashflow_model_results["discount_factor"] = discount_factor
                    cashflow_model_results["present_value"] = PV_output

                    sensitivity_analysis.append(
                        {
                            "Macaulay_Duration": "-",
                            "Effective Duration": "-",
                            "Modified_Duration": "-",
                            "PV01 per unit": "-",
                        }
                    )

                else:
                    sensitivity_analysis.append(
                        {
                            "Macaulay_Duration": "-",
                            "Effective Duration": "-",
                            "Modified_Duration": "-",
                            "PV01 per unit": "-",
                        }
                    )
                    valuation_output = {
                        "PV": "None",
                    }
                    total_holding = "None"
                    valuation_results.append(valuation_output)

            else:
                sensitivity_analysis.append(
                    {
                        "Macaulay_Duration": "-",
                        "Effective Duration": "-",
                        "Modified_Duration": "-",
                        "PV01 per unit": "-",
                    }
                )
                valuation_output = {
                    "PV": "None",
                }
                total_holding = "None"
                valuation_results.append(valuation_output)
        else:
            sensitivity_analysis.append(
                {
                    "Macaulay_Duration": "-",
                    "Effective Duration": "-",
                    "Modified_Duration": "-",
                    "PV01 per unit": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        cashflow_model_results["cashflow"] = cashflow_model_results["cashflow"] * Quantity
        cashflow_model_results["present_value"] = present_value_check_function(
            cashflow_model_results["present_value"], Quantity
        )
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict = {}
        final_output_dict["Unique_Reference_ID"] = Unique_Reference_Id
        final_output_dict["Position_Id"] = Position_Id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = Valuation_Date[0]
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Quantity"] = Quantity
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Quantity"] = Quantity
            final_output_dict["Total_Holding"] = total_holding

        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        measure_value = pd.DataFrame(measure_value)
        measure_value["currency"] = currency
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] == "M045":
        final_output_dict = {}
        Issue_Date = pd.to_datetime(row[column_index_dict["issue_date"]], dayfirst=True)
        Maturity_Date = np.array([pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True)])
        outstanding_amount = np.array([float(row[column_index_dict["outstanding_amount"]])])
        Spread_Over_Benchmark = row[column_index_dict["fixed_spread"]]
        current_benchmark_rate = row[column_index_dict["current_benchmark_rate"]]
        Coupon_Frequency = row[column_index_dict["payment_frequency"]]
        Coupon_Frequency_unit = row[column_index_dict["payment_frequency_units"]]
        Discount_Daycount = np.array([row[column_index_dict["discount_daycount_convention"]]])
        Accrual_Daycount = np.array([row[column_index_dict["accrual_daycount_convention"]]])
        Discount_Curve = row[column_index_dict["discounting_curve"]]
        Business_day_convention = np.array([row[column_index_dict["business_convention"]]])
        Last_coupon_date = row[column_index_dict["last_payment_date"]]
        if str(Last_coupon_date) not in ["nan", "NaT", "None", "-"]:
            Last_coupon_date = np.datetime64(row[column_index_dict["last_payment_date"]], "D")
        stub_date = row[column_index_dict["stub_date"]]
        if str(stub_date) not in ["nan", "NaT", "None", "-"]:
            stub_date = np.datetime64(row[column_index_dict["stub_date"]], "D")
        Coupon_Benchmark_Curve = row[column_index_dict["forward_benchmark_curve"]]
        Next_Repricing_Date = pd.to_datetime(row[column_index_dict["next_reset_date"]], dayfirst=True)
        Last_Repricing_Date = pd.to_datetime(row[column_index_dict["last_reset_date"]], dayfirst=True)
        Repricing_Frequency = row[column_index_dict["reset_frequency"]]
        Repricing_Frequency_unit = row[column_index_dict["reset_frequency_unit"]]
        Credit_Spread_Rate = row[column_index_dict["credit_spread_rate"]]
        Credit_Spread_Curve = row[column_index_dict["credit_spread_curve"]]
        accrued_interest = row[column_index_dict["accrued_interest"]]
        interest_overdue = row[column_index_dict["interest_overdue_amount"]]
        principal_overdue = row[column_index_dict["principal_overdue_amount"]]
        charges_overdue = row[column_index_dict["charges_overdue_amount"]]
        if str(accrued_interest) not in ["nan", "None", ""]:
            accrued_interest = np.array([float(accrued_interest / Quantity)], dtype="float")
        valuation_results = []
        sensitivity_analysis = []
        PV_principal = []
        measure_value = []
        if cashflow_uploaded_data is not None and len(cashflow_uploaded_data) > 0:
            cashflow_uploaded_data_position = cashflow_uploaded_data.loc[
                cashflow_uploaded_data["position_id"] == Position_Id
            ]
        else:
            cashflow_uploaded_data_position = pd.DataFrame()
        if len(cashflow_uploaded_data_position) > 0:
            cashflow_upload = True
            cashflow_uploaded_data_position["cashflow"] = (
                cashflow_uploaded_data_position["cashflow"] / Quantity
            )
            accrued_interest = cashflow_model_results.loc[
                cashflow_model_results["cashflow_type"] == "Accrued Interest", "cashflow"
            ]
            if len(accrued_interest) > 0:
                accrued_interest = np.array([accrued_interest.iloc[0]], dtype="float")
            else:
                accrued_interest = None
            cashflow_model_results = cashflow_model_results.loc[
                cashflow_model_results["cashflow_type"] != "Accrued Interest"
            ]
            cashflow_model_results = cashflow_uploaded_data_position.copy()
            cashflow_uploaded_data_position["coupons"] = np.where(
                cashflow_uploaded_data_position["cashflow_type"] == "Interest Proceeds",
                cashflow_uploaded_data_position["cashflow"],
                0,
            )
            cashflow_uploaded_data_position["principal"] = np.where(
                cashflow_uploaded_data_position["cashflow_type"] == "Redemption Proceeds",
                cashflow_uploaded_data_position["cashflow"],
                0,
            )
            coupon_array = cashflow_uploaded_data_position["coupons"].to_numpy()
            principal_amount_array = cashflow_uploaded_data_position["principal"].to_numpy()
            total_amount_array = cashflow_uploaded_data_position["cashflow"].to_numpy()
            cashflow_model_results[["cashflow_status", "discount_factor", "present_value"]] = [
                cashflow_status,
                "",
                "",
            ]
            del cashflow_uploaded_data_position
        else:
            cashflow_upload = False
            cashflow_results_output = valuation_models.floating_coupon_cashflow_generation(
                Unique_Reference_Id,
                Issue_Date,
                Maturity_Date,
                outstanding_amount,
                outstanding_amount,
                Spread_Over_Benchmark,
                Coupon_Frequency,
                Coupon_Frequency_unit,
                Valuation_Date,
                Discount_Daycount,
                Accrual_Daycount,
                Discount_Curve,
                Business_day_convention,
                Last_coupon_date,
                Coupon_Benchmark_Curve,
                Next_Repricing_Date,
                Last_Repricing_Date,
                curve_data,
                Repricing_Frequency,
                Repricing_Frequency_unit,
                holiday_calendar,
                current_benchmark_rate,
                custom_daycount_conventions,
                accrued_interest,
                stub_date=stub_date,
                business_days=business_days,
            )
            coupon_array = cashflow_results_output[4]
            total_amount_array = cashflow_results_output[6]
            principal_amount_array = cashflow_results_output[5]
            accrued_interest = cashflow_results_output[7]
            cashflow_model_results = {
                "extract_date": Valuation_Date[0],
                "transaction_date": cashflow_results_output[2],
                "unique_reference_id": Unique_Reference_Id,
                "reference_dimension": reference_dimension,
                "cashflow_type": None,
                "cashflow_status": cashflow_status,
                "cashflow": cashflow_results_output[4],
                "time_to_maturity": cashflow_results_output[3],
                "discount_factor": None,
                "present_value": None,
                "currency": currency,
                "asset_liability_type": asset_liability_type,
                "product_variant_name": product_variant_name,
                "fund": fund,
                "portfolio": portfolio,
                "cohort": None,
                "entity": entity,
            }
            cashflow_model_results = pd.DataFrame(cashflow_model_results)
            cashflow_model_results["cashflow_type"] = "Interest Proceeds"
            cashflow_model_results, dpd_cashflows = overdue_cashflow_calculations(
                Position_Id,
                cashflow_model_results,
                dpd_schedule,
                dpd_ruleset,
                overdue_bucketing_data,
                Valuation_Date,
                Unique_Reference_Id,
                reference_dimension,
                cashflow_status,
                currency,
                asset_liability_type,
                product_variant_name,
                fund,
                portfolio,
                entity,
                interest_overdue,
                principal_overdue,
                charges_overdue,
            )
            if len(dpd_cashflows) > 0:
                total_amount_dpd = dpd_cashflows["cashflow"].to_numpy(dtype="float")
                total_amount = np.append(total_amount, total_amount_dpd)

            coupon_array = cashflow_model_results["cashflow"].to_numpy()

        cashflow_model_results = cashflow_model_results.astype(
            {"time_to_maturity": "float64", "cashflow": "float64", "transaction_date": "datetime64[ns]"}
        )

        output_msg = output_check_fn(
            cashflow_results=cashflow_model_results[cashflow_model_results["time_to_maturity"] != 0]
        )

        if output_msg["CF_Output"] == "Present":
            if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
                TTM = (cashflow_model_results["time_to_maturity"].to_numpy()).astype("float64")
                if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                    zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == Discount_Curve), :]
                    tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                    rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                    zero_rates = np.empty([0], dtype="float64")
                    extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                    curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[
                        0
                    ]
                    for j in TTM:
                        if zero_rate_curve_points["interpolation_algorithm"].iloc[0] == "Linear":
                            inter_val = linearinterp(tenor, rates, j)
                            if inter_val is None:
                                if extrapolation_algorithm == "Linear":
                                    extrapolated_value = linearexterp(tenor, rates, j)
                                else:
                                    extrapolated_value = flatexterp(tenor, rates, j)
                                zero_rates = np.append(zero_rates, extrapolated_value)
                            else:
                                interpolated_value = inter_val
                                zero_rates = np.append(zero_rates, interpolated_value)
                    zero_rate_curve_points = None
                    tenor = None
                    rates = None
                    del zero_rate_curve_points
                    del tenor
                    del rates
                    # Add Credit Spread Rate to zero_rates
                    if str(Credit_Spread_Rate) not in ["nan", "None"]:
                        zero_rates = zero_rates + float(Credit_Spread_Rate)
                    elif str(Credit_Spread_Curve) not in ["nan", "None"]:
                        credit_spread_curve_data = credit_spread_data.loc[
                            (credit_spread_data["credit_spread_curve_name"] == Credit_Spread_Curve), :
                        ]

                        if not credit_spread_curve_data.empty:
                            spread_tenor = credit_spread_curve_data.tenor.to_numpy()
                            spread_tenor_unit = credit_spread_curve_data.tenor_unit.to_numpy()
                            cs_interpolation_algorithm = credit_spread_curve_data[
                                "interpolation_algorithm"
                            ].iloc[0]
                            cs_extrapolation_algorithm = credit_spread_curve_data[
                                "extrapolation_algorithm"
                            ].iloc[0]
                            tenor_extrac = np.vectorize(tenor_extraction)
                            spread_tenor = tenor_extrac(spread_tenor, spread_tenor_unit)
                            del spread_tenor_unit
                            spread_rates = np.array(credit_spread_curve_data.spread_value.tolist())

                            credit_spread_rates = np.empty([0], dtype="float64")
                            for j in TTM:
                                interp_val = linearinterp(spread_tenor, spread_rates, j)
                                if interp_val is None:
                                    if cs_extrapolation_algorithm == "Linear":
                                        extrapolated_value = linearexterp(spread_tenor, spread_rates, j)
                                    else:
                                        extrapolated_value = flatexterp(spread_tenor, spread_rates, j)
                                    credit_spread_rates = np.append(credit_spread_rates, extrapolated_value)
                                else:
                                    interpolated_value = interp_val
                                    credit_spread_rates = np.append(credit_spread_rates, interpolated_value)
                            zero_rates = zero_rates + credit_spread_rates
                            credit_spread_curve_data = None
                            credit_spread_rates = None
                            del credit_spread_curve_data
                            del spread_tenor
                            del spread_rates
                            del credit_spread_rates
                    (
                        PV_output,
                        PV_table,
                        TTM_array,
                        Total_amount_array,
                        DF,
                        PV_coupons,
                        PV_principal,
                        PV_plus_1bps,
                        PV_minus_1bps,
                    ) = fixed_income_valuation(
                        TTM,
                        total_amount_array.astype("float64"),
                        zero_rates,
                        coupon_array.astype("float64"),
                        principal_amount_array.astype("float64"),
                        curve_compounding_frequency=curve_compounding_frequency,
                    )
                    cashflow_model_results["discount_factor"] = DF
                    if not cashflow_upload:
                        cashflow_model_results["present_value"] = PV_coupons
                    else:
                        cashflow_model_results["present_value"] = PV_table
                    output_msg = output_check_fn(valuation_output=PV_output)
                    if output_msg["Val_Output"] == "Present":
                        valuation_output = {
                            "PV": round(PV_output, 4),
                        }
                        measure_dict_val = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value per unit",
                            "measure_value": round(PV_output, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_dict_val_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value",
                            "measure_value": round(PV_output * Quantity, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_val)
                        measure_value.append(measure_dict_val_position)
                        valuation_results.append(valuation_output)
                        total_holding = Quantity * valuation_results[0]["PV"]

                        if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":
                            (
                                PV01,
                                macaulay_duration,
                                modified_duration,
                                effective_duration,
                                ytm,
                            ) = valuation_models.fixed_income_sensitivity_analysis(
                                PV_table,
                                TTM_array,
                                Total_amount_array,
                                Coupon_Frequency,
                                Coupon_Frequency_unit,
                                PV_output,
                                PV_plus_1bps,
                                PV_minus_1bps,
                            )
                            sensitivity_analysis.append(
                                {
                                    "Macaulay Duration": macaulay_duration,
                                    "Effective Duration": effective_duration,
                                    "Modified Duration": modified_duration,
                                    "PV01 per unit": PV01,
                                }
                            )
                            if isinstance(ytm, (np.ndarray)):
                                ytm = ytm[0]
                            else:
                                ytm = ytm
                            measure_dict_ytm = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Yield to Maturity",
                                "measure_value": ytm,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_ytm)
                            measure_dict_mac_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Macaulay Duration",
                                "measure_value": macaulay_duration,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mac_dur)
                            measure_dict_eff_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Effective Duration",
                                "measure_value": effective_duration,
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_eff_dur)
                            measure_dict_mod_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Modified Duration",
                                "measure_value": modified_duration,
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mod_dur)
                            measure_dict_pv01 = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01 per unit",
                                "measure_value": PV01,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01)
                            measure_dict_pv01_position = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01",
                                "measure_value": PV01 * Quantity,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01_position)

                    else:
                        valuation_output = {
                            "PV": "None",
                        }
                        total_holding = "None"
                        valuation_results.append(valuation_output)

            else:
                sensitivity_analysis.append(
                    {
                        "Macaulay_Duration": "-",
                        "Effective Duration": "-",
                        "Modified_Duration": "-",
                        "PV01 per unit": "-",
                    }
                )
                valuation_output = {
                    "PV": "None",
                }
                total_holding = "None"
                valuation_results.append(valuation_output)

        else:
            sensitivity_analysis.append(
                {
                    "Macaulay_Duration": "-",
                    "Effective Duration": "-",
                    "Modified_Duration": "-",
                    "PV01 per unit": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)
        if not cashflow_upload:
            cashflow_model_results = pd.concat(
                [cashflow_model_results, cashflow_model_results.iloc[[-1]]], ignore_index=True
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow")] = (
                outstanding_amount
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow_type")] = (
                "Principal amount"
            )
            if len(PV_principal) > 0:
                cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("present_value")] = (
                    PV_principal[-1]
                )
        cashflow_model_results = cashflow_model_results[cashflow_model_results["time_to_maturity"] != 0]
        if str(accrued_interest[0]) not in ["", "0.0", "None", "nan"]:
            cashflow_model_results = pd.concat(
                [cashflow_model_results, cashflow_model_results.iloc[[-1]]], ignore_index=True
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow")] = (
                accrued_interest[0]
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow_type")] = (
                "Accrued Interest"
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("transaction_date")] = (
                pd.to_datetime(Valuation_Date[0])
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("present_value")] = None
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("time_to_maturity")] = (
                cashflow_model_results["time_to_maturity"].iloc[0]
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("discount_factor")] = None
            cashflow_model_results = cashflow_model_results.sort_values(
                by=["transaction_date", "cashflow_type"], ascending=True
            )
        cashflow_model_results["cashflow"] = cashflow_model_results["cashflow"] * Quantity
        cashflow_model_results["present_value"] = present_value_check_function(
            cashflow_model_results["present_value"], Quantity
        )
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = Unique_Reference_Id
        final_output_dict["Position_Id"] = Position_Id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = Valuation_Date[0]
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Quantity"] = Quantity
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        measure_value = pd.DataFrame(measure_value)
        measure_value["currency"] = currency
        return final_output_dict, cashflow_model_results, measure_value

    elif row[column_index_dict["model_code"]] == "M047":
        final_output_dict = {}
        Issue_Date = pd.to_datetime(row[column_index_dict["issue_date"]], dayfirst=True)
        Maturity_Date = np.array([pd.to_datetime(row[column_index_dict["maturity_date"]], dayfirst=True)])
        outstanding_amount = np.array([float(row[column_index_dict["outstanding_amount"]])])
        if str(row[column_index_dict["face_value"]]) not in ["nan", "None", ""]:
            Face_Value = np.array([float(row[column_index_dict["face_value"]])])
        else:
            Face_Value = outstanding_amount
        if str(row[column_index_dict["redemption_amount"]]) not in ["nan", "None", ""]:
            Redemption_Amount = np.array([float(row[column_index_dict["redemption_amount"]])])
        else:
            Redemption_Amount = outstanding_amount
        accrued_interest = row[column_index_dict["accrued_interest"]]
        if str(accrued_interest) not in ["nan", "None", ""]:
            accrued_interest = np.array([float(accrued_interest / Quantity)], dtype="float")
        base_rate = float(row[column_index_dict["base_rate"]]) / 100
        if str(row[column_index_dict["fixed_spread"]]) not in ["", "nan", "None"]:
            fixed_spread = float(row[column_index_dict["fixed_spread"]]) / 100
        else:
            fixed_spread = 0
        interest_rate = base_rate + fixed_spread
        Coupon_Frequency = row[column_index_dict["payment_frequency"]]
        Coupon_Frequency_unit = row[column_index_dict["payment_frequency_units"]]
        Discount_Daycount = row[column_index_dict["discount_daycount_convention"]]
        Accrual_Daycount = row[column_index_dict["accrual_daycount_convention"]]
        Discount_Curve = row[column_index_dict["discounting_curve"]]
        Business_day_convention = np.array([row[column_index_dict["business_convention"]]])
        Last_coupon_date = row[column_index_dict["last_payment_date"]]
        if str(Last_coupon_date) not in ["nan", "NaT", "None", "-"]:
            Last_coupon_date = np.datetime64(row[column_index_dict["last_payment_date"]], "D")
        stub_date = row[column_index_dict["stub_date"]]
        if str(stub_date) not in ["nan", "NaT", "None", "-"]:
            stub_date = np.datetime64(row[column_index_dict["stub_date"]], "D")
        Credit_Spread_Rate = row[column_index_dict["credit_spread_rate"]]
        Credit_Spread_Curve = row[column_index_dict["credit_spread_curve"]]

        fixed_float_flag = row[column_index_dict["fixed_or_float_flag"]]
        next_reset_date = row[column_index_dict["next_reset_date"]]
        if str(next_reset_date) not in ["nan", "NaT", "None", "-"]:
            next_reset_date = np.datetime64(row[column_index_dict["next_reset_date"]], "D")
        accrual_convention_code = valuation_models.daycount_convention_code(Accrual_Daycount)
        discount_convention_code = valuation_models.daycount_convention_code(Discount_Daycount)

        interest_calculation_methodology = row[column_index_dict["interest_calculation_methodology"]]
        compounding_frequency = row[column_index_dict["compounding_frequency"]]
        compounding_frequency_unit = row[column_index_dict["compounding_frequency_unit"]]

        cashflow_uploaded_data_position = cashflow_uploaded_data.loc[
            cashflow_uploaded_data["position_id"] == Position_Id
        ]
        cashflow_uploaded_data_position["cashflow"] = cashflow_uploaded_data_position["cashflow"] / Quantity
        accrued_interest = cashflow_uploaded_data_position.loc[
            cashflow_uploaded_data_position["cashflow_type"] == "Accrued Interest", "cashflow"
        ]
        if len(accrued_interest) > 0:
            accrued_interest = np.array([accrued_interest.iloc[0]], dtype="float")
        else:
            accrued_interest = np.array([0], dtype="float")
        cashflow_uploaded_data_position = cashflow_uploaded_data_position.loc[
            cashflow_uploaded_data_position["cashflow_type"] != "Accrued Interest"
        ]
        cashflow_model_results = cashflow_uploaded_data_position.copy()
        cashflow_uploaded_data_position["coupons"] = np.where(
            cashflow_uploaded_data_position["cashflow_type"] == "Interest Proceeds",
            cashflow_uploaded_data_position["cashflow"],
            0,
        )
        cashflow_uploaded_data_position["principal"] = np.where(
            cashflow_uploaded_data_position["cashflow_type"].isin(
                ["Redemption Proceeds", "Principal Proceeds", "Principal Amount"]
            ),
            cashflow_uploaded_data_position["cashflow"],
            0,
        )
        coupon_array = cashflow_uploaded_data_position["coupons"].to_numpy()
        principal_amount_array = cashflow_uploaded_data_position["principal"].to_numpy()
        total_amount_array = cashflow_uploaded_data_position["cashflow"].to_numpy()
        cashflow_model_results = cashflow_model_results.sort_values(
            by=["transaction_date", "cashflow_type"], ascending=True
        )
        cashflow_model_results["principal_outstanding_beginning"] = 0
        cashflow_model_results["principal_outstanding_ending"] = 0

        if fixed_float_flag == "Float":
            cashflow_principal_dict = cashflow_model_results.loc[
                cashflow_model_results["cashflow_type"].isin(
                    ["Principal Amount", "Redemption Proceeds", "Principal Proceeds"]
                )
            ].to_dict("records")
            for i in range(0, len(cashflow_principal_dict)):
                if i == 0:
                    outstanding_amount_principal = outstanding_amount
                cashflow_model_results.loc[
                    (
                        cashflow_model_results["transaction_date"]
                        == cashflow_principal_dict[i]["transaction_date"]
                    )
                    & (
                        cashflow_model_results["cashflow_type"] == cashflow_principal_dict[i]["cashflow_type"]
                    ),
                    "principal_outstanding_beginning",
                ] = outstanding_amount_principal
                outstanding_amount_principal = (
                    outstanding_amount_principal - cashflow_principal_dict[i]["cashflow"]
                )
                cashflow_model_results.loc[
                    (
                        cashflow_model_results["transaction_date"]
                        == cashflow_principal_dict[i]["transaction_date"]
                    )
                    & (
                        cashflow_model_results["cashflow_type"] == cashflow_principal_dict[i]["cashflow_type"]
                    ),
                    "principal_outstanding_ending",
                ] = outstanding_amount_principal

        cashflow_model_results[["cashflow_status", "discount_factor", "present_value"]] = [
            cashflow_status,
            "",
            "",
        ]
        del cashflow_uploaded_data_position

        measure_value = []
        cashflow_model_results = cashflow_model_results.astype(
            {"time_to_maturity": "float64", "cashflow": "float64", "transaction_date": "datetime64[ns]"}
        )

        valuation_results = []
        sensitivity_analysis = []
        PV_principal = []
        output_msg = output_check_fn(
            cashflow_results=cashflow_model_results[cashflow_model_results["time_to_maturity"] != 0]
        )
        if output_msg["CF_Output"] == "Present":
            if config_dict["inputs"]["Output_choice"]["Valuation"] == "Yes":
                TTM = (cashflow_model_results["time_to_maturity"].to_numpy()).astype("float64")
                if config_dict["inputs"]["Valuation_Method"] == "risk_based_valuation":
                    zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == Discount_Curve), :]
                    tenor = np.array(zero_rate_curve_points["tenor"], dtype="float64")
                    rates = np.array(zero_rate_curve_points["rate"], dtype="float64")
                    zero_rates = np.empty([0], dtype="float64")
                    extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
                    curve_compounding_frequency = zero_rate_curve_points["compounding_frequency_output"].iloc[
                        0
                    ]
                    for j in range(len(TTM)):
                        if zero_rate_curve_points["interpolation_algorithm"].iloc[0] == "Linear":
                            inter_val = linearinterp(tenor, rates, TTM[j])
                            if inter_val is None:
                                if extrapolation_algorithm == "Linear":
                                    extrapolated_value = linearexterp(tenor, rates, TTM[j])
                                else:
                                    extrapolated_value = flatexterp(tenor, rates, TTM[j])
                                zero_rates = np.append(zero_rates, extrapolated_value)
                            else:
                                interpolated_value = inter_val
                                zero_rates = np.append(zero_rates, interpolated_value)
                    zero_rate_curve_points = None

                    del zero_rate_curve_points

                    # Add Credit Spread Rate to zero_rates
                    if str(Credit_Spread_Rate) not in ["nan", "None"]:
                        zero_rates = zero_rates + float(Credit_Spread_Rate)
                    elif str(Credit_Spread_Curve) not in ["nan", "None"]:
                        credit_spread_curve_data = credit_spread_data.loc[
                            (credit_spread_data["credit_spread_curve_name"] == Credit_Spread_Curve), :
                        ]
                        cs_interpolation_algorithm = credit_spread_curve_data["interpolation_algorithm"].iloc[
                            0
                        ]
                        cs_extrapolation_algorithm = credit_spread_curve_data["extrapolation_algorithm"].iloc[
                            0
                        ]

                        if not credit_spread_curve_data.empty:
                            spread_tenor = credit_spread_curve_data.tenor.to_numpy()
                            spread_tenor_unit = credit_spread_curve_data.tenor_unit.to_numpy()
                            tenor_extrac = np.vectorize(tenor_extraction)
                            spread_tenor = tenor_extrac(spread_tenor, spread_tenor_unit)
                            spread_rates = credit_spread_curve_data.spread_value.to_numpy()
                            credit_spread_rates = np.empty([0], dtype="float64")

                            logging.warning(f"TENOR VM - {spread_tenor}")
                            logging.warning(f"RATES VM - {spread_rates}")
                            logging.warning(f"interpolation_algorithm VM - {cs_interpolation_algorithm}")
                            logging.warning(f"extrapolation_algorithm VM - {cs_extrapolation_algorithm}")

                            for j in TTM:
                                interp_val = linearinterp(spread_tenor, spread_rates, j)
                                if interp_val is None:
                                    if cs_extrapolation_algorithm == "Linear":
                                        extrapolated_value = linearexterp(spread_tenor, spread_rates, j)
                                    else:
                                        extrapolated_value = flatexterp(spread_tenor, spread_rates, j)
                                    credit_spread_rates = np.append(credit_spread_rates, extrapolated_value)
                                else:
                                    interpolated_value = interp_val
                                    credit_spread_rates = np.append(credit_spread_rates, interpolated_value)
                            
                            logging.warning(f"{Position_Id} - {TTM} - {len(TTM)}")
                            logging.warning(f"{Position_Id} - {credit_spread_rates} - {len(credit_spread_rates)}")
                            zero_rates = zero_rates + credit_spread_rates
                            logging.warning(f"{Position_Id} - {zero_rates} - {len(zero_rates)}")

                    zero_rates = zero_rates.astype("float64")
                    (
                        PV_output,
                        PV_table,
                        TTM_array,
                        Total_amount_array,
                        DF,
                        PV_coupons,
                        PV_principal,
                        PV_plus_1bps,
                        PV_minus_1bps,
                    ) = fixed_income_valuation(
                        TTM,
                        total_amount_array.astype("float64"),
                        zero_rates,
                        coupon_array.astype("float64"),
                        principal_amount_array.astype("float64"),
                        curve_compounding_frequency=curve_compounding_frequency,
                    )

                    cashflow_model_results["discount_factor"] = DF
                    cashflow_model_results["present_value"] = PV_table
                    output_msg = output_check_fn(valuation_output=PV_output)

                    if output_msg["Val_Output"] == "Present":
                        valuation_output = {
                            "PV": round(PV_output, 4),
                        }
                        measure_dict_val = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value per unit",
                            "measure_value": round(PV_output, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_dict_val_position = {
                            "measure_run_date": datetime.now(),
                            "valuation_date": Valuation_Date[0],
                            "unique_reference_id": Unique_Reference_Id,
                            "position_id": Position_Id,
                            "reference_dimension": reference_dimension,
                            "measure_type": "Fair Value",
                            "measure_value": round(PV_output, 4),
                            "absolute_relative": "Absolute",
                            "residual_maturity": TTM_array[-1],
                            "asset_liability_type": asset_liability_type,
                            "product_variant_name": product_variant_name,
                            "fund": fund,
                            "portfolio": portfolio,
                            "cohort": "",
                            "entity": entity,
                        }
                        measure_value.append(measure_dict_val)
                        measure_value.append(measure_dict_val_position)
                        valuation_results.append(valuation_output)
                        total_holding = Quantity * valuation_results[0]["PV"]

                        if config_dict["inputs"]["Output_choice"]["Sensitivity_Analysis"] == "Yes":
                            if fixed_float_flag == "Float":
                                cashflow_model_results["zero_rates"] = zero_rates
                                interest_date_reset_check = cashflow_model_results.loc[
                                    (cashflow_model_results["transaction_date"] == next_reset_date)
                                    & (cashflow_model_results["cashflow_type"] == "Interest Proceeds")
                                ]
                                principal_date_check = cashflow_model_results.loc[
                                    (
                                        cashflow_model_results["cashflow_type"].isin(
                                            ["Principal Amount", "Redemption Proceeds", "Principal Proceeds"]
                                        )
                                    )
                                    & (cashflow_model_results["transaction_date"] < next_reset_date)
                                ]
                                # All interest cashflows before and on next reset date and principal cashflows
                                reset_filterered_df = cashflow_model_results.loc[
                                    (
                                        (
                                            cashflow_model_results["cashflow_type"].isin(
                                                [
                                                    "Principal Amount",
                                                    "Redemption Proceeds",
                                                    "Principal Proceeds",
                                                ]
                                            )
                                        )
                                        & (cashflow_model_results["transaction_date"] < next_reset_date)
                                    )
                                    | (
                                        (
                                            cashflow_model_results["cashflow_type"].isin(
                                                [
                                                    "Interest Proceeds",
                                                    "Charges Overdue",
                                                    "Interest Overdue",
                                                    "Principal Overdue",
                                                ]
                                            )
                                        )
                                        & (cashflow_model_results["transaction_date"] <= next_reset_date)
                                    )
                                ]
                                reset_maturity = conventions.A_day_count(
                                    Valuation_Date[0],
                                    next_reset_date,
                                    discount_convention_code,
                                    custom_daycount_conventions=custom_daycount_conventions,
                                )

                                # Case 1 - No principal cashflows before reset date
                                if len(principal_date_check) == 0:
                                    reset_df_principal = cashflow_model_results.loc[
                                        (cashflow_model_results["cashflow_type"] == "Interest Proceeds")
                                    ].head(1)
                                    reset_df_principal["cashflow_type"] = "Principal Amount"
                                    reset_df_principal["cashflow"] = outstanding_amount
                                    reset_df_principal["transaction_date"] = next_reset_date
                                    reset_df_principal["time_to_maturity"] = reset_maturity
                                    reset_filterered_df = pd.concat(
                                        [reset_filterered_df, reset_df_principal], ignore_index=True
                                    )

                                # Case 2 - Principal cashflows on or before reset date
                                else:
                                    reset_df_principal = cashflow_model_results.loc[
                                        (cashflow_model_results["cashflow_type"] == "Interest Proceeds")
                                    ].head(1)
                                    reset_df_principal["cashflow_type"] = "Principal Amount"
                                    principal_outstanding = cashflow_model_results.loc[
                                        (
                                            cashflow_model_results["cashflow_type"].isin(
                                                [
                                                    "Principal Amount",
                                                    "Redemption Proceeds",
                                                    "Principal Proceeds",
                                                ]
                                            )
                                        )
                                        & (cashflow_model_results["transaction_date"] >= next_reset_date)
                                    ]["cashflow"].sum()
                                    reset_df_principal["cashflow"] = principal_outstanding
                                    reset_df_principal["transaction_date"] = next_reset_date
                                    reset_df_principal["time_to_maturity"] = reset_maturity
                                    reset_filterered_df = pd.concat(
                                        [reset_filterered_df, reset_df_principal], ignore_index=True
                                    )

                                if len(interest_date_reset_check) == 0:
                                    interest_till_reset_dict = reset_filterered_df.loc[
                                        (
                                            reset_filterered_df["cashflow_type"].isin(
                                                [
                                                    "Principal Amount",
                                                    "Redemption Proceeds",
                                                    "Principal Proceeds",
                                                ]
                                            )
                                        )
                                        & (reset_filterered_df["transaction_date"] == next_reset_date)
                                    ].to_dict("records")
                                    previous_payment_date = cashflow_model_results.loc[
                                        (cashflow_model_results["transaction_date"] < next_reset_date)
                                        & (cashflow_model_results["cashflow_type"] == "Interest Proceeds")
                                    ]
                                    if len(previous_payment_date) > 0:
                                        previous_payment_date_val = np.datetime64(
                                            pd.to_datetime(
                                                previous_payment_date["transaction_date"].max(), dayfirst=True
                                            ).date()
                                        )
                                        interest_cashflow = 0
                                        val_date_check = False
                                    else:
                                        previous_payment_date_val = last_payment_date
                                        val_date_check = True
                                        interest_cashflow = accrued_interest[0]

                                    principal_payment_dates_between_previous_interest_payment_and_reset = (
                                        cashflow_model_results.loc[
                                            (
                                                cashflow_model_results["cashflow_type"].isin(
                                                    [
                                                        "Principal Amount",
                                                        "Redemption Proceeds",
                                                        "Principal Proceeds",
                                                    ]
                                                )
                                            )
                                            & (cashflow_model_results["transaction_date"] < next_reset_date)
                                            & (
                                                cashflow_model_results["transaction_date"]
                                                > previous_payment_date_val
                                            ),
                                            "transaction_date",
                                        ].tolist()
                                    )
                                    if (
                                        len(
                                            principal_payment_dates_between_previous_interest_payment_and_reset
                                        )
                                        != 0
                                    ):
                                        for i in range(
                                            0,
                                            len(
                                                principal_payment_dates_between_previous_interest_payment_and_reset
                                            ),
                                        ):
                                            principal_outstanding_beginning = cashflow_model_results.loc[
                                                (
                                                    cashflow_model_results["cashflow_type"].isin(
                                                        [
                                                            "Principal Amount",
                                                            "Redemption Proceeds",
                                                            "Principal Proceeds",
                                                        ]
                                                    )
                                                )
                                                & (
                                                    cashflow_model_results["transaction_date"]
                                                    == principal_payment_dates_between_previous_interest_payment_and_reset[
                                                        i
                                                    ]
                                                ),
                                                "principal_outstanding_ending",
                                            ]
                                            if (
                                                i
                                                == principal_payment_dates_between_previous_interest_payment_and_reset[
                                                    -1
                                                ]
                                            ):
                                                if (
                                                    len(
                                                        principal_payment_dates_between_previous_interest_payment_and_reset
                                                    )
                                                    == 1
                                                ):
                                                    if val_date_check:
                                                        year_frac = conventions.A_day_count(
                                                            valuation_date[0],
                                                            next_reset_date,
                                                            accrual_convention_code,
                                                            custom_daycount_conventions=custom_daycount_conventions,
                                                        )
                                                    else:
                                                        year_frac = conventions.A_day_count(
                                                            previous_payment_date_val,
                                                            next_reset_date,
                                                            accrual_convention_code,
                                                            custom_daycount_conventions=custom_daycount_conventions,
                                                        )
                                                else:
                                                    year_frac = conventions.A_day_count(
                                                        principal_payment_dates_between_previous_interest_payment_and_reset[
                                                            i - 1
                                                        ],
                                                        next_reset_date,
                                                        accrual_convention_code,
                                                        custom_daycount_conventions=custom_daycount_conventions,
                                                    )
                                            else:
                                                if (
                                                    len(
                                                        principal_payment_dates_between_previous_interest_payment_and_reset
                                                    )
                                                    == 1
                                                ):
                                                    if val_date_check:
                                                        year_frac = conventions.A_day_count(
                                                            valuation_date[0],
                                                            principal_payment_dates_between_previous_interest_payment_and_reset[
                                                                i
                                                            ],
                                                            accrual_convention_code,
                                                            custom_daycount_conventions=custom_daycount_conventions,
                                                        )
                                                    else:
                                                        year_frac = conventions.A_day_count(
                                                            previous_payment_date_val,
                                                            principal_payment_dates_between_previous_interest_payment_and_reset[
                                                                i
                                                            ],
                                                            accrual_convention_code,
                                                            custom_daycount_conventions=custom_daycount_conventions,
                                                        )
                                                else:
                                                    year_frac = conventions.A_day_count(
                                                        principal_payment_dates_between_previous_interest_payment_and_reset[
                                                            i - 1
                                                        ],
                                                        principal_payment_dates_between_previous_interest_payment_and_reset[
                                                            i
                                                        ],
                                                        accrual_convention_code,
                                                        custom_daycount_conventions=custom_daycount_conventions,
                                                    )
                                            interest_cashflow += (
                                                principal_outstanding_beginning * year_frac * interest_rate
                                            )
                                    else:
                                        if val_date_check:
                                            year_frac = conventions.A_day_count(
                                                valuation_date[0],
                                                next_reset_date,
                                                accrual_convention_code,
                                                custom_daycount_conventions=custom_daycount_conventions,
                                            )
                                            interest_cashflow += (
                                                outstanding_amount * year_frac * interest_rate
                                            )
                                        else:
                                            year_frac = conventions.A_day_count(
                                                previous_payment_date_val,
                                                next_reset_date,
                                                accrual_convention_code,
                                                custom_daycount_conventions=custom_daycount_conventions,
                                            )
                                            previous_principal_payment_date = cashflow_model_results.loc[
                                                (
                                                    cashflow_model_results["cashflow_type"].isin(
                                                        [
                                                            "Principal Amount",
                                                            "Redemption Proceeds",
                                                            "Principal Proceeds",
                                                        ]
                                                    )
                                                )
                                                & (
                                                    cashflow_model_results["transaction_date"]
                                                    <= previous_payment_date_val
                                                ),
                                                "transaction_date",
                                            ].max()
                                            outstanding_amount = cashflow_model_results.loc[
                                                (
                                                    cashflow_model_results["cashflow_type"].isin(
                                                        [
                                                            "Principal Amount",
                                                            "Redemption Proceeds",
                                                            "Principal Proceeds",
                                                        ]
                                                    )
                                                )
                                                & (
                                                    cashflow_model_results["transaction_date"]
                                                    == previous_principal_payment_date
                                                ),
                                                "principal_outstanding_ending",
                                            ].iloc[0]
                                            interest_cashflow += (
                                                outstanding_amount * year_frac * interest_rate
                                            )

                                    interest_till_reset_dict[0]["cashflow"] = interest_cashflow
                                    interest_till_reset_dict[0]["cashflow_type"] = "Interest Proceeds"
                                    reset_filterered_df = pd.concat(
                                        [reset_filterered_df, pd.DataFrame(interest_till_reset_dict)],
                                        ignore_index=True,
                                    )

                                reset_zero_rate = linearinterp(tenor, rates, reset_maturity)
                                if reset_zero_rate is None:
                                    if extrapolation_algorithm == "Linear":
                                        reset_zero_rate = linearexterp(tenor, rates, reset_maturity)
                                    else:
                                        reset_zero_rate = flatexterp(tenor, rates, reset_maturity)

                                if str(Credit_Spread_Rate) not in ["nan", "None"]:
                                    reset_zero_rate = reset_zero_rate + float(Credit_Spread_Rate)
                                elif str(Credit_Spread_Curve) not in ["nan", "None"]:
                                    if not credit_spread_curve_data.empty:
                                        reset_credit_spread = linearinterp(
                                            spread_tenor, spread_rates, reset_maturity
                                        )
                                        if reset_credit_spread is None:
                                            if cs_extrapolation_algorithm == "Linear":
                                                reset_credit_spread = linearexterp(
                                                    spread_tenor, spread_rates, reset_maturity
                                                )
                                            else:
                                                reset_credit_spread = flatexterp(
                                                    spread_tenor, spread_rates, reset_maturity
                                                )
                                            credit_spread_rates = np.append(
                                                credit_spread_rates, reset_credit_spread
                                            )
                                        reset_zero_rate = reset_zero_rate + reset_credit_spread

                                reset_filterered_df.loc[
                                    reset_filterered_df["transaction_date"] == next_reset_date, "zero_rates"
                                ] = reset_zero_rate

                                (
                                    PV_output_sens,
                                    PV_table_sens,
                                    TTM_array_sens,
                                    Total_amount_array_sens,
                                    DF_sens,
                                    PV_coupons_sens,
                                    PV_principal_sens,
                                    PV_plus_1bps_sens,
                                    PV_minus_1bps_sens,
                                ) = fixed_income_valuation(
                                    (reset_filterered_df["time_to_maturity"].to_numpy()).astype("float64"),
                                    (reset_filterered_df["cashflow"].to_numpy()).astype("float64"),
                                    (reset_filterered_df["zero_rates"].to_numpy()).astype("float64"),
                                    (reset_filterered_df["cashflow"].to_numpy()).astype("float64"),
                                    (reset_filterered_df["cashflow"].to_numpy()).astype("float64"),
                                    curve_compounding_frequency=curve_compounding_frequency,
                                )
                                (
                                    PV01,
                                    macaulay_duration,
                                    modified_duration,
                                    effective_duration,
                                    ytm,
                                ) = valuation_models.fixed_income_sensitivity_analysis(
                                    PV_table_sens,
                                    TTM_array_sens,
                                    Total_amount_array_sens,
                                    Coupon_Frequency,
                                    Coupon_Frequency_unit,
                                    PV_output_sens,
                                    PV_plus_1bps_sens,
                                    PV_minus_1bps_sens,
                                )

                            else:

                                (
                                    PV01,
                                    macaulay_duration,
                                    modified_duration,
                                    effective_duration,
                                    ytm,
                                ) = valuation_models.fixed_income_sensitivity_analysis(
                                    PV_table,
                                    TTM_array,
                                    Total_amount_array,
                                    Coupon_Frequency,
                                    Coupon_Frequency_unit,
                                    PV_output,
                                    PV_plus_1bps,
                                    PV_minus_1bps,
                                )

                            sensitivity_analysis.append(
                                {
                                    "Macaulay_Duration": macaulay_duration,
                                    "Effective Duration": effective_duration,
                                    "Modified_Duration": modified_duration,
                                    "PV01 per unit": PV01,
                                }
                            )
                            if isinstance(ytm, (np.ndarray)):
                                ytm = ytm[0]
                            else:
                                ytm = ytm
                            measure_dict_ytm = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Yield to Maturity",
                                "measure_value": ytm,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_ytm)
                            measure_dict_mac_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Macaulay Duration",
                                "measure_value": macaulay_duration,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mac_dur)
                            measure_dict_eff_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Effective Duration",
                                "measure_value": effective_duration,
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_eff_dur)
                            measure_dict_mod_dur = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "Modified Duration",
                                "measure_value": modified_duration,
                                "absolute_relative": "Relative",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_mod_dur)
                            measure_dict_pv01 = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01 per unit",
                                "measure_value": PV01,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01)
                            measure_dict_pv01_position = {
                                "measure_run_date": datetime.now(),
                                "valuation_date": Valuation_Date[0],
                                "unique_reference_id": Unique_Reference_Id,
                                "position_id": Position_Id,
                                "reference_dimension": reference_dimension,
                                "measure_type": "PV01",
                                "measure_value": PV01 * Quantity,
                                "absolute_relative": "Absolute",
                                "residual_maturity": TTM_array[-1],
                                "asset_liability_type": asset_liability_type,
                                "product_variant_name": product_variant_name,
                                "fund": fund,
                                "portfolio": portfolio,
                                "cohort": "",
                                "entity": entity,
                            }
                            measure_value.append(measure_dict_pv01_position)
                    else:
                        valuation_output = {
                            "PV": "None",
                        }
                        total_holding = "None"
                        valuation_results.append(valuation_output)

            else:
                sensitivity_analysis.append(
                    {
                        "Macaulay_Duration": "-",
                        "Effective Duration": "-",
                        "Modified_Duration": "-",
                        "PV01 per unit": "-",
                    }
                )
                valuation_output = {
                    "PV": "None",
                }
                total_holding = "None"
                valuation_results.append(valuation_output)

        else:
            sensitivity_analysis.append(
                {
                    "Macaulay_Duration": "-",
                    "Effective Duration": "-",
                    "Modified_Duration": "-",
                    "PV01 per unit": "-",
                }
            )
            valuation_output = {
                "PV": "None",
            }
            total_holding = "None"
            valuation_results.append(valuation_output)

        cashflow_model_results = cashflow_model_results[cashflow_model_results["time_to_maturity"] != 0]

        if str(accrued_interest[0]) not in ["", "0.0", "None", "nan"]:
            cashflow_model_results = pd.concat(
                [cashflow_model_results, cashflow_model_results.iloc[[-1]]], ignore_index=True
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow")] = (
                accrued_interest[0]
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("cashflow_type")] = (
                "Accrued Interest"
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("transaction_date")] = (
                pd.to_datetime(Valuation_Date[0])
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("present_value")] = None
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("time_to_maturity")] = (
                cashflow_model_results["time_to_maturity"].iloc[0]
            )
            cashflow_model_results.iloc[-1, cashflow_model_results.columns.get_loc("discount_factor")] = None
            cashflow_model_results = cashflow_model_results.sort_values(
                by=["transaction_date", "cashflow_type"], ascending=True
            )

        if "zero_rates" in cashflow_model_results.columns.tolist():
            cashflow_model_results.drop(
                columns=["principal_outstanding_beginning", "principal_outstanding_ending", "zero_rates"],
                inplace=True,
            )
        else:
            cashflow_model_results.drop(
                columns=["principal_outstanding_beginning", "principal_outstanding_ending"], inplace=True
            )

        cashflow_model_results["cashflow"] = cashflow_model_results["cashflow"]
        cashflow_model_results["position_id"] = Position_Id
        final_output_dict["Unique_Reference_ID"] = Unique_Reference_Id
        final_output_dict["Position_Id"] = Position_Id
        final_output_dict["Product_Variant_Name"] = product_variant_name
        final_output_dict["Valuation_Date"] = Valuation_Date[0]
        final_output_dict["Cashflow_Result"] = json.dumps(
            cashflow_model_results.replace("", "-").fillna("-").to_dict("records"), cls=NpEncoder
        )
        if str(type(valuation_results[0]["PV"])) in ["float", "int"]:
            final_output_dict["Fair_Value_Per_Unit"] = round(valuation_results[0]["PV"], 4)
            final_output_dict["Total_Holding"] = round(total_holding, 4)
        else:
            final_output_dict["Fair_Value_Per_Unit"] = valuation_results[0]["PV"]
            final_output_dict["Total_Holding"] = total_holding
        final_output_dict["Quantity"] = Quantity
        final_output_dict["Sensitivity"] = json.dumps(sensitivity_analysis)
        measure_value = pd.DataFrame(measure_value)
        measure_value["currency"] = currency
        return final_output_dict, cashflow_model_results, measure_value

    else:
        pass


valuation_models = Valuation_Models()


def emi_cashflow_generation(
    fund,
    portfolio,
    issue_date,
    last_payment_date,
    payment_amount,
    maturity_date,
    interest_rate,
    payment_frequency,
    payment_frequency_unit,
    loan_amount,
    position_id,
    business_convention,
    discount_convention,
    accrual_convention,
    product_variant,
    currency,
    valuation_date,
    entity,
    asset_liability_type,
    holiday_calendar,
    custom_daycount_conventions=None,
    accrued_interest=None,
    stub_date=None,
    business_days="1111100",
    moratorium_end_date="",
    moratorium_flag="N",
    interest_moratorium_flag="N",
    moratorium_interest_and_accrued_interest=0,
    fixed_payment_day_flag="No",
    fixed_payment_day="",
    payment_window="",
    repayment_period_month_day_start="",
    repayment_period_month_day_end="",
    first_emi_flag = "No",
    first_emi_amount = None,
):

    coupon_frequency = valuation_models.coupon_Frequency(payment_frequency, payment_frequency_unit)
    if str(last_payment_date) in ["None", "NaT", "-", "nan"]:
        if str(stub_date) in ["None", "NaT", "-", "nan"]:
            Begining_Date_array, Ending_Date_array = valuation_models.month_range_day(
                issue_date, maturity_date[0], int(12 / coupon_frequency)
            )
        else:
            Begining_Date_array_0 = np.array([issue_date], dtype="datetime64[D]")
            Ending_Date_array_0 = np.array([stub_date], dtype="datetime64[D]")
            Begining_Date_array, Ending_Date_array = valuation_models.month_range_day(
                stub_date,
                maturity_date[0],
                int(12 / coupon_frequency),
            )
            if fixed_payment_day_flag != "Yes":
                Begining_Date_array = np.concatenate((Begining_Date_array_0, Begining_Date_array))
                Ending_Date_array = np.concatenate((Ending_Date_array_0, Ending_Date_array))
    else:
        Begining_Date_array, Ending_Date_array = valuation_models.month_range_day(
            last_payment_date, maturity_date[0], int(12 / coupon_frequency)
        )
    Cashflow_Date_array = np.empty([0], dtype="datetime64[D]")
    convention_code = valuation_models.busday_convention_code(business_convention)
    del_index = []

    if fixed_payment_day_flag == "Yes":
        day_of_week = week_code_generator(fixed_payment_day)
        Begining_Date_array = Begining_Date_array.astype("datetime64[D]")
        Ending_Date_array = Ending_Date_array.astype("datetime64[D]")

        # Adjustment 1
        Begining_Date_array = nth_weekday_vectorized(Begining_Date_array, payment_window, day_of_week)
        Ending_Date_array = nth_weekday_vectorized(Ending_Date_array, payment_window, day_of_week)
        # Adjustment 2
        Begining_Date_array = payment_window_adjustment_vectorized(
            Begining_Date_array, repayment_period_month_day_start, repayment_period_month_day_end
        )
        Ending_Date_array = payment_window_adjustment_vectorized(
            Ending_Date_array, repayment_period_month_day_start, repayment_period_month_day_end
        )
        Begining_Date_array = Begining_Date_array.astype("datetime64[D]")
        Ending_Date_array = Ending_Date_array.astype("datetime64[D]")

        if str(stub_date) not in ["None", "NaT", "-", "nan"]:
            Begining_Date_array = np.concatenate((Begining_Date_array_0, Begining_Date_array))
            Ending_Date_array = np.concatenate((Ending_Date_array_0, Ending_Date_array))
        
        # Final Adjustment
        Ending_Date_array = Ending_Date_array[Ending_Date_array > valuation_date]
        del_index = np.where(Cashflow_Date_array <= valuation_date)
        Begining_Date_array = np.delete(Begining_Date_array, del_index)
        Begining_Date_array = np.where(Begining_Date_array<issue_date,issue_date,Begining_Date_array)
        Cashflow_Date_array = Ending_Date_array.astype("datetime64[D]")
       
        del_index = np.where(Begining_Date_array == maturity_date[0])
        Cashflow_Date_array = np.unique(Cashflow_Date_array[Cashflow_Date_array > valuation_date])
        Begining_Date_array = np.delete(Begining_Date_array, del_index)
        Begining_Date_array = Begining_Date_array.astype("datetime64[D]")
        Ending_Date_array = Ending_Date_array.astype("datetime64[D]")
        Cashflow_Date_array = Cashflow_Date_array.astype("datetime64[D]")
        
    elif convention_code == "EOM":
        Cashflow_Date_array = conventions.eomonth(Ending_Date_array, maturity_date[0])
        Begining_Date_array = conventions.eomonth(Begining_Date_array, maturity_date[0])
        Ending_Date_array = conventions.eomonth(Ending_Date_array, maturity_date[0])
        Ending_Date_array = Ending_Date_array[Ending_Date_array > valuation_date]
        del_index = np.where(Cashflow_Date_array <= valuation_date)
        Cashflow_Date_array = np.unique(Cashflow_Date_array[Cashflow_Date_array > valuation_date])
        Begining_Date_array = np.delete(Begining_Date_array, del_index)
    else:
        for i in range(Ending_Date_array.size):
            if Ending_Date_array[i] > valuation_date:
                Cashflow_Date_array = np.append(
                    Cashflow_Date_array,
                    conventions.business_day(
                        Ending_Date_array[i], convention_code, holiday_calendar, business_days=business_days
                    ),
                )
            else:
                del_index.append(i)
        for d_i in sorted(del_index, reverse=True):
            Begining_Date_array = np.delete(Begining_Date_array, d_i)
            Ending_Date_array = np.delete(Ending_Date_array, d_i)

    if interest_moratorium_flag == "Y":
        Cashflow_Date_array = Cashflow_Date_array[Cashflow_Date_array > moratorium_end_date]
        Ending_Date_array = Ending_Date_array[Ending_Date_array > moratorium_end_date]
        if str(last_payment_date) in ["None", "NaT", "-", "nan"]:
            Begining_Date_array = np.unique(np.append(Begining_Date_array, moratorium_end_date))
        Begining_Date_array = Begining_Date_array[Begining_Date_array >= moratorium_end_date]

    Year_frac_array = np.empty([0], dtype="float64")
    accrual_convention_code = valuation_models.daycount_convention_code(accrual_convention)
    discount_convention_code = valuation_models.daycount_convention_code(discount_convention)
    if str(accrued_interest) in ["nan", "None", ""]:
        if str(last_payment_date) in ["None", "NaT", "-", "nan"]:
            time_period = conventions.A_day_count(
                np.datetime64(issue_date, "D"),
                valuation_date,
                accrual_convention_code,
                custom_daycount_conventions=custom_daycount_conventions,
            )
        else:
            time_period = conventions.A_day_count(
                last_payment_date,
                valuation_date,
                accrual_convention_code,
                custom_daycount_conventions=custom_daycount_conventions,
            )
        accrued_interest = loan_amount * interest_rate * time_period

    TTM_array = conventions.D_day_count(
        valuation_date, Cashflow_Date_array, discount_convention_code, custom_daycount_conventions
    )

    if interest_moratorium_flag == "Y":
        Year_frac_0_value = conventions.A_day_count(
            Begining_Date_array[0],
            Cashflow_Date_array[0],
            accrual_convention_code,
            custom_daycount_conventions=custom_daycount_conventions,
        )
    elif str(last_payment_date) in ["None", "NaT", "-", "nan"]:
        Year_frac_0_value = conventions.A_day_count(
            np.datetime64(issue_date, "D"),
            Cashflow_Date_array[0],
            accrual_convention_code,
            custom_daycount_conventions=custom_daycount_conventions,
        )
    else:
        Year_frac_0_value = conventions.A_day_count(
            last_payment_date,
            Cashflow_Date_array[0],
            accrual_convention_code,
            custom_daycount_conventions=custom_daycount_conventions,
        )
    if Year_frac_0_value > 0:
        Year_frac_array = np.append(Year_frac_array, Year_frac_0_value)
    else:
        Year_frac_array = np.append(Year_frac_array, 0)
    
    for i in range(1, Begining_Date_array.size):
        if str(Cashflow_Date_array[i - 1]) == "NaT":
            Year_frac_value = conventions.A_day_count(
                last_payment_date,
                Cashflow_Date_array[i],
                accrual_convention_code,
                custom_daycount_conventions=custom_daycount_conventions,
            )
        else:
            Year_frac_value = conventions.A_day_count(
                Begining_Date_array[i],
                Cashflow_Date_array[i],
                accrual_convention_code,
                custom_daycount_conventions=custom_daycount_conventions,
            )

        if Year_frac_value > 0:
            Year_frac_array = np.append(Year_frac_array, Year_frac_value)
        else:
            Year_frac_array = np.append(Year_frac_array, 0)

    interest_amount_array = np.empty([0], dtype="float")
    principal_amount_array = np.empty([0], dtype="float")
    principal_outstanding_beginning = np.empty([0], dtype="float")
    principal_outstanding_ending = np.empty([0], dtype="float")

    for i in range(0, (Cashflow_Date_array.size)):
        if i == 0:
            if interest_moratorium_flag == "Y":
                if moratorium_interest_and_accrued_interest != 0 and moratorium_end_date <= valuation_date:
                    Year_frac_array[i] = conventions.A_day_count(
                        valuation_date,
                        Cashflow_Date_array[i],
                        accrual_convention_code,
                        custom_daycount_conventions=custom_daycount_conventions,
                    )
            else:
                if moratorium_interest_and_accrued_interest != 0:
                    Year_frac_array[i] = conventions.A_day_count(
                        valuation_date,
                        Cashflow_Date_array[i],
                        accrual_convention_code,
                        custom_daycount_conventions=custom_daycount_conventions,
                    )
            interest_amount = moratorium_interest_and_accrued_interest
        else:
            interest_amount = 0

        interest_amount += interest_rate * loan_amount * Year_frac_array[i]
        interest_amount_array = np.append(interest_amount_array, interest_amount)
        if i == 0 and first_emi_flag == "Yes" and str(first_emi_amount) not in ['nan','-','None']:
            principal_amount = first_emi_amount - interest_amount
        else:
            principal_amount = payment_amount - interest_amount
        loan_amount_original = loan_amount
        principal_outstanding_beginning = np.append(principal_outstanding_beginning, loan_amount_original)
        loan_amount_interim = loan_amount - principal_amount
        if loan_amount_interim < 0:
            principal_amount = loan_amount_original
            principal_amount_array = np.append(principal_amount_array, principal_amount)
        elif i == (len(Cashflow_Date_array) - 1) and loan_amount_interim > 0:
            principal_amount = loan_amount_original
            principal_amount_array = np.append(principal_amount_array, principal_amount)
        else:
            principal_amount_array = np.append(principal_amount_array, principal_amount)

        loan_amount = loan_amount - principal_amount
        principal_outstanding_ending = np.append(principal_outstanding_ending, loan_amount)

    negative_indexes = np.where(principal_amount_array < 0)
    principal_amount_array = np.delete(principal_amount_array, negative_indexes)
    interest_amount_array = np.delete(interest_amount_array, negative_indexes)
    Cashflow_Date_array = np.delete(Cashflow_Date_array, negative_indexes)
    principal_outstanding_beginning = np.delete(principal_outstanding_beginning, negative_indexes)
    principal_outstanding_ending = np.delete(principal_outstanding_ending, negative_indexes)
    TTM_array = np.delete(TTM_array, negative_indexes)
    cashflow_date_array = np.append(Cashflow_Date_array, Cashflow_Date_array)
    cashflow_array = np.append(principal_amount_array, interest_amount_array)
    interest_check = np.in1d(cashflow_array, interest_amount_array)
    cashflow_type_arr = np.where(interest_check, "Interest Proceeds", "Principal Proceeds")
    size_diff = cashflow_array.size - principal_amount_array.size
    zero_array = np.repeat(0, size_diff)
    interest_amount_array = np.append(interest_amount_array, zero_array)
    principal_amount_array = np.append(principal_amount_array, zero_array)
    principal_outstanding_beginning = np.append(principal_outstanding_beginning, zero_array)
    principal_outstanding_ending = np.append(principal_outstanding_ending, zero_array)

    result_array = np.array(
        [
            np.repeat(valuation_date, cashflow_date_array.size),
            cashflow_date_array,
            np.repeat(position_id, cashflow_date_array.size),
            np.repeat("Security", cashflow_date_array.size),
            cashflow_type_arr,
            np.repeat("Unrealised", cashflow_date_array.size),
            cashflow_array,
            np.append(TTM_array, TTM_array),
            np.repeat(0, cashflow_date_array.size),
            np.repeat(0, cashflow_date_array.size),
            np.repeat(currency, cashflow_date_array.size),
            np.repeat(asset_liability_type, cashflow_date_array.size),
            np.repeat(product_variant, cashflow_date_array.size),
            np.repeat(fund, cashflow_date_array.size),
            np.repeat(portfolio, cashflow_date_array.size),
            np.repeat("N/A", cashflow_date_array.size),
            np.repeat(entity, cashflow_date_array.size),
            interest_amount_array,
            principal_amount_array,
            np.repeat(accrued_interest[0], cashflow_date_array.size),
            principal_outstanding_beginning,
            principal_outstanding_ending,
        ]
    )
    return result_array


def pre_emi_cashflow_generation(
    issue_date,
    fund,
    portfolio,
    last_payment_date,
    payment_amount,
    maturity_date,
    interest_rate,
    payment_frequency,
    payment_frequency_unit,
    loan_amount,
    position_id,
    business_convention,
    discount_convention,
    accrual_convention,
    product_variant,
    currency,
    valuation_date,
    entity,
    asset_liability_type,
    holiday_calendar,
    emi_start_date,
    emi_end_date,
    custom_daycount_conventions=None,
    interest_moratorium_flag="Y",
    accrued_interest=None,
    stub_date=None,
    business_days="1111100",
):

    coupon_frequency = valuation_models.coupon_Frequency(payment_frequency, payment_frequency_unit)
    # Pre-EMI payments
    if interest_moratorium_flag == "Y":
        cashflows_pre_emi = valuation_models.fixed_coupon_cashflow_generation(
            position_id,
            issue_date,
            emi_start_date,
            loan_amount,
            loan_amount,
            interest_rate,
            payment_frequency,
            payment_frequency_unit,
            valuation_date,
            discount_convention,
            accrual_convention,
            "",
            business_convention,
            last_payment_date,
            holiday_calendar,
            custom_daycount_conventions,
            accrued_interest,
            stub_date=stub_date,
            business_days=business_days,
        )
        accrued_interest = cashflows_pre_emi[7]
        cashflow_dates_pre_emi = cashflows_pre_emi[2]
        emi_start_date_index = np.where(cashflow_dates_pre_emi == emi_start_date[0])[0][0]
        interest_pre_emi = cashflows_pre_emi[4]
        ttm_pre_emi = cashflows_pre_emi[3]
        cashflow_dates_pre_emi = np.delete(cashflow_dates_pre_emi, emi_start_date_index)
        interest_pre_emi = np.delete(interest_pre_emi, emi_start_date_index)
        ttm_pre_emi = np.delete(ttm_pre_emi, emi_start_date_index)
    else:
        cashflow_dates_pre_emi = np.empty([0], dtype="datetime64[D]")
        interest_pre_emi = np.empty([0], dtype=float)
        ttm_pre_emi = np.empty([0], dtype=float)
        accrued_interest = [None]

    # Normal EMI
    Begining_Date_array, Ending_Date_array = valuation_models.month_range_day(
        emi_start_date[0] - relativedelta(months=int(12 / coupon_frequency)),
        emi_end_date[0],
        int(12 / coupon_frequency),
    )
    Cashflow_Date_array = np.empty([0], dtype="datetime64[D]")
    convention_code = valuation_models.busday_convention_code(business_convention)
    del_index = []
    if convention_code == "EOM":
        Cashflow_Date_array = conventions.eomonth(Ending_Date_array, maturity_date[0])
        del_index = np.where(Cashflow_Date_array <= Valuation_Date)
        Cashflow_Date_array = np.unique(Cashflow_Date_array[Cashflow_Date_array > Valuation_Date])
        Begining_Date_array = np.delete(Begining_Date_array, del_index)
    else:
        for i in range(Ending_Date_array.size):
            if Ending_Date_array[i] > valuation_date:
                Cashflow_Date_array = np.append(
                    Cashflow_Date_array,
                    conventions.business_day(
                        Ending_Date_array[i], convention_code, holiday_calendar, business_days=business_days
                    ),
                )
            else:
                del_index.append(i)
        for d_i in sorted(del_index, reverse=True):
            Begining_Date_array = np.delete(Begining_Date_array, d_i)
            Ending_Date_array = np.delete(Ending_Date_array, d_i)
    Year_frac_array = np.empty([0], dtype="float64")
    accrual_convention_code = valuation_models.daycount_convention_code(accrual_convention)
    discount_convention_code = valuation_models.daycount_convention_code(discount_convention)
    TTM_array = conventions.D_day_count(
        valuation_date, Cashflow_Date_array, discount_convention_code, custom_daycount_conventions
    )
    Year_frac_0_value = conventions.A_day_count(
        np.array(emi_start_date[0] - relativedelta(months=int(12 / coupon_frequency)), dtype="datetime64[D]"),
        Ending_Date_array[0],
        accrual_convention_code,
        custom_daycount_conventions=custom_daycount_conventions,
    )
    if Year_frac_0_value > 0:
        Year_frac_array = np.append(Year_frac_array, Year_frac_0_value)
    else:
        Year_frac_array = np.append(Year_frac_array, 0)
    for i in range(1, Begining_Date_array.size):
        if str(Ending_Date_array[i - 1]) == "NaT":
            Year_frac_value = conventions.A_day_count(
                np.array(
                    emi_start_date[0] - relativedelta(months=int(12 / coupon_frequency)),
                    dtype="datetime64[D]",
                ),
                Ending_Date_array[i],
                accrual_convention_code,
                custom_daycount_conventions=custom_daycount_conventions,
            )
        else:
            Year_frac_value = conventions.A_day_count(
                Begining_Date_array[i],
                Ending_Date_array[i],
                accrual_convention_code,
                custom_daycount_conventions=custom_daycount_conventions,
            )

        if Year_frac_value > 0:
            Year_frac_array = np.append(Year_frac_array, Year_frac_value)
        else:
            Year_frac_array = np.append(Year_frac_array, 0)

    interest_amount_array = np.empty([0], dtype="float")
    principal_amount_array = np.empty([0], dtype="float")
    negative_index = np.empty([0], dtype="int")
    for i in range(0, (Cashflow_Date_array.size)):
        interest_amount = interest_rate * loan_amount * Year_frac_array[i]
        interest_amount_array = np.append(interest_amount_array, interest_amount)
        principal_amount = payment_amount - interest_amount
        loan_amount_original = loan_amount
        loan_amount = loan_amount - principal_amount
        if (i == Cashflow_Date_array.size - 1) and loan_amount > 0:
            # Principal Adjustment
            payment_amount = payment_amount + loan_amount
            principal_amount = payment_amount - interest_amount
            principal_amount_array = np.append(principal_amount_array, principal_amount)
        elif loan_amount < 0:
            principal_amount = loan_amount_original
            principal_amount_array = np.append(principal_amount_array, principal_amount)
        else:
            principal_amount_array = np.append(principal_amount_array, principal_amount)

    negative_indexes = np.where(principal_amount_array < 0)
    principal_amount_array = np.delete(principal_amount_array, negative_indexes)
    interest_amount_array = np.delete(interest_amount_array, negative_indexes)
    Cashflow_Date_array = np.delete(Cashflow_Date_array, negative_indexes)
    TTM_array = np.delete(TTM_array, negative_indexes)
    cashflow_date_array = np.append(Cashflow_Date_array, Cashflow_Date_array)
    cashflow_date_array = np.append(cashflow_dates_pre_emi, cashflow_date_array)
    cashflow_array = np.append(interest_amount_array, principal_amount_array)
    cashflow_array = np.append(interest_pre_emi, cashflow_array)
    interest_amount_array = np.append(interest_pre_emi, interest_amount_array)
    interest_check = np.in1d(cashflow_array, interest_amount_array)
    cashflow_type_arr = np.where(interest_check, "Interest Proceeds", "Principal Proceeds")
    zero_array_principal = np.repeat(0, cashflow_array.size - principal_amount_array.size)
    zero_array_interest = np.repeat(0, cashflow_array.size - interest_amount_array.size)
    interest_amount_array = np.append(interest_amount_array, zero_array_interest)
    principal_amount_array = np.append(principal_amount_array, zero_array_principal)
    ttm_array = np.append(TTM_array, TTM_array)
    ttm_array = np.append(ttm_pre_emi, ttm_array)
    result_array = np.array(
        [
            np.repeat(valuation_date, cashflow_date_array.size),
            cashflow_date_array,
            np.repeat(position_id, cashflow_date_array.size),
            np.repeat("Security", cashflow_date_array.size),
            cashflow_type_arr,
            np.repeat("Unrealised", cashflow_date_array.size),
            cashflow_array,
            ttm_array,
            np.repeat(0, cashflow_date_array.size),
            np.repeat(0, cashflow_date_array.size),
            np.repeat(currency, cashflow_date_array.size),
            np.repeat(asset_liability_type, cashflow_date_array.size),
            np.repeat(product_variant, cashflow_date_array.size),
            np.repeat(fund, cashflow_date_array.size),
            np.repeat(portfolio, cashflow_date_array.size),
            np.repeat("N/A", cashflow_date_array.size),
            np.repeat(entity, cashflow_date_array.size),
            interest_amount_array,
            principal_amount_array,
            np.repeat(accrued_interest[0], cashflow_date_array.size),
        ]
    )
    return result_array


def Value_extraction_fixed_income_government_portfolio(config_dict, curve_data, row="", holiday_calendar=[]):
    cashflow_model_results = pd.DataFrame()
    valuation_results = []
    sensitivity_analysis = []
    ISIN = np.array([row[0]])
    Issue_Date = np.array([pd.to_datetime(row[1], dayfirst=True)])
    Maturity_Date = np.array([pd.to_datetime(row[2], dayfirst=True)])
    Face_Value = np.array([row[3]])
    Redemption_Amount = np.array([row[4]])
    Coupon_Rate = np.array([row[5]])
    Coupon_Frequency = np.array([row[6]])
    Valuation_Date = np.array([pd.to_datetime(row[7], dayfirst=True)])
    Discount_Daycount = np.array([row[8]])
    Accrual_Daycount = np.array([row[9]])
    Discount_Curve = np.array([row[10]])
    Business_day_convention = np.array([row[11]])
    Last_coupon_date = np.array([pd.to_datetime(row[12], dayfirst=True)])
    cashflow_results = valuation_models.fixed_coupon_cashflow_generation(
        ISIN,
        Issue_Date,
        Maturity_Date,
        Face_Value,
        Redemption_Amount,
        Coupon_Rate,
        Coupon_Frequency,
        Valuation_Date,
        Discount_Daycount,
        Accrual_Daycount,
        Discount_Curve,
        Business_day_convention,
        Last_coupon_date,
        holiday_calendar,
    )
    index_values = [
        "ISIN",
        "Cashflow Dates",
        "Time Elapsed",
        "Coupons",
        "Principal",
        "Total_Amount",
        "PV of Coupons",
        "PV of Principal",
        "PV of Total Amount",
    ]
    cashflow_model_output = pd.DataFrame(data=cashflow_results, index=index_values).transpose()
    cashflow_model_results = pd.concat([cashflow_model_results, cashflow_model_output], ignore_index=True)
    if config_dict["outputs"]["Valuation"] == "Yes":
        zero_rate_curve = Discount_Curve[0]
        zero_rate_curve_points = curve_data.loc[(curve_data["curve_name"] == zero_rate_curve), :]
        interpolation_algorithm = zero_rate_curve_points["interpolation_algorithm"].iloc[0]
        extrapolation_algorithm = zero_rate_curve_points["extrapolation_algorithm"].iloc[0]
        zero_rate_points = np.array(json.loads(zero_rate_curve_points.curve_points.iloc[0]))
        tenor = np.array(zero_rate_points[0], dtype="float64")
        rates = np.array(zero_rate_points[1], dtype="float64")
        TTM = cashflow_model_results["Time Elapsed"].to_numpy(dtype="float64")
        Total_Amount = cashflow_model_results["Total Amount"].to_numpy(dtype="float64")
        Coupons = cashflow_model_results["Coupons"].to_numpy(dtype="float64")
        Principal = cashflow_model_results["Principal"].to_numpy(dtype="float64")
        zero_rates = np.empty([0], dtype="float64")
        for j in range(len(TTM)):
            if interpolation_algorithm == "Linear":
                if linearinterp(tenor, rates, TTM[j]) is None:
                    if extrapolation_algorithm == "Linear":
                        extrapolated_value = linearexterp(tenor, rates, TTM[j]) / 100
                    else:
                        extrapolated_value = flatexterp(tenor, rates, TTM[j]) / 100
                    zero_rates = np.append(zero_rates, extrapolated_value)
                else:
                    interpolated_value = linearinterp(tenor, rates, TTM[j]) / 100
                    zero_rates = np.append(zero_rates, interpolated_value)
        (
            PV_output,
            PV_table,
            TTM_array,
            Total_amount_array,
            df,
            PV_coupons,
            PV_principal,
            PV_plus_1bps,
            PV_minus_1bps,
        ) = fixed_income_valuation(TTM, Total_Amount, zero_rates, Coupons, Principal)
        cashflow_model_results["PV of Coupons"] = PV_coupons
        cashflow_model_results["PV of Principal"] = PV_principal
        cashflow_model_results["PV of Total Amount"] = PV_table
        valuation_output = {"ISIN": row[0], "Valuation Date": Valuation_Date, f"PV": round(PV_output, 4)}
        valuation_results.append(valuation_output)
        if config_dict["outputs"]["Sensitivity_Analysis"] == "Yes":
            (
                PV01,
                macaulay_duration,
                modified_duration,
                effective_duration,
                ytm,
            ) = valuation_models.fixed_income_sensitivity_analysis(
                PV_table,
                TTM_array,
                Total_amount_array,
                Coupon_Frequency,
                PV_output,
                PV_plus_1bps,
                PV_minus_1bps,
            )
            sensitivity_analysis.append(
                {
                    "Macaulay Duration": macaulay_duration,
                    "Effective Duration": effective_duration,
                    "Modified Duration": modified_duration,
                    "PV01 per unit": PV01,
                }
            )

    return cashflow_model_results, valuation_results, sensitivity_analysis


# @njit(cache=True, fastmath=True)
def eqpnl(prices):
    # replacing zeros in price data with median price
    returns = np.zeros(prices.shape[0])
    for i in range(1, prices.shape[0]):
        if prices[i - 1] > 0:
            returns[i] = np.log(prices[i] / prices[i - 1])
    # scenarios for EQ like asset followed pnl
    scenarios = prices[-1] * np.exp(returns)
    pnl = scenarios - scenarios[0]
    return pnl, returns


# rearranges the term structure of the bonds to give par rates for each tenor point (output: 1d list with all historical dates as rows)
def boot(i, df):
    # df is a dataframe with 1 row having yields and each tenor point as a column
    par = df.T[i].to_frame(name="YTM")
    rates = list(par["YTM"])
    return rates


# gives possible term structure for bonds in each scenario (output: Dataframe with tenors as columns and scenarios as rows)
def bondvar(df, boot, tenors, index):
    # parallelising operation over each tenor point
    rates = Parallel(n_jobs=multiprocessing.cpu_count())(delayed(boot)(i, df) for i in df.index)
    rates = pd.DataFrame(rates, columns=tenors, index=index)
    # returns calculation
    returns = np.log(rates / rates.shift(1))
    returns.iloc[0] = 0
    # scenarios calculation
    scenarios = pd.DataFrame(columns=tenors, index=index)
    scenarios.iloc[0] = df.iloc[-1]
    scenarios = scenarios.iloc[0] * np.exp(returns)
    return scenarios, returns


# calculates the diversified VaR of a portfolio (output: positions df with an additional column 'Diversified VaR' - same for all rows(assets))
def diver_var(df, p, hp, final_output, measures_output, position_data):
    # 1d array representing sum of all assets' pnls
    fin_pnl_0 = df.sum(axis=1)
    fin_pnl = df.sum(axis=1) * math.sqrt(hp)
    # masks required for barcharts and histograms
    mask1 = fin_pnl < 0
    mask2 = fin_pnl >= 0
    fig, axs = plt.subplots(1, 2, figsize=(10, 3))
    axs[0].bar(df.index[mask1], fin_pnl[mask1], width=0.6, color="black")
    axs[0].bar(df.index[mask2], fin_pnl[mask2], width=0.6, color="var(--primary-color)")
    axs[0].axhline(y=fin_pnl_0.quantile(1 - p / 100) * math.sqrt(hp), color="darkred", linestyle="dashed")
    axs[0].set_title("Scenario wise Profit & Loss")
    axs[1].set_title("Profit & Loss Distribution")
    N, bins, patches = axs[1].hist(fin_pnl, density=False, bins=len(fin_pnl), color="var(--primary-color)")
    figfile = BytesIO()
    plt.savefig(figfile, format="png", bbox_inches="tight", pad_inches=0.35)
    plt.close()
    figfile.seek(0)
    figdata_png = figfile.getvalue()
    figdata_png = base64.b64encode(figdata_png)
    var_plot = figdata_png.decode("utf8")
    # adding column to positions dataset wiith VaR for portfolio
    final_output["Portfolio - Diversified VaR"] = list(
        np.full(final_output.shape[0], -(np.percentile(np.array(sorted(fin_pnl_0)), 100 - p) * math.sqrt(hp)))
    )
    measures_output = measures_output.append(measures_output.iloc[[-1]])
    measures_output.iloc[-1, measures_output.columns.get_loc("unique_reference_id")] = measures_output[
        "portfolio"
    ].iloc[0]
    measures_output.iloc[-1, measures_output.columns.get_loc("measure_type")] = (
        "Portfolio Historical Simulation VaR - Diversified"
    )
    measures_output.iloc[-1, measures_output.columns.get_loc("measure_value")] = final_output[
        "Portfolio - Diversified VaR"
    ].iloc[0]
    measures_output.iloc[-1, measures_output.columns.get_loc("reference_dimension")] = "Portfolio"
    measures_output.iloc[-1, measures_output.columns.get_loc("residual_maturity")] = None
    measures_output.iloc[-1, measures_output.columns.get_loc("product_variant_name")] = None
    measures_output.iloc[-1, measures_output.columns.get_loc("fund")] = None
    measures_output.iloc[-1, measures_output.columns.get_loc("cohort")] = None
    measures_output.iloc[-1, measures_output.columns.get_loc("portfolio")] = None
    return final_output, measures_output, var_plot


# calculates the undiversified VaR of a portfolio (output: positions df with 2 additional columns: 'Undiversified VaR' - same for all rows(assets), 'Asset VaR' - different for each row(asset))
def undiver_var(df, p, hp, final_output, measures_output, position_data):
    var = []
    # storing var for each position in the positions data
    for i in df.columns:
        var_value = np.percentile(np.array(sorted(df[i])), 100 - p) * math.sqrt(hp)
        var.append({"position_id": i, "Security VaR": -var_value})
    var = pd.DataFrame(var)
    final_output = final_output.drop_duplicates(subset=["Position_Id"])
    # adding two columns, asset and undiversified var to positions dataset
    measures_fair_value = measures_output.loc[measures_output["measure_type"] == "Fair Value"]
    final_output = pd.merge(
        final_output, var, left_on="Position_Id", right_on="position_id", how="left"
    ).drop(columns=["position_id"])
    final_output["Portfolio - Undiversified VaR"] = var["Security VaR"].sum()
    measures_computation = final_output.loc[
        :, ["Unique_Reference_ID", "Position_Id", "Valuation_Date", "Security VaR"]
    ].rename(
        columns={
            "Unique_Reference_ID": "unique_reference_id",
            "Position_Id": "position_id",
            "Valuation_Date": "valuation_date",
            "Security VaR": "measure_value",
        }
    )
    measures_computation["measure_run_date"] = datetime.now()
    measures_computation["reference_dimension"] = "Security"
    measures_computation["measure_type"] = "Historical Simulation VaR"
    measures_computation["absolute_relative"] = "Absolute"
    measures_computation = pd.merge(
        measures_computation,
        measures_fair_value.loc[
            :,
            [
                "position_id",
                "currency",
                "residual_maturity",
                "asset_liability_type",
                "product_variant_name",
                "fund",
                "cohort",
                "portfolio",
                "entity",
            ],
        ],
        left_on="position_id",
        right_on="position_id",
        how="left",
    )
    measures_computation = pd.concat(
        [measures_computation, measures_computation.iloc[[-1]]], ignore_index=True
    )
    measures_computation.iloc[-1, measures_computation.columns.get_loc("unique_reference_id")] = (
        measures_fair_value["portfolio"].iloc[0]
    )
    measures_computation.iloc[-1, measures_computation.columns.get_loc("position_id")] = None
    measures_computation.iloc[-1, measures_computation.columns.get_loc("measure_type")] = (
        "Portfolio Historical Simulation VaR - Undiversified"
    )
    measures_computation.iloc[-1, measures_computation.columns.get_loc("measure_value")] = var[
        "Security VaR"
    ].sum()
    measures_computation.iloc[-1, measures_computation.columns.get_loc("reference_dimension")] = "Portfolio"
    measures_computation.iloc[-1, measures_computation.columns.get_loc("residual_maturity")] = None
    measures_computation.iloc[-1, measures_computation.columns.get_loc("product_variant_name")] = None
    measures_computation.iloc[-1, measures_computation.columns.get_loc("fund")] = None
    measures_computation.iloc[-1, measures_computation.columns.get_loc("cohort")] = None
    measures_computation.iloc[-1, measures_computation.columns.get_loc("portfolio")] = None
    measures_output = measures_output.append(measures_computation)
    final_output["Security VaR"] = final_output["Security VaR"].fillna("None")
    return final_output, measures_output


# gets historical price for equity like ith asset for jth date (output: historical price (float))
def fastfillrow(hist, i, j):
    # getting historical price for ith security from historical data
    if len(np.where((hist.security_identifier == i) & (hist.index == j))[0]) == 1:
        t = hist["quoted_price"][np.where((hist.security_identifier == i) & (hist.index == j))[0][0]]
    else:
        t = np.nan
    return t


# Revalues each interest rate product
def bond_revaluation(position_data, cashflow_data_position, model_code, zero_rates, credit_spread_data):
    interpolation_algorithm = "Linear"
    extrapolation_algorithm = "Linear"
    simulation = zero_rates.columns.tolist()[1]
    if model_code == "M001":
        tenor = np.array(zero_rates["tenor"], dtype="float64")
        rates = np.array(zero_rates[simulation], dtype="float64")
        zero_rates = np.empty([0], dtype="float64")
        TTM_array = np.array(cashflow_data_position["time_to_maturity"], dtype="float64")
        Redemption_Amount = np.array(position_data["redemption_amount"], dtype="float64")
        for j in range(len(TTM_array)):
            if interpolation_algorithm == "Linear":
                if linearinterp(tenor, rates, TTM_array[j]) is None:
                    if extrapolation_algorithm == "Linear":
                        extrapolated_value = linearexterp(tenor, rates, TTM_array[j])
                    else:
                        extrapolated_value = flatexterp(tenor, rates, TTM_array[j])
                    zero_rates = np.append(zero_rates, extrapolated_value)
                else:
                    interpolated_value = linearinterp(tenor, rates, TTM_array[j])
                    zero_rates = np.append(zero_rates, interpolated_value)
        PV, TTM_array, df, PV_plus_1bps, PV_minus_1bps = commercial_paper_valuation(
            TTM_array, Redemption_Amount, zero_rates
        )
    elif model_code == "M002":
        TTM = np.array(cashflow_data_position["time_to_maturity"], dtype="float64")
        Total_Amount = np.array(cashflow_data_position["cashflow"], dtype="float64")
        tenor = np.array(zero_rates["tenor"], dtype="float64")
        rates = np.array(zero_rates[simulation], dtype="float64")
        zero_rates = np.empty([0], dtype="float64")
        for j in range(len(TTM)):
            if interpolation_algorithm == "Linear":
                if linearinterp(tenor, rates, TTM[j]) is None:
                    if extrapolation_algorithm == "Linear":
                        extrapolated_value = linearexterp(tenor, rates, TTM[j])
                    else:
                        extrapolated_value = flatexterp(tenor, rates, TTM[j])
                    zero_rates = np.append(zero_rates, extrapolated_value)
                else:
                    interpolated_value = linearinterp(tenor, rates, TTM[j])
                    zero_rates = np.append(zero_rates, interpolated_value)
        PV = fixed_income_valuation_VAR(TTM, Total_Amount, zero_rates)
    elif model_code == "M005":
        tenor = np.array(zero_rates["tenor"], dtype="float64")
        rates = np.array(zero_rates[simulation], dtype="float64")
        zero_rates = np.empty([0], dtype="float64")
        TTM_array = np.array(cashflow_data_position["time_to_maturity"], dtype="float64")
        Redemption_Amount = np.array(position_data["redemption_amount"], dtype="float64")
        credit_spread_rate = np.array(position_data["credit_spread_rate"])
        Credit_Spread_Curve = np.array(position_data["credit_spread_curve"])
        for j in range(len(TTM_array)):
            if interpolation_algorithm == "Linear":
                if linearinterp(tenor, rates, TTM_array[j]) is None:
                    if extrapolation_algorithm == "Linear":
                        extrapolated_value = linearexterp(tenor, rates, TTM_array[j])
                    else:
                        extrapolated_value = flatexterp(tenor, rates, TTM_array[j])
                    zero_rates = np.append(zero_rates, extrapolated_value)
                else:
                    interpolated_value = linearinterp(tenor, rates, TTM_array[j])
                    zero_rates = np.append(zero_rates, interpolated_value)
        if str(credit_spread_rate) not in ["nan", "None"]:
            all_in_rate = float(zero_rates[0]) + float(credit_spread_rate[0])
        elif str(Credit_Spread_Curve[0]) not in ["nan", "None"]:
            spread_rate_curve = Credit_Spread_Curve[0]
            credit_spread_curve_data = credit_spread_data.loc[
                (credit_spread_data["credit_spread_curve_name"] == spread_rate_curve), :
            ]
            credit_spread_curve_data["interpolation_algorithm"].iloc[0]
            cs_extrapolation_algorithm = credit_spread_curve_data["extrapolation_algorithm"].iloc[0]
            if len(credit_spread_curve_data) > 0:
                spread_tenor = np.array(credit_spread_curve_data.tenor.tolist())
                spread_tenor_unit = np.array(credit_spread_curve_data.tenor_unit.tolist())
                tenor_extrac = np.vectorize(tenor_extraction)
                spread_tenor = tenor_extrac(spread_tenor, spread_tenor_unit)
                spread_rates = np.array(credit_spread_curve_data.spread_value.tolist())
                credit_spread_rates = np.empty([0], dtype="float64")
                for j in range(len(TTM_array)):
                    if linearinterp(spread_tenor, spread_rates, TTM_array[j]) is None:
                        if cs_extrapolation_algorithm == "Linear":
                            calculated_value = linearexterp(spread_tenor, spread_rates, TTM_array[j])
                        else:
                            calculated_value = flatexterp(spread_tenor, spread_rates, TTM_array[j])
                    else:
                        calculated_value = linearinterp(spread_tenor, spread_rates, TTM_array[j])
                    credit_spread_rates = np.append(credit_spread_rates, calculated_value)
                all_in_rate = zero_rates + credit_spread_rates
        PV, TTM_array, df, PV_plus_1bps, PV_minus_1bps = commercial_paper_valuation(
            TTM_array, Redemption_Amount, all_in_rate
        )
    elif model_code == "M006":
        TTM = np.array(cashflow_data_position["time_to_maturity"], dtype="float64")
        Total_Amount = np.array(cashflow_data_position["cashflow"], dtype="float64")
        tenor = np.array(zero_rates["tenor"], dtype="float64")
        rates = np.array(zero_rates[simulation], dtype="float64")
        zero_rates = np.empty([0], dtype="float64")
        credit_spread_rate = np.array(position_data["credit_spread_rate"])
        Credit_Spread_Curve = np.array(position_data["credit_spread_curve"])
        for j in range(len(TTM)):
            if interpolation_algorithm == "Linear":
                if linearinterp(tenor, rates, TTM[j]) is None:
                    if extrapolation_algorithm == "Linear":
                        extrapolated_value = linearexterp(tenor, rates, TTM[j])
                    else:
                        extrapolated_value = flatexterp(tenor, rates, TTM[j])
                    zero_rates = np.append(zero_rates, extrapolated_value)
                else:
                    interpolated_value = linearinterp(tenor, rates, TTM[j])
                    zero_rates = np.append(zero_rates, interpolated_value)
        # Add Credit Spread Rate to zero_rates
        if str(credit_spread_rate[0]) not in ["nan", "None"]:
            zero_rates = zero_rates + float(credit_spread_rate[0])
        elif str(Credit_Spread_Curve[0]) not in ["nan", "None"]:
            spread_rate_curve = Credit_Spread_Curve[0]
            credit_spread_curve_data = credit_spread_data.loc[
                (credit_spread_data["credit_spread_curve_name"] == spread_rate_curve), :
            ]
            if len(credit_spread_curve_data) > 0:
                spread_tenor = np.array(credit_spread_curve_data.tenor.tolist())
                spread_tenor_unit = np.array(credit_spread_curve_data.tenor_unit.tolist())
                credit_spread_curve_data["interpolation_algorithm"].iloc[0]
                cs_extrapolation_algorithm = credit_spread_curve_data["extrapolation_algorithm"].iloc[0]
                tenor_extrac = np.vectorize(tenor_extraction)
                spread_tenor = tenor_extrac(spread_tenor, spread_tenor_unit)
                spread_rates = np.array(credit_spread_curve_data.spread_value.tolist())
                credit_spread_rates = np.empty([0], dtype="float64")

                for j in range(len(TTM)):
                    if linearinterp(spread_tenor, spread_rates, TTM[j]) is None:
                        if cs_extrapolation_algorithm == "Linear":
                            extrapolated_value = linearexterp(spread_tenor, spread_rates, TTM[j])
                        else:
                            extrapolated_value = flatexterp(spread_tenor, spread_rates, TTM[j])
                        credit_spread_rates = np.append(credit_spread_rates, extrapolated_value)
                    else:
                        interpolated_value = linearinterp(spread_tenor, spread_rates, TTM[j])
                        credit_spread_rates = np.append(credit_spread_rates, interpolated_value)

                zero_rates = zero_rates + credit_spread_rates
        PV = fixed_income_valuation_VAR(TTM, Total_Amount, zero_rates)
    return PV


# gives the pnl for the ith asset (equity, or bond like) (output: 1d list with each row as the pnl of a scenario)
def fastfillcol(
    position_data, hist, all_pnl, s, i, b_scen_transposed, cashflow_data, credit_spread_data, fastfillrow
):
    # for equity like assets
    if position_data.asset_class[np.where(position_data.position_id == i)[0][0]] in [
        "EQ",
        "MF",
        "INVITs",
        "RE",
    ]:
        # parallelising over each row (or historical date)
        t = Parallel(n_jobs=multiprocessing.cpu_count())(
            delayed(fastfillrow)(
                hist, position_data.unique_reference_id[np.where(position_data.position_id == i)[0][0]], j
            )
            for j in all_pnl.index
        )
        all_pnl[i] = t
        ar = np.array(all_pnl[i].fillna(method="bfill"))
        # in case an array is still fully nan, the pnl column gets dummy values for now
        all_pnl_figures, returns = eqpnl(ar)
        all_pnl[i] = all_pnl_figures * position_data.quantity[np.where(position_data.position_id == i)[0][0]]
    else:
        # extracting valuation date bond price of bond like asset
        model_code = position_data.loc[position_data["position_id"] == i, ["model_code"]].iloc[0]
        cashflow_data_position = cashflow_data.loc[cashflow_data["position_id"] == i]
        price = Parallel(n_jobs=multiprocessing.cpu_count())(
            delayed(bond_revaluation)(
                position_data.loc[position_data["position_id"] == i],
                cashflow_data_position,
                np.array(model_code),
                b_scen_transposed.loc[:, ["benchmark", j, "tenor"]],
                credit_spread_data,
            )
            for j in range(0, s)
        )
        pnl = np.zeros(len(price))
        for m in range(1, len(price)):
            pnl[m] = price[m] - price[0]
        # getting pnl for that asset
        all_pnl[i] = pnl
        returns = []
    return list(all_pnl[i]), returns


# gives the final dataframe containing pnls of all assets (output: Dataframe with assets as columns and scenarios as rows)
def ppnl(
    all_pnl,
    position_data,
    hist,
    s,
    b_scen_transposed,
    cashflow_data,
    credit_spread_data,
    fastfillcol,
    fastfillrow,
):
    # parallelising over each asset
    pnl, returns = zip(
        *Parallel(n_jobs=multiprocessing.cpu_count())(
            delayed(fastfillcol)(
                position_data,
                hist,
                all_pnl,
                s,
                i,
                b_scen_transposed,
                cashflow_data,
                credit_spread_data,
                fastfillrow,
            )
            for i in all_pnl.columns
        )
    )
    returns = pd.DataFrame(list(returns), columns=all_pnl.index, index=all_pnl.columns).T
    new = pd.DataFrame(np.array(pnl).T, columns=all_pnl.columns, index=all_pnl.index)
    return new, returns


@njit(cache=True, fastmath=True)
def VAR(
    final_output,
    config_dict,
    position_data,
    cashflow_data,
    measures,
    hist,
    ir_curve_components_data,
    cs_curve_repo_data,
    cs_curve_components_data,
    val_date,
):
    methodology = config_dict["inputs"]["VAR Methodology"]
    if methodology == "Historical Simulation":
        diversification = config_dict["inputs"]["Diversified"]
        if "Diversified" in diversification:
            diver = "Yes"
        else:
            diver = "No"
        if "Undiversified" in diversification:
            undiver = "Yes"
        else:
            undiver = "No"
        curve_component_transformation_vect = np.vectorize(curve_component_transformation)
        hist_filtered = hist.loc[hist["extract_date"] == pd.to_datetime(val_date, dayfirst=True)]
        cs_curve_component_transformation_result = curve_component_transformation_vect(
            cs_curve_repo_data.to_dict("records")
        )
        cs_curve_data = pd.concat(cs_curve_component_transformation_result, ignore_index=True)
        del cs_curve_component_transformation_result
        cs_curve_data = cs_curve_data.merge(
            cs_curve_components_data, left_on="curve_components", right_on="id", how="left"
        ).drop(columns=["curve_components", "id"])
        cs_curve_data["tenor"] = np.where(
            cs_curve_data["tenor_unit"] == "D",
            cs_curve_data["tenor_value"] / 365.25,
            np.where(
                cs_curve_data["tenor_unit"] == "M",
                cs_curve_data["tenor_value"] / 12,
                cs_curve_data["tenor_value"],
            ),
        )
        credit_spread_data = (
            cs_curve_data.merge(
                hist_filtered.loc[:, ["security_identifier", "quoted_price"]],
                left_on="curve_component",
                right_on="security_identifier",
                how="left",
            )
            .drop(columns=["security_identifier"])
            .rename(columns={"quoted_price": "spread_value", "curve_name": "credit_spread_curve_name"})
        )
        del cs_curve_data
        credit_spread_data.sort_values(by=["credit_spread_curve_name", "tenor"], inplace=True)
        credit_spread_data = credit_spread_data.drop(columns=["tenor"]).rename(
            columns={"tenor_value": "tenor"}
        )
        lp = int(config_dict["inputs"]["Lookback_Period"])
        hp = float(config_dict["inputs"]["Holding_Period"])
        p = float(config_dict["inputs"]["Percentile"])
        # extracting historical data for the lookback period starting from the valuation date
        hist = hist[
            (hist.extract_date <= pd.to_datetime(val_date, dayfirst=True))
            & (hist.extract_date >= pd.to_datetime(val_date, dayfirst=True) - timedelta(days=lp))
        ]
        # getting only GB and TB securities from the historical data
        bhist = hist[
            (hist.security_identifier.str.contains("FBIL_GSEC_GB", case=True))
            | (hist.security_identifier.str.contains("FBIL_TB", case=True))
            | (hist.security_identifier.str.contains("FBIL_GSEC_O/N", case=True))
        ]
        bhist = bhist[bhist.security_identifier != "FBIL_TB_12M"]
        bhist.fillna(0, inplace=True)
        # initializing empty dataframe for historical term structures
        ts = pd.DataFrame(
            columns=sorted(bhist.security_identifier.unique()), index=bhist.extract_date.unique()
        )
        # inserting the yield for each tenor point into ts according to date
        for d in bhist.extract_date.unique():
            t = bhist[bhist.extract_date == d]
            for j in t.index:
                ts[t.security_identifier[j]][t.extract_date[j]] = t["yield"][j]
        # getting the scenarios dataframe for all bond like assets
        b_scen, b_returns = bondvar(ts, boot, ts.columns, [i for i in range(len(ts.index))])
        b_returns["Scenario"] = [i for i in range(len(b_returns.index))]
        hist.set_index("extract_date", inplace=True)
        # initializing all_pnl for all assets combined
        all_pnl = pd.DataFrame(columns=position_data.position_id.unique(), index=ts.index)
        b_scen_transposed = b_scen.T.reset_index().rename(columns={"index": "benchmark"})
        b_scen_transposed = pd.merge(
            b_scen_transposed,
            ir_curve_components_data,
            how="left",
            left_on="benchmark",
            right_on="curve_component",
        ).fillna(0)
        b_scen_transposed["tenor"] = np.where(
            b_scen_transposed["tenor_unit"] == "Y",
            b_scen_transposed["tenor_value"],
            np.where(
                b_scen_transposed["tenor_unit"] == "M",
                b_scen_transposed["tenor_value"] / 12,
                b_scen_transposed["tenor_value"] / 365.25,
            ),
        )
        b_scen_transposed = b_scen_transposed.sort_values(by=["tenor"], ascending=True)
        # all_pnl gets updated to a df with pnl values for each asset
        all_pnl, returns = ppnl(
            all_pnl,
            position_data,
            hist,
            b_scen.shape[0],
            b_scen_transposed,
            cashflow_data,
            credit_spread_data,
            fastfillcol,
            fastfillrow,
        )
        all_pnl["Scenario"] = [i for i in range(len(all_pnl.index))]
        pnl_final_output = pd.melt(
            all_pnl, id_vars=["Scenario"], value_vars=[i for i in all_pnl.columns[:-1]]
        ).rename(columns={"Scenario": "simulation", "variable": "position_id", "value": "pnl"})
        pnl_final_output["reporting_date"] = pd.to_datetime(val_date, dayfirst=True)
        pnl_final_output["run_date"] = datetime.now()
        pnl_final_output["pnl"] = pnl_final_output["pnl"].fillna(0)
        all_pnl.set_index("Scenario", inplace=True)
        returns["Scenario"] = [i for i in range(len(returns.index))]
        returns = returns.dropna(axis=1)
        b_returns = pd.melt(b_returns, id_vars=["Scenario"], value_vars=[i for i in b_returns.columns[:-1]])
        returns = pd.melt(returns, id_vars=["Scenario"], value_vars=[i for i in returns.columns[:-1]])
        ret_final_output = pd.concat([b_returns, returns], ignore_index=True).rename(
            columns={"Scenario": "simulation", "variable": "position_id", "value": "return"}
        )
        ret_final_output["reporting_date"] = pd.to_datetime(val_date, dayfirst=True)
        ret_final_output["run_date"] = datetime.now()
        # getting diversified and undiversified vars from all_pnl and appending it to positions data
        if diver == "Yes" and undiver == "Yes":
            final_output, measures = undiver_var(
                all_pnl.iloc[1:], p, hp, final_output, measures, position_data
            )
            final_output, measures_output, var_plot = diver_var(
                all_pnl.iloc[1:], p, hp, final_output, measures, position_data
            )
            return final_output, measures_output, var_plot, pnl_final_output, ret_final_output
        elif diver == "Yes" and undiver == "No":
            final_output, measures_output, var_plot = diver_var(
                all_pnl.iloc[1:], p, hp, final_output, measures, position_data
            )
            return final_output, measures_output, var_plot, pnl_final_output, ret_final_output
        else:
            var_plot = ""
            final_output, measures_output = (
                undiver_var(all_pnl.iloc[1:], p, hp, final_output, measures, position_data),
                var_plot,
            )
            return final_output, measures_output, var_plot, pnl_final_output, ret_final_output


################gen date function#################
def gen_date(date, num, unit):
    if unit == "Months":
        days = (date.astype("datetime64[D]") - date.astype("datetime64[M]")).astype(int)
        val_date = date.astype("datetime64[M]")
        date_new = np.datetime64(val_date) + np.timedelta64(num, "M")
        y = date_new + np.array(days, "timedelta64[D]")
        return y
    if unit == "Days":
        val_date = date
        y = date + np.timedelta64(num, "D")
        return y
    if unit == "Weeks":
        val_date = date
        num_1 = 7 * num
        y = np.datetime64(val_date) + np.timedelta64(num_1, "D")
        return y
    if unit == "Years":
        days = (date.astype("datetime64[D]") - date.astype("datetime64[M]")).astype(int)
        months = date.astype("datetime64[M]").astype(int) % 12
        val_date = date
        val_date = val_date.astype("datetime64[Y]")
        date_new = np.datetime64(val_date) + np.timedelta64(num, "Y")
        x = date_new + np.array(months, "timedelta64[M]")
        y = x + np.array(days, "timedelta64[D]")
        return y


def date_range_day(start, end, Period):
    """Date range day"""
    x = np.arange(
        np.datetime64(start),
        np.datetime64(end),
        np.timedelta64(Period, "D"),
        dtype="datetime64[D]",
    )
    return x


def NMD_percentage_calculation(NMD_Data, nmd_cashflow_frequency):
    """Wrapper function for Percentage"""
    start_date = pd.to_datetime(NMD_Data["reporting_date"].iloc[0], dayfirst=True)
    if nmd_cashflow_frequency == "Monthly":
        NMD_Data["start_tenor"] = np.where(
            NMD_Data["start_tenor_unit"].isin(["Year", "Years", "Y"]),
            NMD_Data["start_tenor"] * 12,
            np.where(
                NMD_Data["start_tenor_unit"].isin(["Days", "Day", "D"]),
                NMD_Data["start_tenor"] / 30,
                np.where(
                    NMD_Data["start_tenor_unit"].isin(["Weeks", "Week", "W"]),
                    NMD_Data["start_tenor"] / 4,
                    NMD_Data["start_tenor"],
                ),
            ),
        )
        NMD_Data["end_tenor"] = np.where(
            NMD_Data["end_tenor_unit"].isin(["Year", "Years", "Y"]),
            NMD_Data["end_tenor"] * 12,
            np.where(
                NMD_Data["end_tenor_unit"].isin(["Days", "Day", "D"]),
                NMD_Data["end_tenor"] / 30,
                np.where(
                    NMD_Data["end_tenor_unit"].isin(["Weeks", "Week", "W"]),
                    NMD_Data["end_tenor"] / 4,
                    NMD_Data["end_tenor"],
                ),
            ),
        )
        NMD_Data["start_tenor_unit"] = "Months"
        NMD_Data["end_tenor_unit"] = "Months"
        end_date = start_date + relativedelta(months=float(NMD_Data["end_tenor"].iloc[-1]))
        Ending_Date_array = valuation_models.month_range_day(start_date, end_date, 1)[1]
        period_difference_array = (
            Ending_Date_array.astype("datetime64[M]") - np.array(start_date).astype("datetime64[M]")
        ).astype("float")

    elif nmd_cashflow_frequency == "Daily":
        NMD_Data["start_tenor"] = np.where(
            NMD_Data["start_tenor_unit"].isin(["Year", "Years", "Y"]),
            NMD_Data["start_tenor"] * 365,
            np.where(
                NMD_Data["start_tenor_unit"].isin(["Months", "Month", "M"]),
                NMD_Data["start_tenor"] * 30,
                np.where(
                    NMD_Data["start_tenor_unit"].isin(["Weeks", "Week", "W"]),
                    NMD_Data["start_tenor"] * 7,
                    NMD_Data["start_tenor"],
                ),
            ),
        )
        NMD_Data["end_tenor"] = np.where(
            NMD_Data["end_tenor_unit"].isin(["Year", "Years", "Y"]),
            NMD_Data["end_tenor"] * 365,
            np.where(
                NMD_Data["end_tenor_unit"].isin(["Months", "Month", "M"]),
                NMD_Data["end_tenor"] * 30,
                np.where(
                    NMD_Data["end_tenor_unit"].isin(["Weeks", "Week", "W"]),
                    NMD_Data["end_tenor"] * 7,
                    NMD_Data["end_tenor"],
                ),
            ),
        )
        NMD_Data["start_tenor_unit"] = "Days"
        NMD_Data["end_tenor_unit"] = "Days"
        end_date = start_date + relativedelta(days=float(NMD_Data["end_tenor"].iloc[-1]))
        Ending_Date_array = date_range_day(
            start_date + relativedelta(days=1), end_date + relativedelta(days=1), 1
        )
        period_difference_array = (
            Ending_Date_array.astype("datetime64[D]") - np.array(start_date).astype("datetime64[D]")
        ).astype("float")

    else:
        NMD_Data["start_tenor"] = np.where(
            NMD_Data["start_tenor_unit"].isin(["Months", "Month", "M"]),
            NMD_Data["start_tenor"] / 12,
            np.where(
                NMD_Data["start_tenor_unit"].isin(["Days", "Day", "D"]),
                NMD_Data["start_tenor"] / 365,
                np.where(
                    NMD_Data["start_tenor_unit"].isin(["Weeks", "Week", "W"]),
                    NMD_Data["start_tenor"] / 52,
                    NMD_Data["start_tenor"],
                ),
            ),
        )
        NMD_Data["end_tenor"] = np.where(
            NMD_Data["end_tenor_unit"].isin(["Months", "Month", "M"]),
            NMD_Data["end_tenor"] / 12,
            np.where(
                NMD_Data["end_tenor_unit"].isin(["Days", "Day", "D"]),
                NMD_Data["end_tenor"] / 365,
                np.where(
                    NMD_Data["end_tenor_unit"].isin(["Weeks", "Week", "W"]),
                    NMD_Data["end_tenor"] / 52,
                    NMD_Data["end_tenor"],
                ),
            ),
        )
        NMD_Data["start_tenor_unit"] = "Years"
        NMD_Data["end_tenor_unit"] = "Years"
        end_date = start_date + relativedelta(years=float(NMD_Data["end_tenor"].iloc[-1]))
        Ending_Date_array = valuation_models.month_range_day(start_date, end_date, 12)[1]
        period_difference_array = (
            Ending_Date_array.astype("datetime64[Y]") - np.array(start_date).astype("datetime64[Y]")
        ).astype("float64")

    Percentage_Calc_arr = np.empty([0], dtype="float64")
    for i in range(len(period_difference_array)):
        percentage_group = NMD_Data.loc[
            (NMD_Data["start_tenor"] < period_difference_array[i])
            & (NMD_Data["end_tenor"] >= period_difference_array[i])
        ]
        percentage = percentage_group["percentage"].iloc[0] / (
            percentage_group["end_tenor"].iloc[0] - percentage_group["start_tenor"].iloc[0]
        )
        Percentage_Calc_arr = np.append(Percentage_Calc_arr, percentage)

    column_names = ["Date", "Percentage"]
    result_array = np.array([Ending_Date_array, Percentage_Calc_arr])
    df = pd.DataFrame(data=result_array, index=column_names)
    return df


def NMD_Cashflow(
    fund,
    Portfolio,
    issue_date,
    Position_ID,
    last_payment_date,
    payment_frequency,
    payment_frequency_unit,
    interest_rate,
    Outstanding_Amount,
    Discounting_Curve,
    Currency,
    Date,
    Percentage,
    product_variant_name,
    Val_Date,
    entity,
    asset_liability_type,
    accrued_interest,
    holiday_calendar,
    business_day_convention,
    discount_daycount,
    custom_daycount_conventions,
    nmd_cashflow_frequency,
    accrual_convention_code,
    stub_date=None,
    business_days="1111100",
):
    """NMD Cashflow Generation"""
    Cashflow_Date = np.array(Date)
    Interest_Paid_array = np.empty([0], dtype="float64")
    Principal_Paid_array = np.empty([0], dtype="float64")

    if str(payment_frequency) in ["nan", "None", "-",""]:
        payment_frequency = None
    if str(payment_frequency_unit) in ["nan", "None", "-",""]:
        payment_frequency_unit = None

    if payment_frequency and payment_frequency_unit:
        coupon_frequency = valuation_models.coupon_Frequency(payment_frequency, payment_frequency_unit)
        if str(last_payment_date) in ["None", "NaT", "-", "nan"]:
            if str(stub_date) in ["None", "NaT", "-", "nan"]:
                Begining_Date_array, Ending_Date_array = valuation_models.month_range_day(
                    issue_date, pd.to_datetime(Cashflow_Date[-1], dayfirst=True), int(12 / coupon_frequency)
                )
            else:
                Begining_Date_array_0 = np.array([issue_date], dtype="datetime64[D]")
                Ending_Date_array_0 = np.array([stub_date], dtype="datetime64[D]")
                Begining_Date_array, Ending_Date_array = valuation_models.month_range_day(
                    stub_date,
                    pd.to_datetime(Cashflow_Date[-1], dayfirst=True),
                    int(12 / coupon_frequency),
                )
                Begining_Date_array = np.concatenate((Begining_Date_array_0, Begining_Date_array))
                Ending_Date_array = np.concatenate((Ending_Date_array_0, Ending_Date_array))

        else:
            Begining_Date_array, Ending_Date_array = valuation_models.month_range_day(
                last_payment_date,
                pd.to_datetime(Cashflow_Date[-1], dayfirst=True),
                int(12 / coupon_frequency),
            )
        interest_date_array = np.empty([0], dtype="datetime64[D]")
        interest_beginning_array = np.empty([0], dtype="datetime64[D]")

        convention_code = valuation_models.busday_convention_code(business_day_convention)
        del_index = []
        if convention_code == "EOM":
            interest_date_array = conventions.eomonth(
                Ending_Date_array, np.datetime64(Cashflow_Date[-1], "D")
            )
            interest_date_array = np.unique(interest_date_array[interest_date_array > Val_Date])
            interest_beginning_array = conventions.eomonth(
                Begining_Date_array, np.datetime64(Cashflow_Date[-1], "D")
            )
        else:
            for i in range(Ending_Date_array.size):
                if Ending_Date_array[i] > Val_Date:
                    interest_date_array = np.append(
                        interest_date_array,
                        conventions.business_day(
                            Ending_Date_array[i],
                            convention_code,
                            holiday_calendar,
                            business_days=business_days,
                        ),
                    )
                    interest_beginning_array = np.append(
                        interest_beginning_array,
                        conventions.business_day(
                            Begining_Date_array[i],
                            convention_code,
                            holiday_calendar,
                            business_days=business_days,
                        ),
                    )
                else:
                    del_index.append(i)
        for d_i in sorted(del_index, reverse=True):
            Begining_Date_array = np.delete(Begining_Date_array, d_i)
            Ending_Date_array = np.delete(Ending_Date_array, d_i)
    else:
        interest_date_array = np.empty([0], dtype="datetime64[D]")
        interest_beginning_array = np.empty([0], dtype="datetime64[D]")

    Principal_Paid_array = Outstanding_Amount * Percentage / 100
    Cashflow_array = Principal_Paid_array
    interest_paid_array = np.empty([0], dtype="float")

    if payment_frequency and payment_frequency_unit:
        repayment_dates = Cashflow_Date
        principal_outstanding_start = np.empty([0], dtype="float64")
        principal_outstanding_end = np.empty([0], dtype="float64")
        for i in range(0, len(repayment_dates)):
            principal_outstanding_start = np.append(principal_outstanding_start, Outstanding_Amount)
            Outstanding_Amount = Outstanding_Amount - Principal_Paid_array[i]
            principal_outstanding_end = np.append(principal_outstanding_end, Outstanding_Amount)
        Interests = np.empty([0], dtype="float64")

        for j in range(0, len(interest_date_array)):
            repayment_dates_end = repayment_dates[
                np.where(
                    (repayment_dates > interest_beginning_array[j])
                    & (repayment_dates <= interest_date_array[j])
                )
            ]
            if j == 0:
                total_interest = accrued_interest
            else:
                total_interest = 0
            if repayment_dates_end.size > 0:
                for k in range(repayment_dates_end.size):
                    outstanding_amount_period_start = principal_outstanding_start[
                        np.where(repayment_dates == repayment_dates_end[k])
                    ]
                    outstanding_amount_period_end = principal_outstanding_end[
                        np.where(repayment_dates == repayment_dates_end[k])
                    ]
                    if k == 0:
                        if j == 0:
                            if repayment_dates_end[k] == interest_date_array[j]:
                                year_frac = conventions.A_day_count(
                                    Val_Date,
                                    interest_date_array[j],
                                    accrual_convention_code,
                                    custom_daycount_conventions=custom_daycount_conventions,
                                )
                            else:
                                year_frac = conventions.A_day_count(
                                    Val_Date,
                                    repayment_dates_end[k],
                                    accrual_convention_code,
                                    custom_daycount_conventions=custom_daycount_conventions,
                                )
                        else:
                            if repayment_dates_end[k] == interest_date_array[j]:
                                year_frac = conventions.A_day_count(
                                    interest_beginning_array[j],
                                    interest_date_array[j],
                                    accrual_convention_code,
                                    custom_daycount_conventions=custom_daycount_conventions,
                                )
                            else:
                                year_frac = conventions.A_day_count(
                                    interest_beginning_array[j],
                                    repayment_dates_end[k],
                                    accrual_convention_code,
                                    custom_daycount_conventions=custom_daycount_conventions,
                                )
                    else:
                        year_frac = conventions.A_day_count(
                            repayment_dates_end[k - 1],
                            repayment_dates_end[k],
                            accrual_convention_code,
                            custom_daycount_conventions=custom_daycount_conventions,
                        )
                    total_interest += interest_rate * year_frac * outstanding_amount_period_start
                if repayment_dates_end[-1] != interest_date_array[j]:
                    outstanding_amount_period_start = principal_outstanding_end[
                        np.where(repayment_dates == repayment_dates_end[-1])
                    ]
                    year_frac = conventions.A_day_count(
                        repayment_dates_end[-1],
                        interest_date_array[j],
                        accrual_convention_code,
                        custom_daycount_conventions=custom_daycount_conventions,
                    )
                    total_interest += interest_rate * year_frac * outstanding_amount_period_start
            else:
                principal_index = np.where(repayment_dates < interest_date_array[j])[0]
                if len(principal_index) == 0:
                    outstanding_amount_period_start = principal_outstanding_start[0]
                else:
                    outstanding_amount_period_start = principal_outstanding_end[principal_index[-1]]

                if j == 0:
                    year_frac = conventions.A_day_count(
                        Val_Date,
                        interest_date_array[j],
                        accrual_convention_code,
                        custom_daycount_conventions=custom_daycount_conventions,
                    )
                else:
                    year_frac = conventions.A_day_count(
                        interest_beginning_array[j],
                        interest_date_array[j],
                        accrual_convention_code,
                        custom_daycount_conventions=custom_daycount_conventions,
                    )
                total_interest += interest_rate * year_frac * outstanding_amount_period_start
            Interests = np.append(Interests, total_interest)
        Cashflow_Date = np.append(Cashflow_Date, interest_date_array)
        Cashflow_array = np.append(Cashflow_array, Interests)
        interest_check = np.in1d(Cashflow_array, Interests)
        if asset_liability_type == "Asset":
            cashflow_type_arr = np.where(interest_check, "Interest Proceeds", "Inflows")
        else:
            cashflow_type_arr = np.where(interest_check, "Interest Paid", "Withdrawals")
    else:
        if asset_liability_type == "Asset":
            cashflow_type_arr = np.repeat("Inflows", (Cashflow_Date.size))
        else:
            cashflow_type_arr = np.repeat("Withdrawals", (Cashflow_Date.size))

    sizes = Cashflow_Date.size
    Val_array = np.repeat(Val_Date, sizes)
    discount_convention_code = valuation_models.daycount_convention_code(discount_daycount)
    TTM_array = conventions.D_day_count(
        Val_array,
        Cashflow_Date,
        discount_convention_code,
        custom_daycount_conventions=custom_daycount_conventions,
    )
    size_diff = Cashflow_array.size - Principal_Paid_array.size
    arr = np.repeat(0, size_diff)
    Interest_Paid_arr = np.repeat(0, sizes)
    Principal_Paid_array = np.append(Principal_Paid_array, arr)
    result_array = np.array(
        [
            Cashflow_Date,
            cashflow_type_arr,
            Cashflow_array,
            TTM_array,
            Interest_Paid_arr,
            Principal_Paid_array,
        ]
    )
    return result_array


def repayment_loans(
    unique_reference_id,
    issue_date,
    last_payment_date,
    last_principal_payment_date,
    maturity_date,
    base_rate,
    fixed_spread,
    payment_frequency,
    payment_frequency_unit,
    principal_payment_frequency,
    principal_payment_frequency_unit,
    outstanding_amount,
    convention_code,
    valuation_date,
    principal_payment_amount,
    custom_schedule_id,
    repayment_schedule_position,
    holiday_calendar,
    accrual_convention_code,
    discount_daycount_convention_code,
    accrued_interest,
    custom_daycount_conventions,
    stub_date=None,
    principal_stub_date=None,
    business_days="1111100",
    moratorium_end_date="",
    moratorium_flag="N",
    interest_moratorium_flag="N",
):
    if str(payment_frequency) in ["nan", "None", "-"]:
        payment_frequency = None
    if str(payment_frequency_unit) in ["nan", "None", "-"]:
        payment_frequency_unit = None

    if payment_frequency and payment_frequency_unit:
        interest_frequency = valuation_models.coupon_Frequency(payment_frequency, payment_frequency_unit)
        if str(last_payment_date) in ["None", "NaT", "-", "nan"]:
            if str(stub_date) in ["None", "NaT", "-", "nan"]:
                Begining_Date_array, Ending_Date_array = valuation_models.month_range_day(
                    issue_date[0], maturity_date[0], int(12 / interest_frequency)
                )
            else:
                Begining_Date_array_0 = np.array(issue_date, dtype="datetime64[D]")
                Ending_Date_array_0 = np.array([stub_date], dtype="datetime64[D]")
                Begining_Date_array, Ending_Date_array = valuation_models.month_range_day(
                    stub_date,
                    maturity_date[0],
                    int(12 / interest_frequency),
                )
                Begining_Date_array = np.concatenate((Begining_Date_array_0, Begining_Date_array))
                Ending_Date_array = np.concatenate((Ending_Date_array_0, Ending_Date_array))

        else:
            Begining_Date_array, Ending_Date_array = valuation_models.month_range_day(
                last_payment_date, maturity_date[0], int(12 / interest_frequency)
            )
    else:
        Begining_Date_array = np.array([issue_date], dtype="datetime64[D]")
        Ending_Date_array = np.array(maturity_date, dtype="datetime64[D]")

    interest_rate = base_rate + fixed_spread
    Cashflow_Date_array = np.empty([0], dtype="datetime64[D]")
    convention_code = valuation_models.busday_convention_code(convention_code)
    Maturity_Date = np.array(
        [business_day_val(maturity_date[0].date(), convention_code, [])], dtype="datetime64[D]"
    )
    del_index = []

    if convention_code == "EOM":
        Cashflow_Date_array = conventions.eomonth(Ending_Date_array, Maturity_Date[0])
        del_index = np.where(Cashflow_Date_array <= valuation_date)
        Cashflow_Date_array = np.unique(Cashflow_Date_array[Cashflow_Date_array > valuation_date])
        Begining_Date_array = np.delete(Begining_Date_array, del_index)
    else:
        for i in range(Ending_Date_array.size):
            if Ending_Date_array[i] > valuation_date:
                Cashflow_Date_array = np.append(
                    Cashflow_Date_array,
                    conventions.business_day(
                        Ending_Date_array[i], convention_code, holiday_calendar, business_days=business_days
                    ),
                )
            else:
                del_index.append(i)
    for d_i in sorted(del_index, reverse=True):
        Begining_Date_array = np.delete(Begining_Date_array, d_i)
        Ending_Date_array = np.delete(Ending_Date_array, d_i)

    if interest_moratorium_flag == "Y":
        Cashflow_Date_array = Cashflow_Date_array[Cashflow_Date_array > moratorium_end_date]
        if str(last_payment_date) in ["None", "NaT", "-", "nan"]:
            Begining_Date_array = np.unique(np.append(Begining_Date_array, moratorium_end_date))
        Begining_Date_array = Begining_Date_array[Begining_Date_array >= moratorium_end_date]

    if custom_schedule_id == "Y":
        repayment_dates = repayment_schedule_position["payment_date"].to_numpy(dtype="datetime64[D]")
        repayment_amounts = repayment_schedule_position["payment_amount"].to_numpy(dtype="float64")
    else:
        repayment_frequency = valuation_models.coupon_Frequency(
            principal_payment_frequency, principal_payment_frequency_unit
        )
        if str(last_principal_payment_date) in ["None", "NaT", "-", "nan"]:
            if str(principal_stub_date) in ["None", "NaT", "-", "nan"]:
                repayment_start_dates, repayment_end_dates = valuation_models.month_range_day(
                    issue_date[0], maturity_date[0], int(12 / repayment_frequency)
                )
            else:
                repayment_start_dates_0 = np.array(issue_date, dtype="datetime64[D]")
                repayment_end_dates_0 = np.array([principal_stub_date], dtype="datetime64[D]")
                repayment_start_dates, repayment_end_dates = valuation_models.month_range_day(
                    principal_stub_date,
                    maturity_date[0],
                    int(12 / repayment_frequency),
                )
                repayment_start_dates = np.concatenate((repayment_start_dates_0, repayment_start_dates))
                repayment_end_dates = np.concatenate((repayment_end_dates_0, repayment_end_dates))

        else:
            repayment_start_dates, repayment_end_dates = valuation_models.month_range_day(
                last_principal_payment_date, maturity_date[0], int(12 / repayment_frequency)
            )

        repayment_dates = np.empty([0], dtype="datetime64[D]")
        del_index = []
        if convention_code == "EOM":
            repayment_dates = conventions.eomonth(repayment_end_dates, maturity_date[0])
            del_index = np.where(repayment_dates <= valuation_date)
            repayment_dates = np.unique(repayment_dates[repayment_dates > valuation_date])
            repayment_start_dates = np.delete(repayment_start_dates, del_index)
        else:
            for i in range(repayment_end_dates.size):
                if repayment_end_dates[i] > valuation_date:
                    repayment_dates = np.append(
                        repayment_dates,
                        conventions.business_day(
                            repayment_end_dates[i],
                            convention_code,
                            holiday_calendar,
                            business_days=business_days,
                        ),
                    )
                else:
                    del_index.append(i)
        for d_i in sorted(del_index, reverse=True):
            repayment_start_dates = np.delete(repayment_start_dates, d_i)
            repayment_end_dates = np.delete(repayment_end_dates, d_i)
        repayment_amounts = np.repeat(principal_payment_amount, len(repayment_dates))

    principal_outstanding_start = np.empty([0], dtype="float64")
    principal_outstanding_end = np.empty([0], dtype="float64")
    for i in range(0, len(repayment_dates)):
        principal_outstanding_start = np.append(principal_outstanding_start, outstanding_amount)
        if i == len(repayment_dates) - 1:
            repayment_amounts[i] = outstanding_amount
        outstanding_amount = outstanding_amount - repayment_amounts[i]
        principal_outstanding_end = np.append(principal_outstanding_end, outstanding_amount)

    Interests = np.empty([0], dtype="float64")

    for j in range(0, len(Cashflow_Date_array)):
        repayment_dates_end = repayment_dates[
            np.where((repayment_dates > Begining_Date_array[j]) & (repayment_dates <= Cashflow_Date_array[j]))
        ]
        if j == 0:
            total_interest = accrued_interest
        else:
            total_interest = 0

        if repayment_dates_end.size > 0:
            for k in range(repayment_dates_end.size):
                outstanding_amount_period_start = principal_outstanding_start[
                    np.where(repayment_dates == repayment_dates_end[k])
                ]
                outstanding_amount_period_end = principal_outstanding_end[
                    np.where(repayment_dates == repayment_dates_end[k])
                ]
                if k == 0:
                    if j == 0:
                        if repayment_dates_end[k] == Cashflow_Date_array[j]:
                            if accrued_interest == 0:
                                year_frac = conventions.A_day_count(
                                    Begining_Date_array[j],
                                    Cashflow_Date_array[j],
                                    accrual_convention_code,
                                    custom_daycount_conventions=custom_daycount_conventions,
                                )
                            else:
                                year_frac = conventions.A_day_count(
                                    valuation_date,
                                    Cashflow_Date_array[j],
                                    accrual_convention_code,
                                    custom_daycount_conventions=custom_daycount_conventions,
                                )
                        else:
                            if accrued_interest == 0:
                                year_frac = conventions.A_day_count(
                                    Begining_Date_array[j],
                                    repayment_dates_end[k],
                                    accrual_convention_code,
                                    custom_daycount_conventions=custom_daycount_conventions,
                                )
                            else:
                                year_frac = conventions.A_day_count(
                                    valuation_date,
                                    repayment_dates_end[k],
                                    accrual_convention_code,
                                    custom_daycount_conventions=custom_daycount_conventions,
                                )
                    else:
                        if repayment_dates_end[k] == Cashflow_Date_array[j]:
                            year_frac = conventions.A_day_count(
                                Begining_Date_array[j],
                                Cashflow_Date_array[j],
                                accrual_convention_code,
                                custom_daycount_conventions=custom_daycount_conventions,
                            )
                        else:
                            year_frac = conventions.A_day_count(
                                Begining_Date_array[j],
                                repayment_dates_end[k],
                                accrual_convention_code,
                                custom_daycount_conventions=custom_daycount_conventions,
                            )
                else:
                    year_frac = conventions.A_day_count(
                        repayment_dates_end[k - 1],
                        repayment_dates_end[k],
                        accrual_convention_code,
                        custom_daycount_conventions=custom_daycount_conventions,
                    )
                total_interest += interest_rate * year_frac * outstanding_amount_period_start
            if repayment_dates_end[-1] != Cashflow_Date_array[j]:
                outstanding_amount_period_start = principal_outstanding_end[
                    np.where(repayment_dates == repayment_dates_end[-1])
                ]
                outstanding_amount_period_end = outstanding_amount_period_start

                year_frac = conventions.A_day_count(
                    repayment_dates_end[-1],
                    Cashflow_Date_array[j],
                    accrual_convention_code,
                    custom_daycount_conventions=custom_daycount_conventions,
                )
                total_interest += interest_rate * year_frac * outstanding_amount_period_start
        else:
            principal_index = np.where(repayment_dates < Cashflow_Date_array[j])[0]
            if len(principal_index) == 0:
                outstanding_amount_period_start = principal_outstanding_start[0]
                outstanding_amount_period_end = outstanding_amount_period_start
            else:
                outstanding_amount_period_start = principal_outstanding_end[principal_index[-1]]
                outstanding_amount_period_end = outstanding_amount_period_end

            if j == 0:
                if accrued_interest == 0:
                    year_frac = conventions.A_day_count(
                        Begining_Date_array[j],
                        Cashflow_Date_array[j],
                        accrual_convention_code,
                        custom_daycount_conventions=custom_daycount_conventions,
                    )
                else:
                    year_frac = conventions.A_day_count(
                        valuation_date,
                        Cashflow_Date_array[j],
                        accrual_convention_code,
                        custom_daycount_conventions=custom_daycount_conventions,
                    )
            else:
                year_frac = conventions.A_day_count(
                    Begining_Date_array[j],
                    Cashflow_Date_array[j],
                    accrual_convention_code,
                    custom_daycount_conventions=custom_daycount_conventions,
                )
            total_interest += interest_rate * year_frac * outstanding_amount_period_start

        Interests = np.append(Interests, total_interest)

    cashflow_type_array_interest = np.repeat("Interest Proceeds", len(Interests))
    cashflow_type_array_principal = np.repeat("Principal Amount", len(repayment_amounts))

    cashflows = list(Interests) + list(repayment_amounts)

    cashflow_type_array = list(cashflow_type_array_interest) + list(cashflow_type_array_principal)

    TTM_array_interest = conventions.D_day_count(
        valuation_date,
        Cashflow_Date_array,
        discount_daycount_convention_code,
        custom_daycount_conventions=custom_daycount_conventions,
    )
    TTM_array_principal = conventions.D_day_count(
        valuation_date,
        repayment_dates,
        discount_daycount_convention_code,
        custom_daycount_conventions=custom_daycount_conventions,
    )

    TTM_array = list(TTM_array_interest) + list(TTM_array_principal)
    cashflow_date_array = list(Cashflow_Date_array) + list(repayment_dates)
    principal_outstanding_beginning = list(np.repeat(0, len(Interests))) + list(principal_outstanding_start)
    principal_outstanding_ending = list(np.repeat(0, len(Interests))) + list(principal_outstanding_end)
    result_array = [
        cashflow_date_array,
        TTM_array,
        cashflows,
        cashflow_type_array,
        principal_outstanding_beginning,
        principal_outstanding_ending,
    ]
    return result_array


def recurring_deposits(
    unique_reference_id,
    issue_date,
    last_payment_date,
    last_deposit_date,
    maturity_date,
    base_rate,
    fixed_spread,
    payment_frequency,
    payment_frequency_unit,
    deposit_frequency,
    deposit_frequency_unit,
    outstanding_amount,
    convention_code,
    valuation_date,
    deposit_amount,
    holiday_calendar,
    accrual_convention_code,
    discount_daycount_convention_code,
    accrued_interest,
    custom_daycount_conventions,
    stub_date=None,
    principal_stub_date=None,
    business_days="1111100",
):
    if payment_frequency and payment_frequency_unit:
        interest_frequency = valuation_models.coupon_Frequency(payment_frequency, payment_frequency_unit)
        if str(last_payment_date) in ["None", "NaT", "-", "nan"]:
            if str(stub_date) in ["None", "NaT", "-", "nan"]:
                Begining_Date_array, Ending_Date_array = valuation_models.month_range_day(
                    issue_date[0], maturity_date[0], int(12 / interest_frequency)
                )
            else:
                Begining_Date_array_0 = np.array(issue_date, dtype="datetime64[D]")
                Ending_Date_array_0 = np.array([stub_date], dtype="datetime64[D]")
                Begining_Date_array, Ending_Date_array = valuation_models.month_range_day(
                    stub_date,
                    maturity_date[0],
                    int(12 / interest_frequency),
                )
                Begining_Date_array = np.concatenate((Begining_Date_array_0, Begining_Date_array))
                Ending_Date_array = np.concatenate((Ending_Date_array_0, Ending_Date_array))

        else:
            Begining_Date_array, Ending_Date_array = valuation_models.month_range_day(
                last_payment_date, maturity_date[0], int(12 / interest_frequency)
            )
    else:
        Begining_Date_array = np.array([issue_date], dtype="datetime64[D]")
        Ending_Date_array = np.array(maturity_date, dtype="datetime64[D]")

    interest_rate = base_rate + fixed_spread
    Cashflow_Date_array = np.empty([0], dtype="datetime64[D]")
    convention_code = valuation_models.busday_convention_code(convention_code)
    Maturity_Date = np.array(
        [business_day_val(maturity_date[0].date(), convention_code, [])], dtype="datetime64[D]"
    )
    del_index = []
    if convention_code == "EOM":
        Cashflow_Date_array = conventions.eomonth(Ending_Date_array, Maturity_Date[0])
        del_index = np.where(Cashflow_Date_array <= Valuation_Date)
        Cashflow_Date_array = np.unique(Cashflow_Date_array[Cashflow_Date_array > Valuation_Date])
        Begining_Date_array = np.delete(Begining_Date_array, del_index)
    else:
        for i in range(Ending_Date_array.size):
            if Ending_Date_array[i] > valuation_date:
                Cashflow_Date_array = np.append(
                    Cashflow_Date_array,
                    conventions.business_day(
                        Ending_Date_array[i], convention_code, holiday_calendar, business_days=business_days
                    ),
                )
            else:
                del_index.append(i)
        for d_i in sorted(del_index, reverse=True):
            Begining_Date_array = np.delete(Begining_Date_array, d_i)
            Ending_Date_array = np.delete(Ending_Date_array, d_i)

    deposit_frequency = valuation_models.coupon_Frequency(deposit_frequency, deposit_frequency_unit)
    if str(last_deposit_date) in ["None", "NaT", "-", "nan"]:
        if str(principal_stub_date) in ["None", "NaT", "-", "nan"]:
            deposit_start_dates, deposit_end_dates = valuation_models.month_range_day(
                issue_date[0], maturity_date[0], int(12 / deposit_frequency)
            )
        else:
            deposit_start_dates_0 = np.array(issue_date, dtype="datetime64[D]")
            deposit_end_dates_0 = np.array([principal_stub_date], dtype="datetime64[D]")
            deposit_start_dates, deposit_end_dates = valuation_models.month_range_day(
                principal_stub_date,
                maturity_date[0],
                int(12 / deposit_frequency),
            )
            deposit_start_dates = np.concatenate((deposit_start_dates_0, deposit_start_dates))
            deposit_end_dates = np.concatenate((deposit_end_dates_0, deposit_end_dates))

    else:
        deposit_start_dates, deposit_end_dates = valuation_models.month_range_day(
            last_deposit_date, maturity_date[0], int(12 / deposit_frequency)
        )

    deposit_dates = np.empty([0], dtype="datetime64[D]")
    del_index = []
    for i in range(deposit_end_dates.size):
        if deposit_end_dates[i] > valuation_date:
            deposit_dates = np.append(
                deposit_dates,
                conventions.business_day(
                    deposit_end_dates[i], convention_code, holiday_calendar, business_days=business_days
                ),
            )
        else:
            del_index.append(i)
    for d_i in sorted(del_index, reverse=True):
        deposit_start_dates = np.delete(deposit_start_dates, d_i)
        deposit_end_dates = np.delete(deposit_end_dates, d_i)
    deposit_amounts = np.repeat(deposit_amount, len(deposit_dates))
    principal_outstanding_start = np.empty([0], dtype="float64")
    principal_outstanding_end = np.empty([0], dtype="float64")
    for i in range(0, len(deposit_dates)):
        principal_outstanding_start = np.append(principal_outstanding_start, outstanding_amount)
        if deposit_dates[i] == maturity_date[0]:
            principal_outstanding_end = np.append(principal_outstanding_end, outstanding_amount)
        else:
            outstanding_amount = outstanding_amount + deposit_amounts[i]
            principal_outstanding_end = np.append(principal_outstanding_end, outstanding_amount)

    Interests = np.empty([0], dtype="float64")
    for j in range(0, len(Cashflow_Date_array)):
        deposit_dates_end = deposit_dates[
            np.where((deposit_dates > Begining_Date_array[j]) & (deposit_dates <= Cashflow_Date_array[j]))
        ]
        if j == 0:
            total_interest = accrued_interest
        else:
            total_interest = 0

        if deposit_dates_end.size > 0:
            for k in range(deposit_dates_end.size):
                outstanding_amount_period_start = principal_outstanding_start[
                    np.where(deposit_dates == deposit_dates_end[k])
                ]
                if k == 0:
                    if j == 0:
                        if deposit_dates_end[k] == Cashflow_Date_array[j]:
                            if accrued_interest == 0:
                                year_frac = conventions.A_day_count(
                                    Begining_Date_array[j],
                                    Cashflow_Date_array[j],
                                    accrual_convention_code,
                                    custom_daycount_conventions=custom_daycount_conventions,
                                )
                            else:
                                year_frac = conventions.A_day_count(
                                    valuation_date,
                                    Cashflow_Date_array[j],
                                    accrual_convention_code,
                                    custom_daycount_conventions=custom_daycount_conventions,
                                )
                        else:
                            if accrued_interest == 0:
                                year_frac = conventions.A_day_count(
                                    Begining_Date_array[j],
                                    deposit_dates_end[k],
                                    accrual_convention_code,
                                    custom_daycount_conventions=custom_daycount_conventions,
                                )
                            else:
                                year_frac = conventions.A_day_count(
                                    valuation_date,
                                    deposit_dates_end[k],
                                    accrual_convention_code,
                                    custom_daycount_conventions=custom_daycount_conventions,
                                )
                    else:
                        if deposit_dates_end[k] == Cashflow_Date_array[j]:
                            year_frac = conventions.A_day_count(
                                Begining_Date_array[j],
                                Cashflow_Date_array[j],
                                accrual_convention_code,
                                custom_daycount_conventions=custom_daycount_conventions,
                            )
                        else:
                            year_frac = conventions.A_day_count(
                                Begining_Date_array[j],
                                deposit_dates_end[k],
                                accrual_convention_code,
                                custom_daycount_conventions=custom_daycount_conventions,
                            )
                else:
                    year_frac = conventions.A_day_count(
                        deposit_dates_end[k - 1],
                        deposit_dates_end[k],
                        accrual_convention_code,
                        custom_daycount_conventions=custom_daycount_conventions,
                    )
                total_interest += interest_rate * year_frac * outstanding_amount_period_start
            if deposit_dates_end[-1] != Cashflow_Date_array[j]:
                outstanding_amount_period_start = principal_outstanding_end[
                    np.where(deposit_dates == deposit_dates_end[-1])
                ]
                year_frac = conventions.A_day_count(
                    deposit_dates_end[-1],
                    Cashflow_Date_array[j],
                    accrual_convention_code,
                    custom_daycount_conventions=custom_daycount_conventions,
                )
                total_interest += interest_rate * year_frac * outstanding_amount_period_start
        else:
            principal_index = np.where(deposit_dates < Cashflow_Date_array[j])[0]
            if len(principal_index) == 0:
                outstanding_amount_period_start = principal_outstanding_start[0]
            else:
                outstanding_amount_period_start = principal_outstanding_end[principal_index[-1]]

            if j == 0:
                if accrued_interest == 0:
                    year_frac = conventions.A_day_count(
                        Begining_Date_array[j],
                        Cashflow_Date_array[j],
                        accrual_convention_code,
                        custom_daycount_conventions=custom_daycount_conventions,
                    )
                else:
                    year_frac = conventions.A_day_count(
                        valuation_date,
                        Cashflow_Date_array[j],
                        accrual_convention_code,
                        custom_daycount_conventions=custom_daycount_conventions,
                    )
            else:
                year_frac = conventions.A_day_count(
                    Begining_Date_array[j],
                    Cashflow_Date_array[j],
                    accrual_convention_code,
                    custom_daycount_conventions=custom_daycount_conventions,
                )
            total_interest += interest_rate * year_frac * outstanding_amount_period_start

        Interests = np.append(Interests, total_interest)

    cashflow_type_array_interest = np.repeat("Interest Paid", len(Interests))
    cashflow_type_array_principal = np.repeat("Inflows", len(deposit_amounts) - 1)
    cashflow_type_array_principal = np.append(cashflow_type_array_principal, "Principal Amount")
    deposit_amounts[-1] = principal_outstanding_end[-1] * -1
    Interests = Interests * -1
    cashflows = list(Interests) + list(deposit_amounts)
    cashflow_type_array = list(cashflow_type_array_interest) + list(cashflow_type_array_principal)
    TTM_array_interest = conventions.D_day_count(
        valuation_date,
        Cashflow_Date_array,
        discount_daycount_convention_code,
        custom_daycount_conventions=custom_daycount_conventions,
    )
    TTM_array_principal = conventions.D_day_count(
        valuation_date,
        deposit_dates,
        discount_daycount_convention_code,
        custom_daycount_conventions=custom_daycount_conventions,
    )
    TTM_array = list(TTM_array_interest) + list(TTM_array_principal)
    cashflow_date_array = list(Cashflow_Date_array) + list(deposit_dates)
    result_array = [cashflow_date_array, TTM_array, cashflows, cashflow_type_array]
    return result_array


def Repayment_amount(repayment_dates, cashflow_dates, adjusted_outstanding, outstanding_amount):
    amounts = np.empty([0], dtype="float")

    f = np.where(cashflow_dates < repayment_dates[0], outstanding_amount, 1)
    f = f.astype("float")
    index = np.argwhere(f == 1)
    outstanding_amount = np.delete(f, index)
    amounts = np.append(amounts, outstanding_amount)

    for i in range(repayment_dates.size - 1):

        a = np.where(cashflow_dates >= repayment_dates[i], 1, 0)
        b = np.where(cashflow_dates < repayment_dates[i + 1], 1, 0)
        c = a & b
        adjusted_amounts = np.where(c == 1, adjusted_outstanding[i], 1)
        index = np.argwhere(adjusted_amounts == 1)
        y = np.delete(adjusted_amounts, index)
        amounts = np.append(amounts, y)
    size = repayment_dates.size - 1
    x = np.where(cashflow_dates >= repayment_dates[size], adjusted_outstanding[-1], 1)
    index = np.argwhere(x == 1)
    final_outstanding_amount = np.delete(x, index)
    amounts = np.append(amounts, final_outstanding_amount)
    return amounts


def CCOD_Cashflow(
    fund,
    Portfolio,
    Position_ID,
    Next_Payment_Date,
    Payment_Frequency,
    Base_Rate,
    Margin,
    Outstanding_Amount,
    utilized_limit_amount,
    Discounting_Curve,
    Currency,
    Date,
    Percentage,
    product_variant_name,
    Val_Date,
    entity,
    Accrual_convention_code,
    asset_liability_type,
    maturity_date,
    custom_daycount_conventions,
):

    Cashflow_Date = np.array(Date)
    Primary_Currency_array = np.array(Currency)
    Position_ID_array = np.array(Position_ID)
    Outstanding_Amount_array = np.array([Outstanding_Amount], dtype="float")
    Principal_Paid_array = Outstanding_Amount_array[0] * Percentage / 100

    cumsum = Principal_Paid_array.cumsum()
    cumsum = np.array(cumsum + utilized_limit_amount).astype("float")
    interest_proceeds = (cumsum * Base_Rate) / 365
    total_interest = np.sum(interest_proceeds)
    total_redemption = cumsum[-1]
    Cashflow = np.append(Principal_Paid_array, total_interest)
    Cashflow = np.append(Cashflow, total_redemption)
    maturity_arr = np.repeat(maturity_date, 2)
    Cashflow_Date = np.append(Cashflow_Date, maturity_arr)
    cashflow_type_arr = np.where(Cashflow == total_interest, "Interest Proceeds", "Withdrawals")
    cashflow_type_arr = np.delete(cashflow_type_arr, -1)
    cashflow_type_arr = np.append(cashflow_type_arr, "Redemption Proceeds")
    sizes = Cashflow_Date.size

    Val_array = np.repeat(Val_Date, sizes)
    TTM_array = conventions.D_day_count(
        Val_array, Cashflow_Date, 7, custom_daycount_conventions=custom_daycount_conventions
    )
    fund_arr = np.repeat(fund, sizes)
    Portfolio_arr = np.repeat(Portfolio, sizes)
    Entity_arr = np.repeat(entity, sizes)
    Product_Variant_name_Arr = np.repeat(product_variant_name, sizes)
    reference_arr = np.repeat("Security", sizes)
    Cashflow_status_arr = np.repeat("Unrealised", sizes)
    df_arr = np.repeat(0, sizes)
    PV_arr = np.repeat(0, sizes)
    Position_ID_arr = np.repeat(Position_ID_array, sizes)
    Primary_Currency_array = np.array(Currency)
    Primary_Currency_arr = np.repeat(Primary_Currency_array, sizes)
    size_diff = Cashflow.size - Principal_Paid_array.size
    arr = np.repeat(0, size_diff)
    Interest_Paid_arr = np.repeat(0, sizes)
    Principal_Paid_array = np.append(Principal_Paid_array, arr)

    Asset_arr = np.repeat(asset_liability_type, sizes)

    cohort_arr = np.repeat("N/A", sizes)
    Val_list = list(Val_array)
    Cashflow_Date_list = list(Cashflow_Date)
    Position_ID_list = list(Position_ID_arr)
    reference_list = list(reference_arr)
    Cashflow_type_list = list(cashflow_type_arr)
    Cashflow_status_list = list(Cashflow_status_arr)
    Cashflow_list = list(Cashflow)
    TTM_list = list(TTM_array)
    df_list = list(df_arr)
    pv_list = list(PV_arr)
    Primary_Currency_list = list(Primary_Currency_arr)
    Asset_list = list(Asset_arr)
    Prod_name_list = list(Product_Variant_name_Arr)
    fund_list = list(fund_arr)
    portfolio_list = list(Portfolio_arr)
    cohort_list = list(cohort_arr)
    Entity_list = list(Entity_arr)
    Interest_Paid_list = list(Interest_Paid_arr)
    Principal_Paid_list = list(Principal_Paid_array)

    result_array = np.array(
        [
            Val_list,
            Cashflow_Date_list,
            Position_ID_list,
            reference_list,
            Cashflow_type_list,
            Cashflow_status_list,
            Cashflow_list,
            TTM_list,
            df_list,
            pv_list,
            Primary_Currency_list,
            Asset_list,
            Prod_name_list,
            fund_list,
            portfolio_list,
            cohort_list,
            Entity_list,
            Interest_Paid_list,
            Principal_Paid_list,
        ]
    )
    return result_array


def overdue_cashflow_calculations(
    position_id,
    cashflow_data,
    dpd_schedule,
    dpd_ruleset_logic,
    overdue_bucketing_data,
    valuation_date,
    Unique_Reference_Id,
    reference_dimension,
    cashflow_status,
    currency,
    asset_liability_type,
    product_variant_name,
    fund,
    portfolio,
    entity,
    interest_overdue,
    principal_overdue,
    charges_overdue,
):
    if position_id in dpd_schedule["position_id"].tolist():
        dpd_schedule_position = dpd_schedule[dpd_schedule["position_id"] == position_id]
        dpd_ruleset_logic["start"] = np.where(
            dpd_ruleset_logic["dpd_start_unit"].isin(["Months", "M", "Month"]),
            dpd_ruleset_logic["dpd_start"] * 30,
            np.where(
                dpd_ruleset_logic["dpd_start_unit"].isin(["Years", "Y", "Year"]),
                dpd_ruleset_logic["dpd_start"] * 365,
                dpd_ruleset_logic["dpd_start"],
            ),
        )
        dpd_ruleset_logic["end"] = np.where(
            dpd_ruleset_logic["dpd_end_unit"].isin(["Months", "M", "Month"]),
            dpd_ruleset_logic["dpd_end"] * 30,
            np.where(
                dpd_ruleset_logic["dpd_end_unit"].isin(["Years", "Y", "Year"]),
                dpd_ruleset_logic["dpd_end"] * 365,
                dpd_ruleset_logic["dpd_end"],
            ),
        )
        dpd_ruleset_logic["ttm"] = np.where(
            dpd_ruleset_logic["period_parameter_unit"].isin(["Months", "M", "Month"]),
            dpd_ruleset_logic["period_parameter"] / 12,
            np.where(
                dpd_ruleset_logic["period_parameter_unit"].isin(["Days", "D", "Day"]),
                dpd_ruleset_logic["period_parameter"] / 365,
                dpd_ruleset_logic["period_parameter"],
            ),
        )
        dpd_cashflows = []
        for i, m in dpd_schedule_position.iterrows():
            if m["cashflow"] != 0:
                dpd = m["dpd"]
                dpd_ruleset_logic_filtered = dpd_ruleset_logic.loc[
                    dpd_ruleset_logic["overdue_type"] == m["cashflow_type"]
                ]
                ttm = dpd_ruleset_logic_filtered.loc[
                    (dpd_ruleset_logic_filtered["start"] < dpd) & (dpd_ruleset_logic_filtered["end"] >= dpd),
                    "ttm",
                ].iloc[0]
                cashflow_model_results = {
                    "extract_date": valuation_date[0],
                    "transaction_date": valuation_date[0] + np.timedelta64(round(ttm * 365), "D"),
                    "unique_reference_id": Unique_Reference_Id,
                    "reference_dimension": reference_dimension,
                    "cashflow_type": m["cashflow_type"],
                    "cashflow_status": cashflow_status,
                    "cashflow": m["cashflow"],
                    "time_to_maturity": ttm,
                    "discount_factor": None,
                    "present_value": None,
                    "currency": currency,
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }
                dpd_cashflows.append(cashflow_model_results)

        if dpd_cashflows != []:
            dpd_cashflows = pd.DataFrame(dpd_cashflows)
            cashflow_data = pd.concat([cashflow_data, dpd_cashflows], ignore_index=True)

    else:
        dpd_cashflows = []
        if str(interest_overdue) not in ["None", "", "nan"]:
            if interest_overdue != 0:
                ttm = overdue_bucketing_data.loc[
                    (overdue_bucketing_data["product_variant_name"] == product_variant_name)
                    & (overdue_bucketing_data["overdue_type"] == "Interest Overdue"),
                    "ttm",
                ].iloc[0]
                cashflow_model_results = {
                    "extract_date": valuation_date[0],
                    "transaction_date": valuation_date[0] + np.timedelta64(round(ttm * 365), "D"),
                    "unique_reference_id": Unique_Reference_Id,
                    "reference_dimension": reference_dimension,
                    "cashflow_type": "Interest Overdue",
                    "cashflow_status": cashflow_status,
                    "cashflow": float(interest_overdue),
                    "time_to_maturity": ttm,
                    "discount_factor": None,
                    "present_value": None,
                    "currency": currency,
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }
                dpd_cashflows.append(cashflow_model_results)
        if str(principal_overdue) not in ["None", "", "nan"]:
            if principal_overdue != 0:
                ttm = overdue_bucketing_data.loc[
                    (overdue_bucketing_data["product_variant_name"] == product_variant_name)
                    & (overdue_bucketing_data["overdue_type"] == "Principal Overdue"),
                    "ttm",
                ].iloc[0]
                cashflow_model_results = {
                    "extract_date": valuation_date[0],
                    "transaction_date": valuation_date[0] + np.timedelta64(round(ttm * 365), "D"),
                    "unique_reference_id": Unique_Reference_Id,
                    "reference_dimension": reference_dimension,
                    "cashflow_type": "Principal Overdue",
                    "cashflow_status": cashflow_status,
                    "cashflow": float(principal_overdue),
                    "time_to_maturity": ttm,
                    "discount_factor": None,
                    "present_value": None,
                    "currency": currency,
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }
                dpd_cashflows.append(cashflow_model_results)
        if str(charges_overdue) not in ["None", "", "nan"]:
            if charges_overdue != 0:
                ttm = overdue_bucketing_data.loc[
                    (overdue_bucketing_data["product_variant_name"] == product_variant_name)
                    & (overdue_bucketing_data["overdue_type"] == "Interest on Overdue"),
                    "ttm",
                ].iloc[0]
                cashflow_model_results = {
                    "extract_date": valuation_date[0],
                    "transaction_date": valuation_date[0] + np.timedelta64(round(ttm * 365), "D"),
                    "unique_reference_id": Unique_Reference_Id,
                    "reference_dimension": reference_dimension,
                    "cashflow_type": "Interest on Overdue",
                    "cashflow_status": cashflow_status,
                    "cashflow": float(charges_overdue),
                    "time_to_maturity": ttm,
                    "discount_factor": None,
                    "present_value": None,
                    "currency": currency,
                    "asset_liability_type": asset_liability_type,
                    "product_variant_name": product_variant_name,
                    "fund": fund,
                    "portfolio": portfolio,
                    "cohort": "",
                    "entity": entity,
                }
                dpd_cashflows.append(cashflow_model_results)

        if dpd_cashflows != []:
            dpd_cashflows = pd.DataFrame(dpd_cashflows)
            cashflow_data = pd.concat([cashflow_data, dpd_cashflows], ignore_index=True)

    return cashflow_data, dpd_cashflows


def compound_interest_calculation_formula(
    compounding_frequency, compounding_frequency_unit, n, principal, interest_rate
):
    no_of_payments = valuation_models.coupon_Frequency(compounding_frequency, compounding_frequency_unit)
    interest_amount = principal * (1 + (interest_rate / no_of_payments)) ** (no_of_payments * n) - principal
    return interest_amount


def compound_interest_schedule_generation(
    compounding_frequency,
    compounding_frequency_unit,
    start_date,
    end_date,
    cashflow_beginning_date,
    cashflow_date,
    last_payment_date,
    principal,
    interest_rate,
    discount_convention_code,
    custom_daycount_conventions,
    payout="Maturity",
    model_code="",
    accrued_interest=0,
    valuation_date="",
):
    compounding_frequency = valuation_models.coupon_Frequency(
        compounding_frequency, compounding_frequency_unit
    )

    # Generates the compounding date schedule

    if compounding_frequency_unit == "D":
        period = int(365.25 / compounding_frequency)
        Begining_Date_array = date_range_day(np.datetime64(start_date), np.datetime64(end_date), period)
        Ending_Date_array = date_range_day(
            np.datetime64(start_date) + np.timedelta64(period, "D"),
            np.datetime64(end_date) + np.timedelta64(period, "D"),
            period,
        )
    else:
        Begining_Date_array, Ending_Date_array = valuation_models.month_range_day(
            start_date, end_date, int(12 / compounding_frequency)
        )

    if model_code == "M046":
        Begining_Date_array = Begining_Date_array[np.where(Ending_Date_array > valuation_date[0])]
        Ending_Date_array = Ending_Date_array[np.where(Ending_Date_array > valuation_date[0])]

    # For interest payouts that are schedule based, the cashflow payment date schedule is added to the compounding date schedule
    if payout == "Cashflow_Schedule":
        Begining_Date_array = np.sort(np.unique(np.append(Begining_Date_array, cashflow_beginning_date)))
        Ending_Date_array = np.append(Ending_Date_array, cashflow_date)
        Ending_Date_array = np.sort(np.unique(np.append(Ending_Date_array, cashflow_beginning_date[0])))

    # Generation of the compound interest schedule
    compound_interest_schedule = []
    for i in range(0, len(Begining_Date_array)):
        compound_interest_schedule_row = {}
        compound_interest_schedule_row["accrual_start_date"] = Begining_Date_array[i]
        compound_interest_schedule_row["date"] = Ending_Date_array[i]
        # Flag to identify the cashflow payment date
        if payout == "Maturity":
            if i == len(Begining_Date_array) - 1:
                compound_interest_schedule_row["payout_date"] = 1
            else:
                compound_interest_schedule_row["payout_date"] = 0
        else:
            if Ending_Date_array[i] in cashflow_date or Ending_Date_array[i] == last_payment_date:
                compound_interest_schedule_row["payout_date"] = 1
            else:
                compound_interest_schedule_row["payout_date"] = 0
        # Accrual period calculation
        if model_code == "M046" and i == 0:
            compound_interest_schedule_row["year_frac"] = conventions.D_day_count(
                valuation_date,
                Ending_Date_array[i],
                discount_convention_code,
                custom_daycount_conventions=custom_daycount_conventions,
            )
        else:
            compound_interest_schedule_row["year_frac"] = conventions.D_day_count(
                Begining_Date_array[i],
                Ending_Date_array[i],
                discount_convention_code,
                custom_daycount_conventions=custom_daycount_conventions,
            )
        # Accrual factor calculation
        compound_interest_schedule_row["accrual_rate"] = (
            compound_interest_schedule_row["year_frac"] * interest_rate
        )
        if i == 0:
            if model_code == "M046" and str(accrued_interest) != "None":
                compound_interest_schedule_row["accrual_factor"] = (
                    1 + compound_interest_schedule_row["accrual_rate"] + accrued_interest / principal[0]
                )
            else:
                compound_interest_schedule_row["accrual_factor"] = (
                    1 + compound_interest_schedule_row["accrual_rate"]
                )
        else:
            compound_interest_schedule_row["accrual_factor"] = compound_interest_schedule[i - 1][
                "accrual_factor_payoff"
            ] * (1 + compound_interest_schedule_row["accrual_rate"])
        if compound_interest_schedule_row["payout_date"] == 0:
            compound_interest_schedule_row["accrual_factor_payoff"] = compound_interest_schedule_row[
                "accrual_factor"
            ]
        else:
            compound_interest_schedule_row["accrual_factor_payoff"] = 1
        compound_interest_schedule.append(compound_interest_schedule_row)

    compound_interest_schedule = pd.DataFrame(compound_interest_schedule)

    # Outstanding balance and interest calculation
    compound_interest_schedule["outstanding_balance_before_payout"] = (
        principal[0] * compound_interest_schedule["accrual_factor"]
    )
    compound_interest_schedule["outstanding_balance_after_payout"] = (
        principal[0] * compound_interest_schedule["accrual_factor_payoff"]
    )
    compound_interest_schedule["interest"] = (
        compound_interest_schedule["outstanding_balance_before_payout"] - principal[0]
    )
    return compound_interest_schedule


## Building blocks functions


def executeparallel(config_dict, position_data, func, **kwargs):
    table_cols = position_data.columns
    index_list = []

    def col_index_func(table_cols):
        index_list.append(position_data.columns.get_loc(table_cols))

    np.vectorize(col_index_func)(table_cols)
    index_list.pop(0)

    column_index_dict = dict(zip(table_cols, index_list))
    position_data = np.array(position_data)

    def applyParallel(position_data, column_index_dict, config_dict, func, **kwargs):
        output = Parallel(n_jobs=multiprocessing.cpu_count())(
            delayed(func)(row, column_index_dict, config_dict, **kwargs) for row in position_data
        )
        output = pd.concat(output, ignore_index=True)
        return output

    output = applyParallel(position_data, column_index_dict, config_dict, func, **kwargs)

    return output


def schedule_generation_function(config_dict, request, data=None):

    if config_dict["inputs"]["Data_Choice"] == "Custom_input":
        position_data = pd.DataFrame(config_dict["inputs"], index=[0])
    else:
        position_data = data["position_data"]
        position_data["model_code"] = config_dict["inputs"]["model_code"]

    if "repayment_schedule_data" in data.keys():
        repayment_schedule = data["repayment_schedule_data"]
    else:
        repayment_schedule = None

    holiday_calendar = read_data_func(
        request,
        {
            "inputs": {
                "Data_source": "Database",
                "Table": "Holiday_Calendar_Repository",
                "Columns": ["holiday_calendar", "holiday_date"],
            },
            "condition": [],
        },
    )
    currency_data = read_data_func(
        request,
        {
            "inputs": {
                "Data_source": "Database",
                "Table": "CurrencyMaster",
                "Columns": ["currency_code", "default_holiday_calendar"],
            },
            "condition": [],
        },
    )
    schedule_results = executeparallel(
        config_dict,
        position_data,
        schedule_generation_model,
        holiday_calendar=holiday_calendar,
        currency_data=currency_data,
        repayment_schedule_data=repayment_schedule,
    )
    return schedule_results


def schedule_generation_model(row, column_index_dict, config_dict, **kwargs):
    Unique_Reference_Id = if_key_exists(row, column_index_dict, "unique_reference_id")
    Valuation_Date = np.datetime64(if_key_exists(row, column_index_dict, "reporting_date"), "D")
    currency = if_key_exists(row, column_index_dict, "primary_currency")
    product_variant_name = if_key_exists(row, column_index_dict, "product_variant_name")

    holiday_calendar = kwargs["holiday_calendar"]
    currency_data = kwargs["currency_data"]
    repayment_schedule_data = kwargs["repayment_schedule_data"]
    holiday_calendar_name = if_key_exists(row, column_index_dict, "holiday_calendar")
    if str(holiday_calendar_name) in ["nan", "None"]:
        holiday_calendar_name = currency_data.loc[
            currency_data["currency_code"] == currency, "default_holiday_calendar"
        ].iloc[0]
    holiday_calendar = np.array(
        holiday_calendar.loc[holiday_calendar["holiday_calendar"] == holiday_calendar_name, "holiday_date"]
    ).astype("datetime64[D]")

    Maturity_Date = np.array(np.datetime64(row[column_index_dict["maturity_date"]], "D"))
    ## Zero Coupon Bonds with only Redemption Proceeds
    if row[column_index_dict["model_code"]] in ["M001", "M005"]:
        Business_day_convention = np.array([row[column_index_dict["business_convention"]]])
        convention_code = valuation_models.busday_convention_code(Business_day_convention)
        cashflow_date = conventions.business_day(Maturity_Date, convention_code, holiday_calendar)
        schedule_model_results = {
            "extract_date": Valuation_Date,
            "unique_reference_id": Unique_Reference_Id,
            "product_variant_name": product_variant_name,
            "transaction_date": cashflow_date,
            "cashflow_type": "Redemption Proceeds",
        }
        schedule_model_results = pd.DataFrame([schedule_model_results])

    ## Zero Coupon Instruments with interest and principal split
    elif row[column_index_dict["model_code"]] in ["M031"]:
        Business_day_convention = np.array([row[column_index_dict["business_convention"]]])
        convention_code = valuation_models.busday_convention_code(Business_day_convention)
        cashflow_date = conventions.business_day(Maturity_Date, convention_code, holiday_calendar)
        schedule_model_results = {
            "extract_date": Valuation_Date,
            "unique_reference_id": Unique_Reference_Id,
            "product_variant_name": product_variant_name,
            "transaction_date": cashflow_date,
            "cashflow_type": "Interest Proceeds",
        }
        schedule_model_results = pd.DataFrame([schedule_model_results])

        schedule_model_results = pd.concat([schedule_model_results, schedule_model_results.iloc[[-1]]])
        schedule_model_results.iloc[-1, schedule_model_results.columns.get_loc("cashflow_type")] = (
            "Redemption Proceeds"
        )

    ## Fixed coupon instruments
    elif row[column_index_dict["model_code"]] in ["M002", "M006", "M023", "M037"]:
        Issue_Date = pd.to_datetime(row[column_index_dict["issue_date"]], dayfirst=True)
        Coupon_Frequency = row[column_index_dict["payment_frequency"]]
        Coupon_Frequency_unit = row[column_index_dict["payment_frequency_units"]]
        Business_day_convention = np.array([row[column_index_dict["business_convention"]]])
        Last_coupon_date = np.datetime64(if_key_exists(row, column_index_dict, "last_payment_date"), "D")
        stub_date = np.datetime64(if_key_exists(row, column_index_dict, "stub_date"), "D")
        if Coupon_Frequency and Coupon_Frequency_unit:
            coupon_frequency = valuation_models.coupon_Frequency(Coupon_Frequency, Coupon_Frequency_unit)
            if str(Last_coupon_date) in ["None", "NaT", "-", "nan"]:
                if str(stub_date) in ["None", "NaT", "-", "nan"]:
                    Begining_Date_array, Ending_Date_array = valuation_models.month_range_day(
                        Issue_Date, pd.to_datetime(Maturity_Date), int(12 / coupon_frequency)
                    )
                else:
                    Begining_Date_array_0 = np.array([Issue_Date], dtype="datetime64[D]")
                    Ending_Date_array_0 = np.array([stub_date], dtype="datetime64[D]")
                    Begining_Date_array, Ending_Date_array = valuation_models.month_range_day(
                        stub_date,
                        pd.to_datetime(Maturity_Date),
                        int(12 / coupon_frequency),
                    )
                    Begining_Date_array = np.concatenate((Begining_Date_array_0, Begining_Date_array))
                    Ending_Date_array = np.concatenate((Ending_Date_array_0, Ending_Date_array))
            else:
                Begining_Date_array, Ending_Date_array = valuation_models.month_range_day(
                    Last_coupon_date, pd.to_datetime(Maturity_Date), int(12 / coupon_frequency)
                )
        else:
            Begining_Date_array = np.array([Issue_Date], dtype="datetime64[D]")
            Ending_Date_array = np.array(Maturity_Date[0], dtype="datetime64[D]")
        Cashflow_Date_array = np.empty([0], dtype="datetime64[D]")
        convention_code = valuation_models.busday_convention_code(Business_day_convention)
        del_index = []
        if convention_code == "EOM":
            Cashflow_Date_array = conventions.eomonth(Ending_Date_array, Maturity_Date[0])
            del_index = np.where(Cashflow_Date_array <= Valuation_Date)
            Cashflow_Date_array = np.unique(Cashflow_Date_array[Cashflow_Date_array > Valuation_Date])
            Begining_Date_array = np.delete(Begining_Date_array, del_index)
        else:
            for i in range(Ending_Date_array.size):
                if Ending_Date_array[i] > Valuation_Date:
                    Cashflow_Date_array = np.append(
                        Cashflow_Date_array,
                        conventions.business_day(Ending_Date_array[i], convention_code, holiday_calendar),
                    )
                else:
                    del_index.append(i)
        for d_i in sorted(del_index, reverse=True):
            Begining_Date_array = np.delete(Begining_Date_array, d_i)
            Ending_Date_array = np.delete(Ending_Date_array, d_i)

        schedule_model_results = {
            "unique_reference_id": Unique_Reference_Id,
            "product_variant_name": product_variant_name,
            "transaction_date": Cashflow_Date_array,
            "accrual_start_date": Begining_Date_array,
            "accrual_end_date": Ending_Date_array,
            "cashflow_type": "Interest Proceeds",
        }
        schedule_model_results = pd.DataFrame(schedule_model_results)

        ## Adding maturity date redemption cashflows
        if row[column_index_dict["model_code"]] in ["M002", "M006", "M037"]:
            schedule_model_results = pd.concat([schedule_model_results, schedule_model_results.iloc[[-1]]])
            schedule_model_results.iloc[-1, schedule_model_results.columns.get_loc("cashflow_type")] = (
                "Redemption Proceeds"
            )
            schedule_model_results.iloc[-1, schedule_model_results.columns.get_loc("accrual_start_date")] = (
                None
            )
            schedule_model_results.iloc[-1, schedule_model_results.columns.get_loc("accrual_end_date")] = None

        elif row[column_index_dict["model_code"]] in ["M023"]:
            custom_schedule_id = if_key_exists(row, column_index_dict, "custom_schedule_id", "str")
            principal_payment_frequency = row[column_index_dict["principal_payment_frequency"]]
            principal_payment_frequency_unit = row[column_index_dict["principal_payment_frequency_unit"]]
            last_principal_payment_date = np.array(
                if_key_exists(row, column_index_dict, "last_principal_payment_date"), dtype="datetime64[D]"
            )

            if custom_schedule_id == "Y":
                repayment_schedule_data = repayment_schedule_data.loc[
                    repayment_schedule_data["position_id"] == Unique_Reference_Id
                ]
                repayment_dates = repayment_schedule_data["payment_date"].to_numpy(dtype="datetime64[D]")
            else:
                repayment_frequency = valuation_models.coupon_Frequency(
                    principal_payment_frequency, principal_payment_frequency_unit
                )
                repayment_start_dates, repayment_end_dates = valuation_models.month_range_day(
                    last_principal_payment_date, pd.to_datetime(Maturity_Date), int(12 / repayment_frequency)
                )
                repayment_dates = np.empty([0], dtype="datetime64[D]")
                del_index = []
                for i in range(repayment_end_dates.size):
                    if repayment_end_dates[i] > Valuation_Date:
                        repayment_dates = np.append(
                            repayment_dates,
                            conventions.business_day(
                                repayment_end_dates[i], convention_code, holiday_calendar
                            ),
                        )
                    else:
                        del_index.append(i)

            principal_schedule_results = {
                "unique_reference_id": Unique_Reference_Id,
                "product_variant_name": product_variant_name,
                "transaction_date": repayment_dates,
                "accrual_start_date": None,
                "accrual_end_date": None,
                "cashflow_type": "Redemption Proceeds",
            }
            schedule_model_results = pd.concat(
                [schedule_model_results, pd.DataFrame(principal_schedule_results)]
            )
            schedule_model_results.sort_values(
                by="transaction_date", ascending=True, inplace=True, ignore_index=True
            )

    return schedule_model_results


def cashflow_generation_function(config_dict, request, data):

    if config_dict["inputs"]["Data_Choice"] == "Custom_input":
        position_data = pd.DataFrame(config_dict["inputs"], index=[0])
    else:
        position_data = data["position_data"]
        position_data["model_code"] = config_dict["inputs"]["model_code"]

    if "repayment_schedule_data" in data.keys():
        repayment_schedule = data["repayment_schedule_data"]
    else:
        repayment_schedule = None

    if "interest_schedule_data" in data.keys():
        interest_schedule = data["interest_schedule_data"]
    else:
        interest_schedule = None

    custom_daycount_conventions = read_data_func(
        request,
        {
            "inputs": {
                "Data_source": "Database",
                "Table": "custom_daycount_conventions",
                "Columns": [
                    "convention_name",
                    "numerator",
                    "denominator",
                    "numerator_adjustment",
                    "denominator_adjustment",
                ],
            },
            "condition": [],
        },
    )

    schedule_data = data["previous_result_data"]
    cashflow_results = executeparallel(
        config_dict,
        position_data,
        cashflow_generation_model,
        schedule_data=schedule_data,
        custom_daycount_conventions=custom_daycount_conventions,
        repayment_schedule_data=repayment_schedule,
        interest_schedule_data=interest_schedule,
    )
    return cashflow_results


def cashflow_generation_model(row, column_index_dict, config_dict, **kwargs):
    Unique_Reference_Id = if_key_exists(row, column_index_dict, "unique_reference_id")
    np.array([np.datetime64(if_key_exists(row, column_index_dict, "reporting_date"), "D")])
    schedule_data = kwargs["schedule_data"]
    schedule_data = schedule_data.loc[schedule_data["unique_reference_id"] == Unique_Reference_Id]
    Quantity = float(row[column_index_dict["quantity"]])
    custom_daycount_conventions = kwargs["custom_daycount_conventions"]
    Accrual_Daycount = np.array([row[column_index_dict["accrual_daycount_convention"]]])
    accrual_convention_code = valuation_models.daycount_convention_code(Accrual_Daycount)

    if row[column_index_dict["model_code"]] in ["M001", "M005"]:
        Redemption_Amount = float(row[column_index_dict["redemption_amount"]])
        schedule_data["cashflow"] = Redemption_Amount * Quantity

    elif row[column_index_dict["model_code"]] in ["M031"]:
        Face_Value = float(if_key_exists(row, column_index_dict, "nominal_value", "float"))
        Redemption_Amount = float(if_key_exists(row, column_index_dict, "redemption_amount", "float"))
        Face_Value = Redemption_Amount if Face_Value == 0 else Face_Value
        consideration_amount = float(row[column_index_dict["consideration_amount"]]) / Quantity
        interest_amount = max(Face_Value - consideration_amount, 0)
        schedule_data.loc[schedule_data["cashflow_type"] == "Interest Proceeds", "cashflow"] = (
            interest_amount * Quantity
        )
        schedule_data.loc[schedule_data["cashflow_type"] == "Redemption Proceeds", "cashflow"] = (
            consideration_amount * Quantity
        )

    elif row[column_index_dict["model_code"]] in ["M002", "M006", "M037"]:
        Maturity_Date = np.array(np.datetime64(row[column_index_dict["maturity_date"]], "D"))
        Face_Value = np.array([float(row[column_index_dict["nominal_value"]])])
        Redemption_Amount = np.array([float(row[column_index_dict["redemption_amount"]])])
        Coupon_Rate = np.array([float(if_key_exists(row, column_index_dict, "base_rate")) / 100])

        Begining_Date_array = np.array(schedule_data["accrual_start_date"], dtype="datetime64[D]")
        Ending_Date_array = np.array(schedule_data["accrual_end_date"], dtype="datetime64[D]")
        Cashflow_Date_array = np.array(schedule_data["transaction_date"], dtype="datetime64[D]")

        Year_frac_array = np.empty([0], dtype="float32")
        for i in range(Begining_Date_array.size):
            Year_frac_value = conventions.A_day_count(
                Begining_Date_array[i],
                Ending_Date_array[i],
                accrual_convention_code,
                custom_daycount_conventions=custom_daycount_conventions,
            )

            if Year_frac_value > 0:
                Year_frac_array = np.append(Year_frac_array, Year_frac_value)
            else:
                Year_frac_array = np.append(Year_frac_array, 0)
        Coupon_Rate = np.repeat(Coupon_Rate, len(Year_frac_array))

        ## For Step up bonds
        if row[column_index_dict["model_code"]] in ["M037"]:
            interest_schedule_data = kwargs["interest_schedule_data"]
            interest_schedule_position = interest_schedule_data.loc[
                interest_schedule_data["position_id"] == Unique_Reference_Id
            ].reset_index()

            if len(interest_schedule_position) > 0:
                if "step_up_rate" in interest_schedule_position.columns:
                    method = "step_up_rate"
                else:
                    method = "full_rate"

                for i in range(len(interest_schedule_position)):
                    target_date = np.datetime64(interest_schedule_position.loc[i, "from_date"])
                    target = np.argmax(Begining_Date_array >= target_date)

                    ## For periods before target date with two interest rates applicable
                    if any(Begining_Date_array < target_date):
                        start = np.argmin(Begining_Date_array < target_date) - 1
                        Year_frac_value = conventions.A_day_count(
                            Begining_Date_array[start],
                            target_date,
                            accrual_convention_code,
                            custom_daycount_conventions=custom_daycount_conventions,
                        )
                        if method == "step_up_rate":
                            Coupon_Rate[target:] = Coupon_Rate[start] * Year_frac_value / Year_frac_array[
                                start
                            ] + (Year_frac_array[start] - Year_frac_value) / Year_frac_array[start] * (
                                Coupon_Rate[start]
                                + float(interest_schedule_position.loc[i, "step_up_rate"]) / 100
                            )
                        else:
                            Coupon_Rate[start] = (
                                Coupon_Rate[start] * Year_frac_value / Year_frac_array[start]
                                + (Year_frac_array[start] - Year_frac_value)
                                / Year_frac_array[start]
                                * float(interest_schedule_position.loc[i, "updated_rate"])
                                / 100
                            )

                    if method == "step_up_rate":
                        Coupon_Rate[target:] = (
                            Coupon_Rate[target:]
                            + float(interest_schedule_position.loc[i, "step_up_rate"]) / 100
                        )
                    else:
                        Coupon_Rate[target:] = float(interest_schedule_position.loc[i, "updated_rate"]) / 100

            else:
                step_up_rate = float(row[column_index_dict["step_up_rate"]])
                step_up_interval = float(row[column_index_dict["step_up_interval"]])

                Coupon_Frequency = row[column_index_dict["payment_frequency"]]
                Coupon_Frequency_unit = row[column_index_dict["payment_frequency_units"]]
                coupon_frequency = valuation_models.coupon_Frequency(Coupon_Frequency, Coupon_Frequency_unit)
                Issue_Date = np.datetime64(if_key_exists(row, column_index_dict, "start_date"), "D")
                Year_frac_value = conventions.A_day_count(
                    Issue_Date,
                    Begining_Date_array[0],
                    accrual_convention_code,
                    custom_daycount_conventions=custom_daycount_conventions,
                )
                no_of_payments_done = math.floor(coupon_frequency * Year_frac_value)
                Coupon_Rate = (
                    Coupon_Rate + math.floor(no_of_payments_done / step_up_interval) * step_up_rate / 100
                )

                for i in range(len(Coupon_Rate)):
                    if (i + no_of_payments_done + 1) % step_up_interval == 0:
                        Coupon_Rate[i:] = Coupon_Rate[i:] + step_up_rate / 100

        Face_Value = np.repeat(Face_Value, len(Year_frac_array))
        Coupons, Principal, Total_Amount = fixed_income_government_cashflows(
            Cashflow_Date_array, Year_frac_array, Face_Value, Coupon_Rate, Maturity_Date, Redemption_Amount
        )
        cashflow_type = schedule_data["cashflow_type"].to_list()
        schedule_data["total_amount"] = np.select(
            [
                [x == "Interest Proceeds" for x in cashflow_type],
                [x == "Redemption Proceeds" for x in cashflow_type],
            ],
            [Coupons, Principal],
        )
        schedule_data["cashflow"] = schedule_data["total_amount"] * Quantity

    elif row[column_index_dict["model_code"]] in ["M023"]:
        custom_schedule_id = if_key_exists(row, column_index_dict, "custom_schedule_id", "str")
        outstanding_amount = float(if_key_exists(row, column_index_dict, "outstanding_amount", "float"))
        Coupon_Rate = float(if_key_exists(row, column_index_dict, "base_rate")) / 100
        Accrual_Daycount = np.array([row[column_index_dict["accrual_daycount_convention"]]])
        accrual_convention_code = valuation_models.daycount_convention_code(Accrual_Daycount)
        repayment_schedule_data = kwargs["repayment_schedule_data"]

        repayment_dates = schedule_data.loc[
            schedule_data["cashflow_type"] == "Redemption Proceeds", "transaction_date"
        ].to_numpy(dtype="datetime64[D]")
        Begining_Date_array = schedule_data.loc[
            schedule_data["cashflow_type"] == "Interest Proceeds", "accrual_start_date"
        ].to_numpy(dtype="datetime64[D]")
        Ending_Date_array = schedule_data.loc[
            schedule_data["cashflow_type"] == "Interest Proceeds", "accrual_end_date"
        ].to_numpy(dtype="datetime64[D]")
        Cashflow_Date_array = schedule_data.loc[
            schedule_data["cashflow_type"] == "Interest Proceeds", "transaction_date"
        ].to_numpy(dtype="datetime64[D]")

        if custom_schedule_id == "Y":
            repayment_schedule_data = repayment_schedule_data.loc[
                repayment_schedule_data["position_id"] == Unique_Reference_Id
            ]
            repayment_amounts = repayment_schedule_data["payment_amount"].to_numpy(dtype="float64")
        else:
            principal_payment_amount = if_key_exists(
                row, column_index_dict, "principal_payment_amount", "float"
            )
            if principal_payment_amount == 0:
                principal_payment_amount = outstanding_amount / len(repayment_dates)
            repayment_amounts = np.repeat(principal_payment_amount, len(repayment_dates))

        principal_outstanding_start = np.empty([0], dtype="float64")
        principal_outstanding_end = np.empty([0], dtype="float64")
        for i in range(0, len(repayment_dates)):
            principal_outstanding_start = np.append(principal_outstanding_start, outstanding_amount)
            outstanding_amount = outstanding_amount - repayment_amounts[i]
            principal_outstanding_end = np.append(principal_outstanding_end, outstanding_amount)
            schedule_data.loc[
                (schedule_data["cashflow_type"] == "Redemption Proceeds")
                & (schedule_data["transaction_date"] == repayment_dates[i]),
                "cashflow",
            ] = (
                repayment_amounts[i] * Quantity
            )

        for j in range(0, len(Ending_Date_array)):
            repayment_dates_end = repayment_dates[
                np.where(
                    (repayment_dates > Begining_Date_array[j]) & (repayment_dates <= Ending_Date_array[j])
                )
            ]
            if j == 0:
                total_interest = 0
            else:
                total_interest = 0
            if repayment_dates_end.size > 0:
                for k in range(repayment_dates_end.size):
                    outstanding_amount_period_start = principal_outstanding_start[
                        np.where(repayment_dates == repayment_dates_end[k])
                    ]
                    if k == 0:
                        if repayment_dates_end[k] == Ending_Date_array[j]:
                            year_frac = conventions.A_day_count(
                                Begining_Date_array[j],
                                Ending_Date_array[j],
                                accrual_convention_code,
                                custom_daycount_conventions=custom_daycount_conventions,
                            )
                        else:
                            year_frac = conventions.A_day_count(
                                Begining_Date_array[j],
                                repayment_dates_end[k],
                                accrual_convention_code,
                                custom_daycount_conventions=custom_daycount_conventions,
                            )
                    else:
                        year_frac = conventions.A_day_count(
                            repayment_dates_end[k - 1],
                            repayment_dates_end[k],
                            accrual_convention_code,
                            custom_daycount_conventions=custom_daycount_conventions,
                        )
                    total_interest += Coupon_Rate * year_frac * outstanding_amount_period_start
                if repayment_dates_end[-1] != Ending_Date_array[j]:
                    outstanding_amount_period_start = principal_outstanding_end[
                        np.where(repayment_dates == repayment_dates_end[-1])
                    ]
                    year_frac = conventions.A_day_count(
                        repayment_dates_end[-1],
                        Ending_Date_array[j],
                        accrual_convention_code,
                        custom_daycount_conventions=custom_daycount_conventions,
                    )
                    total_interest += Coupon_Rate * year_frac * outstanding_amount_period_start
            else:
                principal_index = np.where(repayment_dates < Ending_Date_array[j])[0]
                if len(principal_index) == 0:
                    outstanding_amount_period_start = principal_outstanding_start[0]
                else:
                    outstanding_amount_period_start = principal_outstanding_end[principal_index[-1]]

                year_frac = conventions.A_day_count(
                    Begining_Date_array[j],
                    Ending_Date_array[j],
                    accrual_convention_code,
                    custom_daycount_conventions=custom_daycount_conventions,
                )
                total_interest += Coupon_Rate * year_frac * outstanding_amount_period_start

            schedule_data.loc[
                (schedule_data["cashflow_type"] == "Interest Proceeds")
                & (schedule_data["transaction_date"] == Cashflow_Date_array[j]),
                "cashflow",
            ] = (
                total_interest * Quantity
            )

    return schedule_data


def TTM_calculation_function(config_dict, request, data):

    custom_daycount_conventions = read_data_func(
        request,
        {
            "inputs": {
                "Data_source": "Database",
                "Table": "custom_daycount_conventions",
                "Columns": [
                    "convention_name",
                    "numerator",
                    "denominator",
                    "numerator_adjustment",
                    "denominator_adjustment",
                ],
            },
            "condition": [],
        },
    )
    if config_dict["inputs"]["Data_Choice"] == "Custom_input":
        position_data = pd.DataFrame(config_dict["inputs"], index=[0])
    else:
        position_data = data["position_data"]
    cashflow_data = data["previous_result_data"]
    cashflow_results = executeparallel(
        config_dict,
        position_data,
        TTM_calculation_model,
        cashflow_data=cashflow_data,
        custom_daycount_conventions=custom_daycount_conventions,
    )
    return cashflow_results


def TTM_calculation_model(row, column_index_dict, config_dict, **kwargs):

    custom_daycount_conventions = kwargs["custom_daycount_conventions"]
    Unique_Reference_Id = if_key_exists(row, column_index_dict, "unique_reference_id")
    discounting_curve = str(if_key_exists(row, column_index_dict, "discounting_curve"))
    credit_spread_curve = str(if_key_exists(row, column_index_dict, "credit_spread_curve"))
    if credit_spread_curve == "None" or credit_spread_curve == "nan":
        credit_spread_curve = ""
    else:
        credit_spread_curve = " | " + credit_spread_curve
    Valuation_Date = np.array([np.datetime64(if_key_exists(row, column_index_dict, "reporting_date"), "D")])

    Discount_Daycount = np.array([row[column_index_dict["discount_daycount_convention"]]])
    discount_convention_code = valuation_models.daycount_convention_code(Discount_Daycount)

    cashflow_data = kwargs["cashflow_data"]
    cashflow_data = cashflow_data.loc[cashflow_data["unique_reference_id"] == Unique_Reference_Id]
    cashflow_date_array = np.array(cashflow_data["transaction_date"].to_list(), dtype="datetime64[D]")
    TTM_array = conventions.D_day_count(
        Valuation_Date,
        cashflow_date_array,
        discount_convention_code,
        custom_daycount_conventions=custom_daycount_conventions,
    )
    cashflow_data["time_to_maturity"] = TTM_array
    cashflow_data["curve_name"] = discounting_curve + credit_spread_curve

    return cashflow_data


def bootstrapping_function(config_dict, request, data):
    if config_dict["inputs"]["Data_Choice"] == "Custom_input":
        position_data = pd.DataFrame(config_dict["inputs"], index=[0])
    else:
        position_data = data["position_data"]

    valuation_date = pd.to_datetime(position_data["reporting_date"].iloc[0])
    config_dict = config_dict["inputs"]["curve_configuration"]
    position_data = position_data.drop_duplicates(["discounting_curve", "credit_spread_curve"])

    ## Data and configuration extraction for IR curve and CS curve
    curve_repo_data = read_data_func(
        request,
        {
            "inputs": {
                "Data_source": "Database",
                "Table": "ir_curve_repository",
                "Columns": [
                    "configuration_date",
                    "curve_name",
                    "curve_components",
                    "interpolation_algorithm",
                    "extrapolation_algorithm",
                ],
            },
            "condition": [
                {
                    "column_name": "configuration_date",
                    "condition": "Smaller than equal to",
                    "input_value": str(valuation_date),
                    "and_or": "",
                },
            ],
        },
    )
    curve_repo_data = curve_repo_data.sort_values("configuration_date", ascending=False).drop_duplicates(
        subset=["curve_name"]
    )
    curve_components_data = read_data_func(
        request,
        {
            "inputs": {
                "Data_source": "Database",
                "Table": "ir_curve_components",
                "Columns": ["id", "curve_component", "tenor_value", "tenor_unit"],
            },
            "condition": [],
        },
    )
    cs_curve_repo_data = read_data_func(
        request,
        {
            "inputs": {
                "Data_source": "Database",
                "Table": "cs_curve_repository",
                "Columns": [
                    "configuration_date",
                    "curve_name",
                    "curve_components",
                    "interpolation_algorithm",
                ],
            },
            "condition": [
                {
                    "column_name": "configuration_date",
                    "condition": "Smaller than equal to",
                    "input_value": str(valuation_date),
                    "and_or": "",
                },
            ],
        },
    )
    cs_curve_repo_data = cs_curve_repo_data.sort_values(
        "configuration_date", ascending=False
    ).drop_duplicates(subset=["curve_name"])
    cs_curve_components_data = read_data_func(
        request,
        {
            "inputs": {
                "Data_source": "Database",
                "Table": "cs_curve_components",
                "Columns": ["id", "curve_component", "tenor_value", "tenor_unit"],
            },
            "condition": [],
        },
    )

    mtm_data = read_data_func(
        request,
        {
            "inputs": {
                "Data_source": "Database",
                "Table": "Quoted_Security_Data",
                "Order_Type": "ORDER BY created_date DESC",
                "Columns": [
                    "extract_date",
                    "security_identifier",
                    "quoted_price",
                    "yield",
                    "modified_duration",
                    "volume_traded",
                ],
            },
            "condition": [
                {
                    "column_name": "extract_date",
                    "condition": "Equal to",
                    "input_value": str(valuation_date),
                    "and_or": "",
                },
            ],
        },
    ).drop_duplicates(["extract_date", "security_identifier"])

    ## Filtering out data for par rates for base curve
    curve_component_transformation_vect = np.vectorize(curve_component_transformation)
    curve_component_transformation_result = curve_component_transformation_vect(
        curve_repo_data.to_dict("records")
    )
    curve_data = pd.concat(curve_component_transformation_result, ignore_index=True)
    del curve_component_transformation_result
    curve_data = curve_data.merge(
        curve_components_data, left_on="curve_components", right_on="id", how="left"
    ).drop(columns=["curve_components", "id"])
    curve_data["tenor"] = np.where(
        curve_data["tenor_unit"] == "D",
        curve_data["tenor_value"] / 365.25,
        np.where(curve_data["tenor_unit"] == "M", curve_data["tenor_value"] / 12, curve_data["tenor_value"]),
    )
    curve_data = (
        curve_data.merge(
            mtm_data.loc[
                mtm_data["extract_date"] == valuation_date,
                ["security_identifier", "quoted_price"],
            ],
            left_on="curve_component",
            right_on="security_identifier",
            how="left",
        )
        .drop(columns=["security_identifier"])
        .rename(columns={"quoted_price": "rate"})
    )
    curve_data.sort_values(by=["curve_name", "tenor"], inplace=True)

    cs_curve_component_transformation_result = curve_component_transformation_vect(
        cs_curve_repo_data.to_dict("records")
    )
    cs_curve_data = pd.concat(cs_curve_component_transformation_result, ignore_index=True)
    del cs_curve_component_transformation_result
    cs_curve_data = cs_curve_data.merge(
        cs_curve_components_data, left_on="curve_components", right_on="id", how="left"
    ).drop(columns=["curve_components", "id"])
    cs_curve_data["tenor"] = np.where(
        cs_curve_data["tenor_unit"] == "D",
        cs_curve_data["tenor_value"] / 365.25,
        np.where(
            cs_curve_data["tenor_unit"] == "M",
            cs_curve_data["tenor_value"] / 12,
            cs_curve_data["tenor_value"],
        ),
    )
    cs_curve_data = (
        cs_curve_data.merge(
            mtm_data.loc[
                mtm_data["extract_date"] == valuation_date,
                ["security_identifier", "quoted_price"],
            ],
            left_on="curve_component",
            right_on="security_identifier",
            how="left",
        )
        .drop(columns=["security_identifier"])
        .rename(columns={"quoted_price": "spread_value", "curve_name": "credit_spread_curve_name"})
    )
    cs_curve_data.sort_values(by=["credit_spread_curve_name", "tenor"], inplace=True)

    ## For those curve configurations where credit spread adjustment is applicable on par rates
    modified_curve_data = executeparallel(
        config_dict,
        position_data,
        credit_spread_adjustments_model,
        curve_data=curve_data,
        cs_curve_data=cs_curve_data,
        application_type="before",
    )
    ## to deal with multiple cases of credit adjustment applicable after bootstrapping
    modified_curve_data = modified_curve_data.drop_duplicates(subset=["curve_name", "tenor"])

    bootstrapping_results = executeparallel(
        config_dict,
        position_data,
        bootstrapping_model,
        market_data=modified_curve_data,
        original_market_data=curve_data,
        request_user=request,
    )
    bootstrapping_results = bootstrapping_results.drop_duplicates(subset=["curve_name", "time_to_maturity"])

    ## For those curve configurations where credit spread adjustment is applicable on zero rates
    adjusted_bootstrapping_results = executeparallel(
        config_dict,
        position_data,
        credit_spread_adjustments_model,
        curve_data=bootstrapping_results,
        cs_curve_data=cs_curve_data,
        application_type="after",
        request_user=request,
    )
    return adjusted_bootstrapping_results


def credit_spread_adjustments_model(row, column_index_dict, config_dict, **kwargs):
    curve_name = if_key_exists(row, column_index_dict, "discounting_curve")
    cs_curve_name = str(if_key_exists(row, column_index_dict, "credit_spread_curve"))

    config_dict = config_dict[curve_name]
    credit_spread_applicability = config_dict["credit_spread_applicability"]

    ## filtering market data based on curve names
    application_type = kwargs["application_type"]
    curve_data = kwargs["curve_data"]
    if config_dict["extract_from_database"] == "Yes":
        if credit_spread_applicability == "Not applicable" and application_type == "before":
            curve_data = curve_data.loc[curve_data["curve_name"] == curve_name + " Zero"]
        else:
            curve_data = curve_data.loc[curve_data["curve_name"] == curve_name]
    else:
        curve_data = curve_data.loc[curve_data["curve_name"] == curve_name]
    cs_curve_data = kwargs["cs_curve_data"]
    cs_curve_data = cs_curve_data.loc[cs_curve_data["credit_spread_curve_name"] == cs_curve_name]

    if credit_spread_applicability != "Not applicable":
        if credit_spread_applicability == "On par rates":
            if application_type == "before":
                curve_data_ttm = np.array(curve_data["tenor"])
                target_column = "rate"
            else:
                curve_data = kwargs["curve_data"]
                if cs_curve_name == "None" or cs_curve_name == "nan":
                    cs_curve_name = ""
                else:
                    cs_curve_name = " | " + cs_curve_name
                curve_name = curve_name + cs_curve_name
                curve_data = curve_data.loc[curve_data["curve_name"] == curve_name]
                return curve_data

        elif credit_spread_applicability == "On zero rates":
            if application_type == "after":
                curve_data_ttm = np.array(curve_data["time_to_maturity"])
                target_column = "zero_rate"
            else:
                return curve_data

        # to check for cases where no credit spread curve is specified
        if len(cs_curve_data) > 0:
            ## Converting to numpy arrays for interpolation
            cs_curve_data_ttm = np.array(cs_curve_data["tenor"])
            cs_curve_data_rates = np.array(cs_curve_data["spread_value"])
            adjusted_rates = np.empty([0], dtype="float64")
            for i in curve_data_ttm:
                interpolated_value = linearinterp(cs_curve_data_ttm, cs_curve_data_rates, float(i))
                if interpolated_value is None:
                    interpolated_value = flatexterp(cs_curve_data_ttm, cs_curve_data_rates, float(i))

                adjusted_rates = np.append(adjusted_rates, interpolated_value)

            if cs_curve_name == "None" or cs_curve_name == "nan":
                cs_curve_name = ""
            else:
                cs_curve_name = " | " + cs_curve_name
            curve_data["curve_name"] = curve_name + cs_curve_name

            curve_data["base_zero_rate"] = curve_data[target_column]
            curve_data["credit_spread"] = adjusted_rates
            if target_column == "rate":
                curve_data[target_column] = curve_data[target_column] + curve_data["credit_spread"] / 100
            else:
                curve_data[target_column] = curve_data["base_zero_rate"] + curve_data["credit_spread"]
        else:
            curve_data["credit_spread"] = 0

    return curve_data


def bootstrapping_model(row, column_index_dict, config_dict, **kwargs):
    curve_name = if_key_exists(row, column_index_dict, "discounting_curve")
    config_dict = config_dict[curve_name]
    credit_spread_applicability = config_dict["credit_spread_applicability"]
    if credit_spread_applicability == "On par rates":
        cs_curve_name = str(if_key_exists(row, column_index_dict, "credit_spread_curve"))
        if cs_curve_name == "None" or cs_curve_name == "nan":
            cs_curve_name = ""
        else:
            cs_curve_name = " | " + cs_curve_name
        curve_name = curve_name + cs_curve_name
    bootstrapping_method = config_dict["bootstrap_algorithm"]
    compounding_frequency = config_dict["compounding_frequency_output"]
    funding_spread = float(config_dict["funding_spread"]) / 100

    ## filtering market data based on curve name
    market_data = kwargs["market_data"]
    original_market_data = kwargs["original_market_data"]
    if config_dict["extract_from_database"] == "Yes":
        market_database_data = original_market_data.loc[
            original_market_data["curve_name"] == curve_name + " Zero"
        ]
        if len(market_database_data) > 0:
            market_database_data.rename(
                columns={"tenor": "time_to_maturity", "rate": "zero_rate"}, inplace=True
            )
            market_database_data.drop(columns=["curve_component", "tenor_value", "tenor_unit"], inplace=True)
            market_database_data["curve_name"] = curve_name
            market_database_data["output_frequency"] = compounding_frequency

            market_database_data["zero_rate"] = market_database_data["zero_rate"] * 100
            return market_database_data

    market_data = market_data.loc[market_data["curve_name"] == curve_name]
    kwargs["market_data"] = market_data
    ## calling function based on bootstrap method chosen
    if bootstrapping_method == "GSEC Bond Curve Bootstrapping":
        config_dict = {
            "inputs": {
                "option_config": {
                    "Tenor": "tenor",
                    "YTM": "rate",
                    "Par Lim Tenor": config_dict["bootstrap_short_term_tenor_limit"],
                    "Annual": config_dict["compounding_frequency_after_st_tenor"],
                    "Extraction Date": if_key_exists(row, column_index_dict, "reporting_date"),
                    "Output CF": config_dict["compounding_frequency_output"],
                }
            }
        }
        results = Single_Curve_Bootstrapping.singlecurve(kwargs, config_dict)[1]
        results.columns = [
            "time_to_maturity",
            "market_rate",
            "zero_rate",
            "extraction_date",
        ]
    elif bootstrapping_method == "OIS Curve Bootstrapping":
        oisb = OIS_Bootstrapping.OIS_Bootstrapping()
        results = oisb.spot_curve(
            df=market_data.reset_index(),
            tenor_col="tenor",
            ytm_col="rate",
            ext_date=if_key_exists(row, column_index_dict, "reporting_date"),
            st_tenor=float(config_dict["bootstrap_short_term_tenor_limit"]),
            method="fbil",
            fs=funding_spread,
            output_cf=config_dict["compounding_frequency_output"],
            cf_pre_st=config_dict["compounding_frequency_st_tenor"],
            cf_post_st=config_dict["compounding_frequency_after_st_tenor"],
            curve_name=curve_name,
            curve_data=config_dict["save_to_database"],
            curve_quote_data=config_dict["save_to_database"],
            request_user=kwargs["request_user"],
            configuration_date=if_key_exists(row, column_index_dict, "reporting_date"),
        )
        results = pd.DataFrame.from_dict(results[0]["Table"])
        results.columns = ["curve_name", "time_to_maturity", "market_rate", "zero_rate", "extraction_date"]
    elif bootstrapping_method == "Swap Curve Bootstrapping":
        config_dict = {
            "inputs": {
                "option_config": {
                    "s_tenor": "tenor",
                    "m_tenor": "tenor",
                    "l_tenor": "tenor",
                    "s_rate": "rate",
                    "m_rate": "rate",
                    "l_rate": "rate",
                    "YTM": "rate",
                    "Extraction Date": if_key_exists(row, column_index_dict, "reporting_date"),
                    "Short Term Tenor": config_dict["bootstrap_short_term_tenor_limit"],
                    "Medium Term Tenor": config_dict["bootstrap_medium_term_tenor_limit"],
                    "Short CF": config_dict["compounding_frequency_st_tenor"],
                    "Medium CF": config_dict["compounding_frequency_after_st_tenor"],
                    "Long CF": config_dict["compounding_frequency_after_st_tenor"],
                    "Output CF": config_dict["compounding_frequency_output"],
                    "Medium Instrument": "future",
                    "Swap Payment Frequency": config_dict["compounding_frequency_after_st_tenor"],
                }
            }
        }
        results = Swap_Curve.swap(kwargs, config_dict)[1]

    results["curve_name"] = curve_name
    results["output_frequency"] = compounding_frequency

    results["market_rate"] = results["market_rate"] * 100 - funding_spread
    results["zero_rate"] = results["zero_rate"] * 100
    market_data.rename(columns={"tenor": "time_to_maturity"}, inplace=True)

    ## Display for credit spread impact
    if credit_spread_applicability == "On par rates":
        results = results.merge(
            market_data[["curve_name", "time_to_maturity", "credit_spread"]],
            on=["curve_name", "time_to_maturity"],
            how="left",
        )

        results["credit_spread"] = results["credit_spread"].interpolate(method="linear")
        results["base_market_rate"] = results["market_rate"] - results["credit_spread"]
    return results


def interpolation_function(config_dict, request, data):
    config_dict = config_dict["inputs"]
    source_data = data["source_data"]
    target_data = data["target_data"]
    position_data = target_data.drop_duplicates(
        subset=[config_dict["x_column"], config_dict["reference_column"]]
    )
    interpolation_results = executeparallel(
        config_dict, position_data, interpolation_model, source_data=source_data
    )
    target_data = target_data.merge(
        interpolation_results, on=[config_dict["x_column"], config_dict["reference_column"]], how="left"
    ).drop_duplicates()

    return target_data


def interpolation_model(row, column_index_dict, config_dict, **kwargs):
    source_data = kwargs["source_data"]
    interpolation_algorithm = config_dict["interp_method"]
    extrapolation_method = config_dict["extrap_method"]
    reference_value = if_key_exists(row, column_index_dict, config_dict["reference_column"])
    target_x = if_key_exists(row, column_index_dict, config_dict["x_column"])

    source_data = source_data.loc[source_data[config_dict["reference_column"]] == reference_value]

    x_data = np.array(source_data[config_dict["x_column"]].to_list(), dtype="float64")
    y_data = np.array(source_data[config_dict["y_column"]].to_list(), dtype="float64")
    if interpolation_algorithm == "Linear":
        interpolated_value = linearinterp(x_data, y_data, float(target_x))
        if interpolated_value is None:
            if extrapolation_method == "Linear":
                interpolated_value = linearexterp(x_data, y_data, float(target_x))
            elif extrapolation_method == "Flat":
                interpolated_value = flatexterp(x_data, y_data, float(target_x))
    if "output_frequency" in source_data.columns:
        results = pd.DataFrame(
            [[reference_value, target_x, interpolated_value, source_data["output_frequency"].iloc[0]]],
            columns=[
                config_dict["reference_column"],
                config_dict["x_column"],
                config_dict["y_column"],
                "output_frequency",
            ],
        )
    else:
        results = pd.DataFrame(
            [[reference_value, target_x, interpolated_value]],
            columns=[config_dict["reference_column"], config_dict["x_column"], config_dict["y_column"]],
        )

    return results


def discount_factor_function(config_dict, request, data):

    interpolated_data = data["previous_result_data"]

    discount_factors_results = executeparallel(config_dict, interpolated_data, discount_factor_model)
    interpolated_data = interpolated_data.merge(
        discount_factors_results, on=["output_frequency", "zero_rate", "time_to_maturity"], how="left"
    ).drop_duplicates()

    if "cashflow" in interpolated_data.columns:
        interpolated_data["cf_pv"] = interpolated_data["cashflow"] * interpolated_data["discount_factor"]

    return interpolated_data


def discount_factor_model(row, column_index_dict, config_dict, **kwargs):

    rate_column = config_dict["inputs"]["rate"]
    ttm_column = config_dict["inputs"]["ttm"]
    frequency_column = config_dict["inputs"]["frequency"]

    cf = if_key_exists(row, column_index_dict, frequency_column)
    rate = if_key_exists(row, column_index_dict, rate_column)
    ttm = if_key_exists(row, column_index_dict, ttm_column)

    if cf in ["monthly", "Monthly"]:
        discount_factor = math.pow(1 + rate / 1200, -12 * ttm)
    elif cf in ["quarterly", "Quarterly"]:
        discount_factor = math.pow(1 + rate / 400, -4 * ttm)
    elif cf in ["semi-annualised", "Semi-Annual", "semi-annually"]:
        discount_factor = math.pow(1 + rate / 200, -2 * ttm)
    elif cf in ["bi-annual", "Bi-Annual", "bi-annually"]:
        discount_factor = math.pow(1 + rate / 50, -0.5 * ttm)
    elif cf in ["annualised", "Annual", "annually"]:
        discount_factor = math.pow(1 + rate, -ttm)
    else:
        discount_factor = math.exp(rate * ttm * (-1) / 100)

    results = pd.DataFrame(
        [[cf, rate, ttm, discount_factor]],
        columns=[frequency_column, rate_column, ttm_column, "discount_factor"],
    )

    return results


def if_key_exists(row, dictionary, key, value_type="others"):
    if key in dictionary.keys():
        return row[dictionary[key]]
    else:
        if value_type == "float":
            return 0
        elif value_type == "str":
            return ""
        elif value_type == "date":
            return None
        else:
            return None


## Volatility calculation from surface ##


# Goal seek
def optimized_vol(
    vol_test, calc_vol, spot_price, strike_price, ttm, r, q, x, y, interpolation_method, extrapolation_method
):
    diff = abs(vol_test - calc_vol) * 1000
    max_iter = 250
    iter_no = 0

    while diff > 0.0000001 and iter_no <= max_iter:
        vol_test = calc_vol
        BS = Options_Pricing.Black_Scholes(
            S=spot_price,
            K=strike_price,
            T=ttm,
            r=r,
            div=q,
            sigma=vol_test,
        )
        delta = BS.delta("call")
        calc_vol = volatility_interpolation_extrapolation(
            x, y, delta, interpolation_method, extrapolation_method
        )
        diff = abs(vol_test - calc_vol) * 1000
        iter_no = iter_no + 1

    return calc_vol


# Interpolation and Extrapolation
def volatility_interpolation_extrapolation(x, y, param, interpolation_method, extrapolation_method):
    # Interpolation
    if interpolation_method == "Cubic Spline":
        volatility = cubicspline(x, y, param)
    elif interpolation_method == "Linear":
        volatility = linearinterp(x, y, param)
    else:
        pass

    # Extrapolation
    if volatility is None:
        if extrapolation_method == "Linear":
            volatility = linearexterp(x, y, param)
        else:
            volatility = flatexterp(x, y, param)
    return volatility


def volatility_calculation_from_surface(vol_data_filtered, spot_price=0, strike_price=0, T=0, r=0, q=0):
    vol_surface_pivoted = pd.pivot(vol_data_filtered, index="tenor", values="volatility", columns="delta")

    ttm_lower = vol_surface_pivoted.loc[vol_surface_pivoted.index <= T].index[-1]
    vol_surface_lower = vol_surface_pivoted.loc[vol_surface_pivoted.index == ttm_lower]
    ttm_upper = vol_surface_pivoted.loc[vol_surface_pivoted.index <= T + 1].index[-1]
    vol_surface_upper = vol_surface_pivoted.loc[vol_surface_pivoted.index == ttm_upper]
    interpolation_algorithm_smile = vol_data_filtered["interpolation_smile"].iloc[0]
    extrapolation_algorithm_smile = vol_data_filtered["extrapolation_smile"].iloc[0]
    smile_interpolation_parameter = vol_data_filtered["smile_interpolation_parameter"].iloc[0]

    # Smile Intepolation
    if smile_interpolation_parameter == "Delta":
        vol_test_lower = 0.0053
        BS = Options_Pricing.Black_Scholes(
            S=spot_price,
            K=strike_price,
            T=ttm_lower,
            r=r,
            div=q,
            sigma=vol_test_lower,
        )
        delta_lower = BS.delta("call")
        vol_test_upper = 0.0054
        BS = Options_Pricing.Black_Scholes(
            S=spot_price,
            K=strike_price,
            T=ttm_upper,
            r=r,
            div=q,
            sigma=vol_test_upper,
        )
        delta_upper = BS.delta("call")
        lower_vol_inter = volatility_interpolation_extrapolation(
            vol_surface_lower.columns.values,
            vol_surface_lower.values[0],
            delta_lower,
            interpolation_algorithm_smile,
            extrapolation_algorithm_smile,
        )
        upper_vol_inter = volatility_interpolation_extrapolation(
            vol_surface_upper.columns.values,
            vol_surface_upper.values[0],
            delta_upper,
            interpolation_algorithm_smile,
            extrapolation_algorithm_smile,
        )

        lower_vol_final = optimized_vol(
            vol_test_lower,
            lower_vol_inter,
            spot_price,
            strike_price,
            ttm_lower,
            r,
            q,
            vol_surface_lower.columns.values,
            vol_surface_lower.values[0],
            interpolation_algorithm_smile,
            extrapolation_algorithm_smile,
        )
        upper_vol_final = optimized_vol(
            vol_test_upper,
            upper_vol_inter,
            spot_price,
            strike_price,
            ttm_upper,
            r,
            q,
            vol_surface_upper.columns.values,
            vol_surface_upper.values[0],
            interpolation_algorithm_smile,
            extrapolation_algorithm_smile,
        )

    elif smile_interpolation_parameter == "Strike":
        lower_vol_final = volatility_interpolation_extrapolation(
            vol_surface_lower.columns.values,
            vol_surface_lower.values[0],
            strike_price,
            interpolation_algorithm_smile,
            extrapolation_algorithm_smile,
        )
        upper_vol_final = volatility_interpolation_extrapolation(
            vol_surface_lower.columns.values,
            vol_surface_upper.values[0],
            strike_price,
            interpolation_algorithm_smile,
            extrapolation_algorithm_smile,
        )

    else:
        pass

    # Term Structure Interpolation
    interpolation_algorithm_tenor = vol_data_filtered["interpolation_tenor"].iloc[0]
    extrapolation_algorithm_tenor = vol_data_filtered["extrapolation_tenor"].iloc[0]
    tenor_interpolation_parameter = vol_data_filtered["tenor_interpolation_parameter"].iloc[0]

    if tenor_interpolation_parameter == "Linear Total Variance":
        lower_linear_total_variance = lower_vol_final * lower_vol_final * ttm_lower
        upper_linear_total_variance = upper_vol_final * upper_vol_final * ttm_upper
        result = volatility_interpolation_extrapolation(
            np.array([ttm_lower, ttm_upper]),
            np.array([lower_linear_total_variance, upper_linear_total_variance]),
            T,
            interpolation_algorithm_tenor,
            extrapolation_algorithm_tenor,
        )
        final_volatility = np.sqrt(result / T)
    elif tenor_interpolation_parameter == "Variance":
        lower_variance = lower_vol_final * lower_vol_final
        upper_variance = upper_vol_final * upper_vol_final
        result = volatility_interpolation_extrapolation(
            np.array([ttm_lower, ttm_upper]),
            np.array([lower_variance, upper_variance]),
            T,
            interpolation_algorithm_tenor,
            extrapolation_algorithm_tenor,
        )
        final_volatility = np.sqrt(result)
    elif tenor_interpolation_parameter == "Volatility":
        final_volatility = volatility_interpolation_extrapolation(
            np.array([ttm_lower, ttm_upper]),
            np.array([lower_vol_final, upper_vol_final]),
            T,
            interpolation_algorithm_tenor,
            extrapolation_algorithm_tenor,
        )

    return final_volatility


def barrier_fx_greeks_computation(model_class, call_type, option_type):
    if call_type == "call" and option_type == "down and out":
        price_df = model_class.down_out_call()
    if call_type == "call" and option_type == "up and out":
        price_df = model_class.up_out_call()
    if call_type == "call" and option_type == "down and in":
        price_df = model_class.down_in_call()
    if call_type == "call" and option_type == "up and in":
        price_df = model_class.up_in_call()
    if call_type == "put" and option_type == "down and out":
        price_df = model_class.down_out_put()
    if call_type == "put" and option_type == "up and out":
        price_df = model_class.up_out_put()
    if call_type == "put" and option_type == "down and in":
        price_df = model_class.down_in_put()
    if call_type == "put" and option_type == "up and in":
        price_df = model_class.up_in_put()
    return float(price_df)


def digital_fx_greeks_computation(model_class, call_type):
    if call_type == "call":
        price_df = model_class.call()
    if call_type == "put":
        price_df = model_class.put()
    return float(price_df)


## Custom Date Function ##


def nth_weekday(date_val, nth_week, week_day):
    temp = pd.to_datetime(date_val).replace(day=1)
    adj = (week_day - temp.weekday()) % 7
    temp += timedelta(days=int(adj))
    temp += timedelta(weeks=int(nth_week) - 1)
    return temp


nth_weekday_vectorized = np.vectorize(nth_weekday)


def payment_window_adjustment(date_val, repayment_start, repayment_end):
    if date_val.day < repayment_start:
        date_val_adjusted = date_val + timedelta(days=7)
    elif date_val.day > repayment_end:
        date_val_adjusted = date_val - timedelta(days=7)
    else:
        date_val_adjusted = date_val
    return date_val_adjusted


payment_window_adjustment_vectorized = np.vectorize(payment_window_adjustment)


def week_code_generator(payment_day):
    if payment_day == "Monday":
        return 0
    elif payment_day == "Tuesday":
        return 1
    elif payment_day == "Wednesday":
        return 2
    elif payment_day == "Thursday":
        return 3
    elif payment_day == "Friday":
        return 4
    elif payment_day == "Saturday":
        return 5
    elif payment_day == "Sunday":
        return 6
